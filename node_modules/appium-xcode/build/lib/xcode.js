'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _appiumSupport = require('appium-support');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _asyncbox = require('asyncbox');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _plist = require('plist');

var _teen_process = require('teen_process');

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var env = process.env;

var XCRUN_TIMEOUT = 15000;
var XCODE_SUBDIR = "/Contents/Developer";
var DEFAULT_NUMBER_OF_RETRIES = 3;

var log = _appiumSupport.logger.getLogger('Xcode');

function hasExpectedSubDir(path) {
  return path.substring(path.length - XCODE_SUBDIR.length) === XCODE_SUBDIR;
}

function runXcrunCommand(args) {
  var timeout = arguments.length <= 1 || arguments[1] === undefined ? XCRUN_TIMEOUT : arguments[1];
  return _regeneratorRuntime.async(function runXcrunCommand$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('xcrun', args, { timeout: timeout }));

      case 3:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 6:
        context$1$0.prev = 6;
        context$1$0.t0 = context$1$0['catch'](0);

        // the true error can be hidden within the stderr
        if (context$1$0.t0.stderr) {
          context$1$0.t0.message = context$1$0.t0.message + ': ' + context$1$0.t0.stderr;
        }

        throw context$1$0.t0;

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 6]]);
}

function getPathFromSymlink(failMessage) {
  var symlinkPath, legacySymlinkPath, xcodePath, customPath, mesg, msg;
  return _regeneratorRuntime.async(function getPathFromSymlink$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        // Node's invocation of xcode-select sometimes flakes and returns an empty string.
        // Not clear why. As a workaround, Appium can reliably deduce the version in use by checking
        // the locations xcode-select uses to store the selected version's path. This should be 100%
        // reliable so long as the link locations remain the same. However, since we're relying on
        // hardcoded paths, this approach will break the next time Apple changes the symlink location.
        log.warn('Finding XcodePath by symlink because ' + failMessage);

        symlinkPath = "/var/db/xcode_select_link";
        legacySymlinkPath = "/usr/share/xcode-select/xcode_dir_link";
        xcodePath = null;

        if (!_appiumSupport.util.hasContent(env.DEVELOPER_DIR)) {
          context$1$0.next = 17;
          break;
        }

        customPath = hasExpectedSubDir(env.DEVELOPER_DIR) ? env.DEVELOPER_DIR : env.DEVELOPER_DIR + XCODE_SUBDIR;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(customPath));

      case 8:
        if (!context$1$0.sent) {
          context$1$0.next = 12;
          break;
        }

        xcodePath = customPath;
        context$1$0.next = 15;
        break;

      case 12:
        mesg = 'Could not find path to Xcode, environment variable ' + ('DEVELOPER_DIR set to: ' + env.DEVELOPER_DIR + ' ') + 'but no Xcode found';

        log.warn(mesg);
        throw new Error(mesg);

      case 15:
        context$1$0.next = 31;
        break;

      case 17:
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(symlinkPath));

      case 19:
        if (!context$1$0.sent) {
          context$1$0.next = 25;
          break;
        }

        context$1$0.next = 22;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.readlink(symlinkPath));

      case 22:
        xcodePath = context$1$0.sent;
        context$1$0.next = 31;
        break;

      case 25:
        context$1$0.next = 27;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(legacySymlinkPath));

      case 27:
        if (!context$1$0.sent) {
          context$1$0.next = 31;
          break;
        }

        context$1$0.next = 30;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.readlink(legacySymlinkPath));

      case 30:
        xcodePath = context$1$0.sent;

      case 31:
        if (!xcodePath) {
          context$1$0.next = 33;
          break;
        }

        return context$1$0.abrupt('return', xcodePath.replace(new RegExp("/$"), "").trim());

      case 33:
        msg = 'Could not find path to Xcode by symlinks located in ' + symlinkPath + ', or ' + legacySymlinkPath;

        log.warn(msg);
        throw new Error(msg);

      case 36:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function getPathFromXcodeSelect() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? XCRUN_TIMEOUT : arguments[0];

  var _ref, stdout, xcodeFolderPath, msg;

  return _regeneratorRuntime.async(function getPathFromXcodeSelect$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('xcode-select', ['--print-path'], { timeout: timeout }));

      case 2:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;
        xcodeFolderPath = stdout.replace(/\/$/, '').trim();

        if (!_appiumSupport.util.hasContent(xcodeFolderPath)) {
          log.errorAndThrow('xcode-select returned an empty string');
        }

        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(xcodeFolderPath));

      case 8:
        if (!context$1$0.sent) {
          context$1$0.next = 12;
          break;
        }

        return context$1$0.abrupt('return', xcodeFolderPath);

      case 12:
        msg = 'xcode-select could not find xcode. Path \'' + xcodeFolderPath + '\' does not exist.';

        log.errorAndThrow(msg);

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getPath = _lodash2['default'].memoize(function () {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? XCRUN_TIMEOUT : arguments[0];

  // first we try using xcode-select to find the path
  // then we try using the symlinks that Apple has by default
  return getPathFromXcodeSelect(timeout)['catch'](getPathFromSymlink);
});

function getVersionWithoutRetry() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? XCRUN_TIMEOUT : arguments[0];
  var xcodePath, plistPath, version;
  return _regeneratorRuntime.async(function getVersionWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(getPath(timeout));

      case 2:
        xcodePath = context$1$0.sent;
        plistPath = _path2['default'].resolve(xcodePath, "..", "Info.plist");
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(plistPath));

      case 6:
        if (context$1$0.sent) {
          context$1$0.next = 8;
          break;
        }

        throw new Error('Could not get Xcode version. ' + plistPath + ' does not exist on disk.');

      case 8:
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(_appiumSupport.plist.parsePlistFile(plistPath));

      case 10:
        version = context$1$0.sent;
        return context$1$0.abrupt('return', _semver2['default'].coerce(version.CFBundleShortVersionString));

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getVersionMemoized = _lodash2['default'].memoize(function () {
  var retries = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];
  var timeout = arguments.length <= 1 || arguments[1] === undefined ? XCRUN_TIMEOUT : arguments[1];

  return (0, _asyncbox.retry)(retries, getVersionWithoutRetry, timeout);
});

function getVersion() {
  var parse = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
  var retries = arguments.length <= 1 || arguments[1] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[1];
  var timeout = arguments.length <= 2 || arguments[2] === undefined ? XCRUN_TIMEOUT : arguments[2];
  var version, versionString;
  return _regeneratorRuntime.async(function getVersion$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(getVersionMemoized(retries, timeout));

      case 2:
        version = context$1$0.sent;
        versionString = version.patch > 0 ? version.version : version.major + '.' + version.minor;

        if (parse) {
          context$1$0.next = 6;
          break;
        }

        return context$1$0.abrupt('return', versionString);

      case 6:
        return context$1$0.abrupt('return', {
          versionString: versionString,
          versionFloat: parseFloat(versionString),
          major: version.major,
          minor: version.minor,
          patch: version.patch > 0 ? version.patch : undefined
        });

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function getCommandLineToolsVersion() {
  var getVersionFunctions, stdout, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _getVersion, match;

  return _regeneratorRuntime.async(function getCommandLineToolsVersion$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        getVersionFunctions = [function callee$1$0() {
          var pkg;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)('pkgutil', ['--pkgs=com.apple.pkg.DevSDK_.*']));

              case 2:
                pkg = context$2$0.sent.stdout;
                context$2$0.next = 5;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)('pkgutil', ['--pkg-info=' + pkg.trim()]));

              case 5:
                return context$2$0.abrupt('return', context$2$0.sent.stdout);

              case 6:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }, function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)('pkgutil', ['--pkg-info=com.apple.pkg.CLTools_Executables']));

              case 2:
                return context$2$0.abrupt('return', context$2$0.sent.stdout);

              case 3:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }, function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)('pkgutil', ['--pkg-info=com.apple.pkg.DeveloperToolsCLI']));

              case 2:
                return context$2$0.abrupt('return', context$2$0.sent.stdout);

              case 3:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }];
        stdout = undefined;
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 5;
        _iterator = _getIterator(getVersionFunctions);

      case 7:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 22;
          break;
        }

        _getVersion = _step.value;
        context$1$0.prev = 9;
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(_getVersion());

      case 12:
        stdout = context$1$0.sent;
        return context$1$0.abrupt('break', 22);

      case 16:
        context$1$0.prev = 16;
        context$1$0.t0 = context$1$0['catch'](9);

        stdout = '';

      case 19:
        _iteratorNormalCompletion = true;
        context$1$0.next = 7;
        break;

      case 22:
        context$1$0.next = 28;
        break;

      case 24:
        context$1$0.prev = 24;
        context$1$0.t1 = context$1$0['catch'](5);
        _didIteratorError = true;
        _iteratorError = context$1$0.t1;

      case 28:
        context$1$0.prev = 28;
        context$1$0.prev = 29;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 31:
        context$1$0.prev = 31;

        if (!_didIteratorError) {
          context$1$0.next = 34;
          break;
        }

        throw _iteratorError;

      case 34:
        return context$1$0.finish(31);

      case 35:
        return context$1$0.finish(28);

      case 36:
        match = /^version: (.+)$/m.exec(stdout);
        return context$1$0.abrupt('return', match ? match[1] : undefined);

      case 38:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[5, 24, 28, 36], [9, 16], [29,, 31, 35]]);
}

function getAutomationTraceTemplatePathWithoutRetry() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? XCRUN_TIMEOUT : arguments[0];
  var xcodePath, extensions, pathPrefix, pathSuffix, automationTraceTemplatePaths, msg;
  return _regeneratorRuntime.async(function getAutomationTraceTemplatePathWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(getPath(timeout));

      case 2:
        xcodePath = context$1$0.sent;
        extensions = ['xrplugin', 'bundle'];
        pathPrefix = _path2['default'].resolve(xcodePath, "../Applications/Instruments.app/Contents/PlugIns");
        pathSuffix = "Contents/Resources/Automation.tracetemplate";
        automationTraceTemplatePaths = [_path2['default'].resolve(pathPrefix, 'AutomationInstrument.' + extensions[0], pathSuffix), _path2['default'].resolve(pathPrefix, 'AutomationInstrument.' + extensions[1], pathSuffix)];
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(automationTraceTemplatePaths[0]));

      case 9:
        if (!context$1$0.sent) {
          context$1$0.next = 11;
          break;
        }

        return context$1$0.abrupt('return', automationTraceTemplatePaths[0]);

      case 11:
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(automationTraceTemplatePaths[1]));

      case 13:
        if (!context$1$0.sent) {
          context$1$0.next = 15;
          break;
        }

        return context$1$0.abrupt('return', automationTraceTemplatePaths[1]);

      case 15:
        msg = "Could not find Automation.tracetemplate in any of the following" + ('locations ' + automationTraceTemplatePaths.toString());

        log.error(msg);
        throw new Error(msg);

      case 18:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getAutomationTraceTemplatePath = _lodash2['default'].memoize(function () {
  var retries = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];
  var timeout = arguments.length <= 1 || arguments[1] === undefined ? XCRUN_TIMEOUT : arguments[1];

  return (0, _asyncbox.retry)(retries, getAutomationTraceTemplatePathWithoutRetry, timeout);
});

function getMaxIOSSDKWithoutRetry() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? XCRUN_TIMEOUT : arguments[0];

  var version, args, _ref2, stdout, sdkVersion, match;

  return _regeneratorRuntime.async(function getMaxIOSSDKWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(getVersion(false, DEFAULT_NUMBER_OF_RETRIES, timeout));

      case 2:
        version = context$1$0.sent;

        if (!(version[0] === '4')) {
          context$1$0.next = 5;
          break;
        }

        return context$1$0.abrupt('return', '6.1');

      case 5:
        args = ['--sdk', 'iphonesimulator', '--show-sdk-version'];
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(runXcrunCommand(args, timeout));

      case 8:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;
        sdkVersion = stdout.trim();
        match = /\d.\d/.exec(stdout);

        if (match) {
          context$1$0.next = 14;
          break;
        }

        throw new Error('xcrun returned a non-numeric iOS SDK version: \'' + sdkVersion + '\'');

      case 14:
        return context$1$0.abrupt('return', sdkVersion);

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getMaxIOSSDK = _lodash2['default'].memoize(function () {
  var retries = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];
  var timeout = arguments.length <= 1 || arguments[1] === undefined ? XCRUN_TIMEOUT : arguments[1];

  return (0, _asyncbox.retry)(retries, getMaxIOSSDKWithoutRetry, timeout);
});

function getMaxTVOSSDKWithoutRetry() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? XCRUN_TIMEOUT : arguments[0];

  var args, _ref3, stdout, sdkVersion;

  return _regeneratorRuntime.async(function getMaxTVOSSDKWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        args = ['--sdk', 'appletvsimulator', '--show-sdk-version'];
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(runXcrunCommand(args, timeout));

      case 3:
        _ref3 = context$1$0.sent;
        stdout = _ref3.stdout;
        sdkVersion = stdout.trim();

        if (!isNaN(parseFloat(sdkVersion))) {
          context$1$0.next = 8;
          break;
        }

        throw new Error('xcrun returned a non-numeric tvOS SDK version: \'' + sdkVersion + '\'');

      case 8:
        return context$1$0.abrupt('return', sdkVersion);

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getMaxTVOSSDK = _lodash2['default'].memoize(function () {
  var retries = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];
  var timeout = arguments.length <= 1 || arguments[1] === undefined ? XCRUN_TIMEOUT : arguments[1];

  return (0, _asyncbox.retry)(retries, getMaxTVOSSDKWithoutRetry, timeout);
});

function getConnectedDevices() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? XCRUN_TIMEOUT : arguments[0];

  var cmd, args, _ref4, stdout, plistContent, devicesFound, entriesToSearch, currentEntry, deviceInfo;

  return _regeneratorRuntime.async(function getConnectedDevices$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        cmd = '/usr/sbin/system_profiler';
        args = ['-xml', 'SPUSBDataType'];
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, args, { timeout: timeout }));

      case 4:
        _ref4 = context$1$0.sent;
        stdout = _ref4.stdout;
        plistContent = (0, _plist.parse)(stdout);
        devicesFound = [];
        entriesToSearch = [plistContent[0]];

        while (entriesToSearch.length > 0) {
          currentEntry = entriesToSearch.pop();

          if (currentEntry instanceof Array) {
            entriesToSearch = entriesToSearch.concat(currentEntry);
          } else if (currentEntry._name && currentEntry._name.substring(0, 4) === "iPad" || currentEntry._name && currentEntry._name.substring(0, 6) === "iPhone" || currentEntry._name && _lodash2['default'].includes(currentEntry._name, "Apple TV")) {
            deviceInfo = {
              name: currentEntry._name,
              udid: currentEntry.serial_num,
              productId: currentEntry.product_id,
              deviceVersion: currentEntry.bcd_device
            };

            devicesFound.push(deviceInfo);
          } else if (currentEntry._items) {
            entriesToSearch = entriesToSearch.concat(currentEntry._items);
          }
        }
        return context$1$0.abrupt('return', devicesFound);

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function getInstrumentsPathWithoutRetry() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? XCRUN_TIMEOUT : arguments[0];

  var args, _ref5, stdout, instrumentsPath;

  return _regeneratorRuntime.async(function getInstrumentsPathWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        args = ['-find', 'instruments'];
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(runXcrunCommand(args, timeout));

      case 3:
        _ref5 = context$1$0.sent;
        stdout = _ref5.stdout;

        if (!stdout) {
          stdout = "";
        }

        instrumentsPath = stdout.trim();

        if (instrumentsPath) {
          context$1$0.next = 9;
          break;
        }

        throw new Error('Could not find path to instruments binary using \'xcrun ' + args.join(' ') + '\'');

      case 9:
        return context$1$0.abrupt('return', instrumentsPath);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getInstrumentsPath = _lodash2['default'].memoize(function () {
  var retries = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];
  var timeout = arguments.length <= 1 || arguments[1] === undefined ? XCRUN_TIMEOUT : arguments[1];

  return (0, _asyncbox.retry)(retries, getInstrumentsPathWithoutRetry, timeout);
});

function clearInternalCache() {

  // memoized functions
  var memoized = [getPath, getVersionMemoized, getAutomationTraceTemplatePath, getMaxIOSSDK, getMaxTVOSSDK, getInstrumentsPath];

  memoized.forEach(function (f) {
    if (f.cache) {
      f.cache = new _lodash2['default'].memoize.Cache();
    }
  });
}

exports['default'] = { getPath: getPath, getVersion: getVersion, getAutomationTraceTemplatePath: getAutomationTraceTemplatePath, getMaxIOSSDK: getMaxIOSSDK,
  getAutomationTraceTemplatePathWithoutRetry: getAutomationTraceTemplatePathWithoutRetry, getMaxIOSSDKWithoutRetry: getMaxIOSSDKWithoutRetry,
  getConnectedDevices: getConnectedDevices, clearInternalCache: clearInternalCache, getInstrumentsPath: getInstrumentsPath,
  getCommandLineToolsVersion: getCommandLineToolsVersion, getMaxTVOSSDK: getMaxTVOSSDK, getMaxTVOSSDKWithoutRetry: getMaxTVOSSDKWithoutRetry };
module.exports = exports['default'];
//  Xcode < 5.x

// xcode-select allows users to override its settings with the DEVELOPER_DIR env var,
// so check that first

// We should only get here is we failed to capture xcode-select's stdout and our
// other checks failed. Either Apple has moved the symlink to a new location or the user
// is not using the default install. 99.999% chance it's the latter, so issue a warning
// should we ever hit the edge case.

// trim and remove trailing slash

// we want to read the CFBundleShortVersionString from Xcode's plist.
// It should be in /[root]/XCode.app/Contents/

// xcode version strings are not exactly semver string: patch versions of 0
// are removed (e.g., '10.0.0' => '10.0')

// there are a number of different ways that the CLI tools version has been
// represented. Try them from most reliable to least, falling down the chain

// stdout should have a line like `version: 8.0.0.0.1.1472435881`
// https://regex101.com/r/HV3x4d/1

// for ios 8 and up, the file extension for AutiomationInstrument changed.
// rather than waste time getting the iOSSDKVersion, just get both paths and see which one exists
//# sourceMappingURL=data:application/json;charset=utf8;base64,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QUEwQyxFQUFFLHdCQUF3QixFQUF4Qix3QkFBd0I7QUFDcEUscUJBQW1CLEVBQW5CLG1CQUFtQixFQUFFLGtCQUFrQixFQUFsQixrQkFBa0IsRUFBRSxrQkFBa0IsRUFBbEIsa0JBQWtCO0FBQzNELDRCQUEwQixFQUExQiwwQkFBMEIsRUFBRSxhQUFhLEVBQWIsYUFBYSxFQUFFLHlCQUF5QixFQUF6Qix5QkFBeUIsRUFBRSIsImZpbGUiOiJsaWIveGNvZGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1dGlsLCBmcywgcGxpc3QsIGxvZ2dlciB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgcmV0cnkgfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgcGFyc2UgYXMgcGFyc2VQbGlzdERhdGEgfSBmcm9tICdwbGlzdCc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJztcblxuXG5jb25zdCBlbnYgPSBwcm9jZXNzLmVudjtcblxuY29uc3QgWENSVU5fVElNRU9VVCA9IDE1MDAwO1xuY29uc3QgWENPREVfU1VCRElSID0gXCIvQ29udGVudHMvRGV2ZWxvcGVyXCI7XG5jb25zdCBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTID0gMztcblxuY29uc3QgbG9nID0gbG9nZ2VyLmdldExvZ2dlcignWGNvZGUnKTtcblxuXG5mdW5jdGlvbiBoYXNFeHBlY3RlZFN1YkRpciAocGF0aCkge1xuICByZXR1cm4gcGF0aC5zdWJzdHJpbmcocGF0aC5sZW5ndGggLSBYQ09ERV9TVUJESVIubGVuZ3RoKSA9PT0gWENPREVfU1VCRElSO1xufVxuXG5hc3luYyBmdW5jdGlvbiBydW5YY3J1bkNvbW1hbmQgKGFyZ3MsIHRpbWVvdXQgPSBYQ1JVTl9USU1FT1VUKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGV4ZWMoJ3hjcnVuJywgYXJncywge3RpbWVvdXR9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gdGhlIHRydWUgZXJyb3IgY2FuIGJlIGhpZGRlbiB3aXRoaW4gdGhlIHN0ZGVyclxuICAgIGlmIChlcnIuc3RkZXJyKSB7XG4gICAgICBlcnIubWVzc2FnZSA9IGAke2Vyci5tZXNzYWdlfTogJHtlcnIuc3RkZXJyfWA7XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFBhdGhGcm9tU3ltbGluayAoZmFpbE1lc3NhZ2UpIHtcbiAgLy8gTm9kZSdzIGludm9jYXRpb24gb2YgeGNvZGUtc2VsZWN0IHNvbWV0aW1lcyBmbGFrZXMgYW5kIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICAvLyBOb3QgY2xlYXIgd2h5LiBBcyBhIHdvcmthcm91bmQsIEFwcGl1bSBjYW4gcmVsaWFibHkgZGVkdWNlIHRoZSB2ZXJzaW9uIGluIHVzZSBieSBjaGVja2luZ1xuICAvLyB0aGUgbG9jYXRpb25zIHhjb2RlLXNlbGVjdCB1c2VzIHRvIHN0b3JlIHRoZSBzZWxlY3RlZCB2ZXJzaW9uJ3MgcGF0aC4gVGhpcyBzaG91bGQgYmUgMTAwJVxuICAvLyByZWxpYWJsZSBzbyBsb25nIGFzIHRoZSBsaW5rIGxvY2F0aW9ucyByZW1haW4gdGhlIHNhbWUuIEhvd2V2ZXIsIHNpbmNlIHdlJ3JlIHJlbHlpbmcgb25cbiAgLy8gaGFyZGNvZGVkIHBhdGhzLCB0aGlzIGFwcHJvYWNoIHdpbGwgYnJlYWsgdGhlIG5leHQgdGltZSBBcHBsZSBjaGFuZ2VzIHRoZSBzeW1saW5rIGxvY2F0aW9uLlxuICBsb2cud2FybihgRmluZGluZyBYY29kZVBhdGggYnkgc3ltbGluayBiZWNhdXNlICR7ZmFpbE1lc3NhZ2V9YCk7XG5cbiAgY29uc3Qgc3ltbGlua1BhdGggPSBcIi92YXIvZGIveGNvZGVfc2VsZWN0X2xpbmtcIjtcbiAgY29uc3QgbGVnYWN5U3ltbGlua1BhdGggPSBcIi91c3Ivc2hhcmUveGNvZGUtc2VsZWN0L3hjb2RlX2Rpcl9saW5rXCI7IC8vICBYY29kZSA8IDUueFxuICBsZXQgeGNvZGVQYXRoID0gbnVsbDtcblxuICAvLyB4Y29kZS1zZWxlY3QgYWxsb3dzIHVzZXJzIHRvIG92ZXJyaWRlIGl0cyBzZXR0aW5ncyB3aXRoIHRoZSBERVZFTE9QRVJfRElSIGVudiB2YXIsXG4gIC8vIHNvIGNoZWNrIHRoYXQgZmlyc3RcbiAgaWYgKHV0aWwuaGFzQ29udGVudChlbnYuREVWRUxPUEVSX0RJUikpIHtcbiAgICBjb25zdCBjdXN0b21QYXRoID0gaGFzRXhwZWN0ZWRTdWJEaXIoZW52LkRFVkVMT1BFUl9ESVIpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW52LkRFVkVMT1BFUl9ESVIgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW52LkRFVkVMT1BFUl9ESVIgKyBYQ09ERV9TVUJESVI7XG5cbiAgICBpZiAoYXdhaXQgZnMuZXhpc3RzKGN1c3RvbVBhdGgpKSB7XG4gICAgICB4Y29kZVBhdGggPSBjdXN0b21QYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWVzZyA9IGBDb3VsZCBub3QgZmluZCBwYXRoIHRvIFhjb2RlLCBlbnZpcm9ubWVudCB2YXJpYWJsZSBgICtcbiAgICAgICAgICAgICAgICAgYERFVkVMT1BFUl9ESVIgc2V0IHRvOiAke2Vudi5ERVZFTE9QRVJfRElSfSBgICtcbiAgICAgICAgICAgICAgICAgYGJ1dCBubyBYY29kZSBmb3VuZGA7XG4gICAgICBsb2cud2FybihtZXNnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXdhaXQgZnMuZXhpc3RzKHN5bWxpbmtQYXRoKSkge1xuICAgIHhjb2RlUGF0aCA9IGF3YWl0IGZzLnJlYWRsaW5rKHN5bWxpbmtQYXRoKTtcbiAgfSBlbHNlIGlmIChhd2FpdCBmcy5leGlzdHMobGVnYWN5U3ltbGlua1BhdGgpKSB7XG4gICAgeGNvZGVQYXRoID0gYXdhaXQgZnMucmVhZGxpbmsobGVnYWN5U3ltbGlua1BhdGgpO1xuICB9XG5cbiAgaWYgKHhjb2RlUGF0aCkge1xuICAgIHJldHVybiB4Y29kZVBhdGgucmVwbGFjZShuZXcgUmVnRXhwKFwiLyRcIiksIFwiXCIpLnRyaW0oKTtcbiAgfVxuXG4gIC8vIFdlIHNob3VsZCBvbmx5IGdldCBoZXJlIGlzIHdlIGZhaWxlZCB0byBjYXB0dXJlIHhjb2RlLXNlbGVjdCdzIHN0ZG91dCBhbmQgb3VyXG4gIC8vIG90aGVyIGNoZWNrcyBmYWlsZWQuIEVpdGhlciBBcHBsZSBoYXMgbW92ZWQgdGhlIHN5bWxpbmsgdG8gYSBuZXcgbG9jYXRpb24gb3IgdGhlIHVzZXJcbiAgLy8gaXMgbm90IHVzaW5nIHRoZSBkZWZhdWx0IGluc3RhbGwuIDk5Ljk5OSUgY2hhbmNlIGl0J3MgdGhlIGxhdHRlciwgc28gaXNzdWUgYSB3YXJuaW5nXG4gIC8vIHNob3VsZCB3ZSBldmVyIGhpdCB0aGUgZWRnZSBjYXNlLlxuICBsZXQgbXNnID0gYENvdWxkIG5vdCBmaW5kIHBhdGggdG8gWGNvZGUgYnkgc3ltbGlua3MgbG9jYXRlZCBpbiAke3N5bWxpbmtQYXRofSwgb3IgJHtsZWdhY3lTeW1saW5rUGF0aH1gO1xuICBsb2cud2Fybihtc2cpO1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0UGF0aEZyb21YY29kZVNlbGVjdCAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYygneGNvZGUtc2VsZWN0JywgWyctLXByaW50LXBhdGgnXSwge3RpbWVvdXR9KTtcblxuICAvLyB0cmltIGFuZCByZW1vdmUgdHJhaWxpbmcgc2xhc2hcbiAgY29uc3QgeGNvZGVGb2xkZXJQYXRoID0gc3Rkb3V0LnJlcGxhY2UoL1xcLyQvLCAnJykudHJpbSgpO1xuXG4gIGlmICghdXRpbC5oYXNDb250ZW50KHhjb2RlRm9sZGVyUGF0aCkpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdygneGNvZGUtc2VsZWN0IHJldHVybmVkIGFuIGVtcHR5IHN0cmluZycpO1xuICB9XG5cbiAgaWYgKGF3YWl0IGZzLmV4aXN0cyh4Y29kZUZvbGRlclBhdGgpKSB7XG4gICAgcmV0dXJuIHhjb2RlRm9sZGVyUGF0aDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtc2cgPSBgeGNvZGUtc2VsZWN0IGNvdWxkIG5vdCBmaW5kIHhjb2RlLiBQYXRoICcke3hjb2RlRm9sZGVyUGF0aH0nIGRvZXMgbm90IGV4aXN0LmA7XG4gICAgbG9nLmVycm9yQW5kVGhyb3cobXNnKTtcbiAgfVxufVxuXG5jb25zdCBnZXRQYXRoID0gXy5tZW1vaXplKGZ1bmN0aW9uICh0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICAvLyBmaXJzdCB3ZSB0cnkgdXNpbmcgeGNvZGUtc2VsZWN0IHRvIGZpbmQgdGhlIHBhdGhcbiAgLy8gdGhlbiB3ZSB0cnkgdXNpbmcgdGhlIHN5bWxpbmtzIHRoYXQgQXBwbGUgaGFzIGJ5IGRlZmF1bHRcbiAgcmV0dXJuIGdldFBhdGhGcm9tWGNvZGVTZWxlY3QodGltZW91dCkuY2F0Y2goZ2V0UGF0aEZyb21TeW1saW5rKTtcbn0pO1xuXG5cblxuYXN5bmMgZnVuY3Rpb24gZ2V0VmVyc2lvbldpdGhvdXRSZXRyeSAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgeGNvZGVQYXRoID0gYXdhaXQgZ2V0UGF0aCh0aW1lb3V0KTtcblxuICAvLyB3ZSB3YW50IHRvIHJlYWQgdGhlIENGQnVuZGxlU2hvcnRWZXJzaW9uU3RyaW5nIGZyb20gWGNvZGUncyBwbGlzdC5cbiAgLy8gSXQgc2hvdWxkIGJlIGluIC9bcm9vdF0vWENvZGUuYXBwL0NvbnRlbnRzL1xuICBjb25zdCBwbGlzdFBhdGggPSBwYXRoLnJlc29sdmUoeGNvZGVQYXRoLCBcIi4uXCIsIFwiSW5mby5wbGlzdFwiKTtcblxuICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhwbGlzdFBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZ2V0IFhjb2RlIHZlcnNpb24uICR7cGxpc3RQYXRofSBkb2VzIG5vdCBleGlzdCBvbiBkaXNrLmApO1xuICB9XG5cbiAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IHBsaXN0LnBhcnNlUGxpc3RGaWxlKHBsaXN0UGF0aCk7XG4gIHJldHVybiBzZW12ZXIuY29lcmNlKHZlcnNpb24uQ0ZCdW5kbGVTaG9ydFZlcnNpb25TdHJpbmcpO1xufVxuXG5jb25zdCBnZXRWZXJzaW9uTWVtb2l6ZWQgPSBfLm1lbW9pemUoXG4gIGZ1bmN0aW9uIChyZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUywgdGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0VmVyc2lvbldpdGhvdXRSZXRyeSwgdGltZW91dCk7XG4gIH1cbik7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFZlcnNpb24gKHBhcnNlID0gZmFsc2UsIHJldHJpZXMgPSBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTLCB0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgZ2V0VmVyc2lvbk1lbW9pemVkKHJldHJpZXMsIHRpbWVvdXQpO1xuICAvLyB4Y29kZSB2ZXJzaW9uIHN0cmluZ3MgYXJlIG5vdCBleGFjdGx5IHNlbXZlciBzdHJpbmc6IHBhdGNoIHZlcnNpb25zIG9mIDBcbiAgLy8gYXJlIHJlbW92ZWQgKGUuZy4sICcxMC4wLjAnID0+ICcxMC4wJylcbiAgY29uc3QgdmVyc2lvblN0cmluZyA9IHZlcnNpb24ucGF0Y2ggPiAwID8gdmVyc2lvbi52ZXJzaW9uIDogYCR7dmVyc2lvbi5tYWpvcn0uJHt2ZXJzaW9uLm1pbm9yfWA7XG4gIGlmICghcGFyc2UpIHtcbiAgICByZXR1cm4gdmVyc2lvblN0cmluZztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmVyc2lvblN0cmluZyxcbiAgICB2ZXJzaW9uRmxvYXQ6IHBhcnNlRmxvYXQodmVyc2lvblN0cmluZyksXG4gICAgbWFqb3I6IHZlcnNpb24ubWFqb3IsXG4gICAgbWlub3I6IHZlcnNpb24ubWlub3IsXG4gICAgcGF0Y2g6IHZlcnNpb24ucGF0Y2ggPiAwID8gdmVyc2lvbi5wYXRjaCA6IHVuZGVmaW5lZFxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRDb21tYW5kTGluZVRvb2xzVmVyc2lvbiAoKSB7XG4gIC8vIHRoZXJlIGFyZSBhIG51bWJlciBvZiBkaWZmZXJlbnQgd2F5cyB0aGF0IHRoZSBDTEkgdG9vbHMgdmVyc2lvbiBoYXMgYmVlblxuICAvLyByZXByZXNlbnRlZC4gVHJ5IHRoZW0gZnJvbSBtb3N0IHJlbGlhYmxlIHRvIGxlYXN0LCBmYWxsaW5nIGRvd24gdGhlIGNoYWluXG4gIGNvbnN0IGdldFZlcnNpb25GdW5jdGlvbnMgPSBbXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHBrZyA9IChhd2FpdCBleGVjKCdwa2d1dGlsJywgWyctLXBrZ3M9Y29tLmFwcGxlLnBrZy5EZXZTREtfLionXSkpLnN0ZG91dDtcbiAgICAgIHJldHVybiAoYXdhaXQgZXhlYygncGtndXRpbCcsIFtgLS1wa2ctaW5mbz0ke3BrZy50cmltKCl9YF0pKS5zdGRvdXQ7XG4gICAgfSxcbiAgICBhc3luYyAoKSA9PiAoYXdhaXQgZXhlYygncGtndXRpbCcsIFtgLS1wa2ctaW5mbz1jb20uYXBwbGUucGtnLkNMVG9vbHNfRXhlY3V0YWJsZXNgXSkpLnN0ZG91dCxcbiAgICBhc3luYyAoKSA9PiAoYXdhaXQgZXhlYygncGtndXRpbCcsIFtgLS1wa2ctaW5mbz1jb20uYXBwbGUucGtnLkRldmVsb3BlclRvb2xzQ0xJYF0pKS5zdGRvdXQsXG4gIF07XG4gIGxldCBzdGRvdXQ7XG4gIGZvciAobGV0IGdldFZlcnNpb24gb2YgZ2V0VmVyc2lvbkZ1bmN0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBzdGRvdXQgPSBhd2FpdCBnZXRWZXJzaW9uKCk7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoIChpZ24pIHtcbiAgICAgIHN0ZG91dCA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIC8vIHN0ZG91dCBzaG91bGQgaGF2ZSBhIGxpbmUgbGlrZSBgdmVyc2lvbjogOC4wLjAuMC4xLjE0NzI0MzU4ODFgXG4gIGxldCBtYXRjaCA9IC9edmVyc2lvbjogKC4rKSQvbS5leGVjKHN0ZG91dCk7IC8vIGh0dHBzOi8vcmVnZXgxMDEuY29tL3IvSFYzeDRkLzFcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiB1bmRlZmluZWQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aFdpdGhvdXRSZXRyeSAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgeGNvZGVQYXRoID0gYXdhaXQgZ2V0UGF0aCh0aW1lb3V0KTtcblxuICAvLyBmb3IgaW9zIDggYW5kIHVwLCB0aGUgZmlsZSBleHRlbnNpb24gZm9yIEF1dGlvbWF0aW9uSW5zdHJ1bWVudCBjaGFuZ2VkLlxuICAvLyByYXRoZXIgdGhhbiB3YXN0ZSB0aW1lIGdldHRpbmcgdGhlIGlPU1NES1ZlcnNpb24sIGp1c3QgZ2V0IGJvdGggcGF0aHMgYW5kIHNlZSB3aGljaCBvbmUgZXhpc3RzXG4gIGNvbnN0IGV4dGVuc2lvbnMgPSBbJ3hycGx1Z2luJywgJ2J1bmRsZSddO1xuICBjb25zdCBwYXRoUHJlZml4ID0gcGF0aC5yZXNvbHZlKHhjb2RlUGF0aCwgXCIuLi9BcHBsaWNhdGlvbnMvSW5zdHJ1bWVudHMuYXBwL0NvbnRlbnRzL1BsdWdJbnNcIik7XG4gIGNvbnN0IHBhdGhTdWZmaXggPSBcIkNvbnRlbnRzL1Jlc291cmNlcy9BdXRvbWF0aW9uLnRyYWNldGVtcGxhdGVcIjtcbiAgbGV0IGF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHMgPSBbXG4gICAgcGF0aC5yZXNvbHZlKHBhdGhQcmVmaXgsIGBBdXRvbWF0aW9uSW5zdHJ1bWVudC4ke2V4dGVuc2lvbnNbMF19YCwgcGF0aFN1ZmZpeCksXG4gICAgcGF0aC5yZXNvbHZlKHBhdGhQcmVmaXgsIGBBdXRvbWF0aW9uSW5zdHJ1bWVudC4ke2V4dGVuc2lvbnNbMV19YCwgcGF0aFN1ZmZpeClcbiAgXTtcblxuICBpZiAoYXdhaXQgZnMuZXhpc3RzKGF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHNbMF0pKSB7XG4gICAgcmV0dXJuIGF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHNbMF07XG4gIH1cblxuICBpZiAoYXdhaXQgZnMuZXhpc3RzKGF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHNbMV0pKSB7XG4gICAgcmV0dXJuIGF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHNbMV07XG4gIH1cblxuICBjb25zdCBtc2cgPSBcIkNvdWxkIG5vdCBmaW5kIEF1dG9tYXRpb24udHJhY2V0ZW1wbGF0ZSBpbiBhbnkgb2YgdGhlIGZvbGxvd2luZ1wiICtcbiAgICAgICAgICAgICAgYGxvY2F0aW9ucyAke2F1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHMudG9TdHJpbmcoKX1gO1xuICBsb2cuZXJyb3IobXNnKTtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG5cbn1cblxuY29uc3QgZ2V0QXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRoID0gXy5tZW1vaXplKFxuICBmdW5jdGlvbiAocmV0cmllcyA9IERFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMsIHRpbWVvdXQgPSBYQ1JVTl9USU1FT1VUKSB7XG4gICAgcmV0dXJuIHJldHJ5KHJldHJpZXMsIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aFdpdGhvdXRSZXRyeSwgdGltZW91dCk7XG4gIH1cbik7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldE1heElPU1NES1dpdGhvdXRSZXRyeSAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IGdldFZlcnNpb24oZmFsc2UsIERFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMsIHRpbWVvdXQpO1xuICBpZiAodmVyc2lvblswXSA9PT0gJzQnKSB7XG4gICAgcmV0dXJuICc2LjEnO1xuICB9XG5cbiAgY29uc3QgYXJncyA9IFsnLS1zZGsnLCAgJ2lwaG9uZXNpbXVsYXRvcicsICAnLS1zaG93LXNkay12ZXJzaW9uJ107XG4gIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgcnVuWGNydW5Db21tYW5kKGFyZ3MsIHRpbWVvdXQpO1xuXG4gIGNvbnN0IHNka1ZlcnNpb24gPSBzdGRvdXQudHJpbSgpO1xuICBjb25zdCBtYXRjaCA9IC9cXGQuXFxkLy5leGVjKHN0ZG91dCk7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgeGNydW4gcmV0dXJuZWQgYSBub24tbnVtZXJpYyBpT1MgU0RLIHZlcnNpb246ICcke3Nka1ZlcnNpb259J2ApO1xuICB9XG5cbiAgcmV0dXJuIHNka1ZlcnNpb247XG59XG5cbmNvbnN0IGdldE1heElPU1NESyA9IF8ubWVtb2l6ZShcbiAgZnVuY3Rpb24gKHJldHJpZXMgPSBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTLCB0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICAgIHJldHVybiByZXRyeShyZXRyaWVzLCBnZXRNYXhJT1NTREtXaXRob3V0UmV0cnksIHRpbWVvdXQpO1xuICB9XG4pO1xuXG5hc3luYyBmdW5jdGlvbiBnZXRNYXhUVk9TU0RLV2l0aG91dFJldHJ5ICh0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICBjb25zdCBhcmdzID0gWyctLXNkaycsICAnYXBwbGV0dnNpbXVsYXRvcicsICAnLS1zaG93LXNkay12ZXJzaW9uJ107XG4gIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgcnVuWGNydW5Db21tYW5kKGFyZ3MsIHRpbWVvdXQpO1xuXG4gIGNvbnN0IHNka1ZlcnNpb24gPSBzdGRvdXQudHJpbSgpO1xuXG4gIGlmIChpc05hTihwYXJzZUZsb2F0KHNka1ZlcnNpb24pKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgeGNydW4gcmV0dXJuZWQgYSBub24tbnVtZXJpYyB0dk9TIFNESyB2ZXJzaW9uOiAnJHtzZGtWZXJzaW9ufSdgKTtcbiAgfVxuXG4gIHJldHVybiBzZGtWZXJzaW9uO1xufVxuXG5jb25zdCBnZXRNYXhUVk9TU0RLID0gXy5tZW1vaXplKFxuICBmdW5jdGlvbiAocmV0cmllcyA9IERFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMsIHRpbWVvdXQgPSBYQ1JVTl9USU1FT1VUKSB7XG4gICAgcmV0dXJuIHJldHJ5KHJldHJpZXMsIGdldE1heFRWT1NTREtXaXRob3V0UmV0cnksIHRpbWVvdXQpO1xuICB9XG4pO1xuXG5hc3luYyBmdW5jdGlvbiBnZXRDb25uZWN0ZWREZXZpY2VzICh0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICBjb25zdCBjbWQgPSAnL3Vzci9zYmluL3N5c3RlbV9wcm9maWxlcic7XG4gIGNvbnN0IGFyZ3MgPSBbJy14bWwnLCAnU1BVU0JEYXRhVHlwZSddO1xuICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKGNtZCwgYXJncywge3RpbWVvdXR9KTtcbiAgbGV0IHBsaXN0Q29udGVudCA9IHBhcnNlUGxpc3REYXRhKHN0ZG91dCk7XG5cbiAgbGV0IGRldmljZXNGb3VuZCA9IFtdO1xuICBsZXQgZW50cmllc1RvU2VhcmNoID0gW3BsaXN0Q29udGVudFswXV07XG4gIHdoaWxlIChlbnRyaWVzVG9TZWFyY2gubGVuZ3RoID4gMCkge1xuICAgIGxldCBjdXJyZW50RW50cnkgPSBlbnRyaWVzVG9TZWFyY2gucG9wKCk7XG4gICAgaWYgKGN1cnJlbnRFbnRyeSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBlbnRyaWVzVG9TZWFyY2ggPSBlbnRyaWVzVG9TZWFyY2guY29uY2F0KGN1cnJlbnRFbnRyeSk7XG4gICAgfSBlbHNlIGlmICgoY3VycmVudEVudHJ5Ll9uYW1lICYmXG4gICAgICAgICAgICAgICAgY3VycmVudEVudHJ5Ll9uYW1lLnN1YnN0cmluZygwLCA0KSA9PT0gXCJpUGFkXCIpIHx8XG4gICAgICAgICAgICAgICAoY3VycmVudEVudHJ5Ll9uYW1lICYmXG4gICAgICAgICAgICAgICAgY3VycmVudEVudHJ5Ll9uYW1lLnN1YnN0cmluZygwLCA2KSA9PT0gXCJpUGhvbmVcIikgfHxcbiAgICAgICAgICAgICAgIChjdXJyZW50RW50cnkuX25hbWUgJiYgXy5pbmNsdWRlcyhjdXJyZW50RW50cnkuX25hbWUsIFwiQXBwbGUgVFZcIikpKSB7XG4gICAgICBsZXQgZGV2aWNlSW5mbyA9IHtcbiAgICAgICAgbmFtZTogY3VycmVudEVudHJ5Ll9uYW1lLFxuICAgICAgICB1ZGlkOiBjdXJyZW50RW50cnkuc2VyaWFsX251bSxcbiAgICAgICAgcHJvZHVjdElkOiBjdXJyZW50RW50cnkucHJvZHVjdF9pZCxcbiAgICAgICAgZGV2aWNlVmVyc2lvbjogY3VycmVudEVudHJ5LmJjZF9kZXZpY2VcbiAgICAgIH07XG4gICAgICBkZXZpY2VzRm91bmQucHVzaChkZXZpY2VJbmZvKTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRFbnRyeS5faXRlbXMpIHtcbiAgICAgIGVudHJpZXNUb1NlYXJjaCA9IGVudHJpZXNUb1NlYXJjaC5jb25jYXQoY3VycmVudEVudHJ5Ll9pdGVtcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXZpY2VzRm91bmQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEluc3RydW1lbnRzUGF0aFdpdGhvdXRSZXRyeSAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgYXJncyA9IFsnLWZpbmQnLCAnaW5zdHJ1bWVudHMnXTtcbiAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgcnVuWGNydW5Db21tYW5kKGFyZ3MsIHRpbWVvdXQpO1xuXG4gIGlmICghc3Rkb3V0KSB7XG4gICAgc3Rkb3V0ID0gXCJcIjtcbiAgfVxuXG4gIGxldCBpbnN0cnVtZW50c1BhdGggPSBzdGRvdXQudHJpbSgpO1xuXG4gIGlmICghaW5zdHJ1bWVudHNQYXRoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBwYXRoIHRvIGluc3RydW1lbnRzIGJpbmFyeSB1c2luZyAneGNydW4gJHthcmdzLmpvaW4oJyAnKX0nYCk7XG4gIH1cblxuICByZXR1cm4gaW5zdHJ1bWVudHNQYXRoO1xufVxuXG5jb25zdCBnZXRJbnN0cnVtZW50c1BhdGggPSBfLm1lbW9pemUoXG4gIGZ1bmN0aW9uIChyZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUywgdGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0SW5zdHJ1bWVudHNQYXRoV2l0aG91dFJldHJ5LCB0aW1lb3V0KTtcbiAgfVxuKTtcblxuZnVuY3Rpb24gY2xlYXJJbnRlcm5hbENhY2hlICgpIHtcblxuICAvLyBtZW1vaXplZCBmdW5jdGlvbnNcbiAgY29uc3QgbWVtb2l6ZWQgPSBbZ2V0UGF0aCwgZ2V0VmVyc2lvbk1lbW9pemVkLCBnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGdldE1heElPU1NESywgZ2V0TWF4VFZPU1NESywgZ2V0SW5zdHJ1bWVudHNQYXRoXTtcblxuICBtZW1vaXplZC5mb3JFYWNoKChmKSA9PiB7XG4gICAgaWYgKGYuY2FjaGUpIHtcbiAgICAgIGYuY2FjaGUgPSBuZXcgXy5tZW1vaXplLkNhY2hlKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBnZXRQYXRoLCBnZXRWZXJzaW9uLCBnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGgsIGdldE1heElPU1NESyxcbiAgICAgICAgIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aFdpdGhvdXRSZXRyeSwgZ2V0TWF4SU9TU0RLV2l0aG91dFJldHJ5LFxuICAgICAgICAgZ2V0Q29ubmVjdGVkRGV2aWNlcywgY2xlYXJJbnRlcm5hbENhY2hlLCBnZXRJbnN0cnVtZW50c1BhdGgsXG4gICAgICAgICBnZXRDb21tYW5kTGluZVRvb2xzVmVyc2lvbiwgZ2V0TWF4VFZPU1NESywgZ2V0TWF4VFZPU1NES1dpdGhvdXRSZXRyeSB9O1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLiJ9
