'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Symbol$iterator = require('babel-runtime/core-js/symbol/iterator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _interopRequireWildcard = require('babel-runtime/helpers/interop-require-wildcard')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _nodeSimctl = require('node-simctl');

var simctl = _interopRequireWildcard(_nodeSimctl);

var _appiumXcode = require('appium-xcode');

var _appiumXcode2 = _interopRequireDefault(_appiumXcode);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _appiumSupport = require('appium-support');

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _asyncLock = require('async-lock');

var _asyncLock2 = _interopRequireDefault(_asyncLock);

var _utilsJs = require('./utils.js');

var _asyncbox = require('asyncbox');

var _settings = require('./settings');

var settings = _interopRequireWildcard(_settings);

var _teen_process = require('teen_process');

var _tailUntilJs = require('./tail-until.js');

var _extensionsIndex = require('./extensions/index');

var _extensionsIndex2 = _interopRequireDefault(_extensionsIndex);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _calendar = require('./calendar');

var _calendar2 = _interopRequireDefault(_calendar);

var EventEmitter = _events2['default'].EventEmitter;

var STARTUP_TIMEOUT = 60 * 1000;
var EXTRA_STARTUP_TIME = 2000;
var UI_CLIENT_ACCESS_GUARD = new _asyncLock2['default']();

/*
 * This event is emitted as soon as iOS Simulator
 * has finished booting and it is ready to accept xcrun commands.
 * The event handler is called after 'run' method is completed
 * for Xcode 7 and older and is only useful in Xcode 8+,
 * since one can start doing stuff (for example install/uninstall an app) in parallel
 * with Simulator UI startup, which shortens session startup time.
 */
var BOOT_COMPLETED_EVENT = 'bootCompleted';

var SimulatorXcode6 = (function (_EventEmitter) {
  _inherits(SimulatorXcode6, _EventEmitter);

  /**
   * Constructs the object with the `udid` and version of Xcode. Use the exported `getSimulator(udid)` method instead.
   *
   * @param {string} udid - The Simulator ID.
   * @param {object} xcodeVersion - The target Xcode version in format {major, minor, build}.
   */

  function SimulatorXcode6(udid, xcodeVersion) {
    _classCallCheck(this, SimulatorXcode6);

    _get(Object.getPrototypeOf(SimulatorXcode6.prototype), 'constructor', this).call(this);
    this.udid = String(udid);
    this.xcodeVersion = xcodeVersion;

    // platformVersion cannot be found initially, since getting it has side effects for
    // our logic for figuring out if a sim has been run
    // it will be set when it is needed
    this._platformVersion = null;

    this.keychainPath = _path2['default'].resolve(this.getDir(), 'Library', 'Keychains');
    this.simulatorApp = 'iOS Simulator.app';

    this.appDataBundlePaths = {};

    // list of files to check for when seeing if a simulator is "fresh"
    // (meaning it has never been booted).
    // If these files are present, we assume it's been successfully booted
    this.isFreshFiles = ['Library/ConfigurationProfiles', 'Library/Cookies', 'Library/Preferences/.GlobalPreferences.plist', 'Library/Preferences/com.apple.springboard.plist', 'var/run/syslog.pid'];

    // extra time to wait for simulator to be deemed booted
    this.extraStartupTime = EXTRA_STARTUP_TIME;

    this.calendar = new _calendar2['default'](xcodeVersion, this.getDir());
  }

  /**
   * Check the state of Simulator UI client.
   *
   * @return {boolean} True of if UI client is running or false otherwise.
   */

  _createClass(SimulatorXcode6, [{
    key: 'isUIClientRunning',
    value: function isUIClientRunning() {
      return _regeneratorRuntime.async(function isUIClientRunning$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.prev = 0;
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('pgrep', ['-x', this.simulatorApp.split('.')[0]]));

          case 3:
            return context$2$0.abrupt('return', true);

          case 6:
            context$2$0.prev = 6;
            context$2$0.t0 = context$2$0['catch'](0);
            return context$2$0.abrupt('return', false);

          case 9:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[0, 6]]);
    }

    /**
     * How long to wait before throwing an error about Simulator startup timeout happened.
     *
     * @return {number} The number of milliseconds.
     */
  }, {
    key: 'getPlatformVersion',

    /**
     * Get the platform version of the current Simulator.
     *
     * @return {string} SDK version, for example '8.3'.
     */
    value: function getPlatformVersion() {
      var _ref, sdk;

      return _regeneratorRuntime.async(function getPlatformVersion$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (this._platformVersion) {
              context$2$0.next = 6;
              break;
            }

            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.stat());

          case 3:
            _ref = context$2$0.sent;
            sdk = _ref.sdk;

            this._platformVersion = sdk;

          case 6:
            return context$2$0.abrupt('return', this._platformVersion);

          case 7:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Retrieve the full path to the directory where Simulator stuff is located.
     *
     * @return {string} The path string.
     */
  }, {
    key: 'getRootDir',
    value: function getRootDir() {
      var home = process.env.HOME;
      return _path2['default'].resolve(home, 'Library', 'Developer', 'CoreSimulator', 'Devices');
    }

    /**
     * Retrieve the full path to the directory where Simulator applications data is located.
     *
     * @return {string} The path string.
     */
  }, {
    key: 'getDir',
    value: function getDir() {
      return _path2['default'].resolve(this.getRootDir(), this.udid, 'data');
    }

    /**
     * Retrieve the full path to the directory where Simulator logs are stored.
     *
     * @return {string} The path string.
     */
  }, {
    key: 'getLogDir',
    value: function getLogDir() {
      var home = process.env.HOME;
      return _path2['default'].resolve(home, 'Library', 'Logs', 'CoreSimulator', this.udid);
    }

    /**
     * Install valid .app package on Simulator.
     *
     * @param {string} app - The path to the .app package.
     */
  }, {
    key: 'installApp',
    value: function installApp(app) {
      return _regeneratorRuntime.async(function installApp$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(simctl.installApp(this.udid, app));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Verify whether the particular application is installed on Simulator.
     *
     * @param {string} bundleId - The bundle id of the application to be checked.
     * @param {string} appFule - Application name minus ".app" (for iOS 7.1)
     * @return {boolean} True if the given application is installed
     */
  }, {
    key: 'isAppInstalled',
    value: function isAppInstalled(bundleId) {
      var appFile = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
      var appDirs;
      return _regeneratorRuntime.async(function isAppInstalled$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.getAppDirs(appFile, bundleId));

          case 2:
            appDirs = context$2$0.sent;
            return context$2$0.abrupt('return', appDirs.length !== 0);

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Retrieve the directory for a particular application's data.
     *
     * @param {string} id - Either a bundleId (e.g., com.apple.mobilesafari) or, for iOS 7.1, the app name without `.app` (e.g., MobileSafari)
     * @param {string} subdir - The sub-directory we expect to be within the application directory. Defaults to "Data".
     * @return {string} The root application folder.
     */
  }, {
    key: 'getAppDir',
    value: function getAppDir(id) {
      var subDir = arguments.length <= 1 || arguments[1] === undefined ? 'Data' : arguments[1];
      return _regeneratorRuntime.async(function getAppDir$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            this.appDataBundlePaths[subDir] = this.appDataBundlePaths[subDir] || {};
            context$2$0.t0 = _lodash2['default'].isEmpty(this.appDataBundlePaths[subDir]);

            if (!context$2$0.t0) {
              context$2$0.next = 6;
              break;
            }

            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.isFresh());

          case 5:
            context$2$0.t0 = !context$2$0.sent;

          case 6:
            if (!context$2$0.t0) {
              context$2$0.next = 10;
              break;
            }

            context$2$0.next = 9;
            return _regeneratorRuntime.awrap(this.buildBundlePathMap(subDir));

          case 9:
            this.appDataBundlePaths[subDir] = context$2$0.sent;

          case 10:
            return context$2$0.abrupt('return', this.appDataBundlePaths[subDir][id]);

          case 11:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * The xcode 6 simulators are really annoying, and bury the main app
     * directories inside directories just named with Hashes.
     * This function finds the proper directory by traversing all of them
     * and reading a metadata plist (Mobile Container Manager) to get the
     * bundle id.
     *
     * @param {string} subdir - The sub-directory we expect to be within the application directory. Defaults to "Data".
     * @return {object} The list of path-bundle pairs to an object where bundleIds are mapped to paths.
     */
  }, {
    key: 'buildBundlePathMap',
    value: function buildBundlePathMap() {
      var subDir = arguments.length <= 0 || arguments[0] === undefined ? 'Data' : arguments[0];
      var applicationList, pathBundlePair, bundlePathDirs, bundlePathPairs;
      return _regeneratorRuntime.async(function buildBundlePathMap$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Building bundle path map');
            applicationList = undefined;
            pathBundlePair = undefined;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.getPlatformVersion());

          case 5:
            context$2$0.t0 = context$2$0.sent;

            if (!(context$2$0.t0 === '7.1')) {
              context$2$0.next = 11;
              break;
            }

            // apps available
            //   Web.app,
            //   WebViewService.app,
            //   MobileSafari.app,
            //   WebContentAnalysisUI.app,
            //   DDActionsService.app,
            //   StoreKitUIService.app
            applicationList = _path2['default'].resolve(this.getDir(), 'Applications');
            pathBundlePair = function callee$2$0(dir) {
              var appFiles, bundleId;
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    dir = _path2['default'].resolve(applicationList, dir);
                    context$3$0.next = 3;
                    return _regeneratorRuntime.awrap(_appiumSupport.fs.glob(dir + '/*.app'));

                  case 3:
                    appFiles = context$3$0.sent;
                    bundleId = appFiles[0].match(/.*\/(.*)\.app/)[1];
                    return context$3$0.abrupt('return', { path: dir, bundleId: bundleId });

                  case 6:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this);
            };
            context$2$0.next = 12;
            break;

          case 11:
            (function () {
              applicationList = _path2['default'].resolve(_this.getDir(), 'Containers', subDir, 'Application');
              // given a directory, find the plist file and pull the bundle id from it
              var readBundleId = function readBundleId(dir) {
                var plist, metadata;
                return _regeneratorRuntime.async(function readBundleId$(context$4$0) {
                  while (1) switch (context$4$0.prev = context$4$0.next) {
                    case 0:
                      plist = _path2['default'].resolve(dir, '.com.apple.mobile_container_manager.metadata.plist');
                      context$4$0.next = 3;
                      return _regeneratorRuntime.awrap(settings.read(plist));

                    case 3:
                      metadata = context$4$0.sent;
                      return context$4$0.abrupt('return', metadata.MCMMetadataIdentifier);

                    case 5:
                    case 'end':
                      return context$4$0.stop();
                  }
                }, null, _this);
              };
              // given a directory, return the path and bundle id associated with it
              pathBundlePair = function callee$3$0(dir) {
                var bundleId;
                return _regeneratorRuntime.async(function callee$3$0$(context$4$0) {
                  while (1) switch (context$4$0.prev = context$4$0.next) {
                    case 0:
                      dir = _path2['default'].resolve(applicationList, dir);
                      context$4$0.next = 3;
                      return _regeneratorRuntime.awrap(readBundleId(dir));

                    case 3:
                      bundleId = context$4$0.sent;
                      return context$4$0.abrupt('return', { path: dir, bundleId: bundleId });

                    case 5:
                    case 'end':
                      return context$4$0.stop();
                  }
                }, null, _this);
              };
            })();

          case 12:
            context$2$0.next = 14;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.readdir(applicationList));

          case 14:
            bundlePathDirs = context$2$0.sent;
            context$2$0.next = 17;
            return _regeneratorRuntime.awrap((0, _asyncbox.asyncmap)(bundlePathDirs, function callee$2$0(dir) {
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    context$3$0.next = 2;
                    return _regeneratorRuntime.awrap(pathBundlePair(dir));

                  case 2:
                    return context$3$0.abrupt('return', context$3$0.sent);

                  case 3:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this);
            }, false));

          case 17:
            bundlePathPairs = context$2$0.sent;
            return context$2$0.abrupt('return', bundlePathPairs.reduce(function (bundleMap, bundlePath) {
              bundleMap[bundlePath.bundleId] = bundlePath.path;
              return bundleMap;
            }, {}));

          case 19:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Get the state and specifics of this sim.
     *
     * @return {object} Simulator stats mapping, for example:
     * { name: 'iPhone 4s',
     *   udid: 'C09B34E5-7DCB-442E-B79C-AB6BC0357417',
     *   state: 'Shutdown',
     *   sdk: '8.3'
     * }
     */
  }, {
    key: 'stat',
    value: function stat() {
      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, sdk, deviceArr, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, device;

      return _regeneratorRuntime.async(function stat$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            context$2$0.prev = 3;
            context$2$0.t0 = _lodash2['default'];
            context$2$0.next = 7;
            return _regeneratorRuntime.awrap(simctl.getDevices());

          case 7:
            context$2$0.t1 = context$2$0.sent;
            context$2$0.t2 = _Symbol$iterator;
            _iterator = context$2$0.t0.toPairs.call(context$2$0.t0, context$2$0.t1)[context$2$0.t2]();

          case 10:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              context$2$0.next = 44;
              break;
            }

            _step$value = _slicedToArray(_step.value, 2);
            sdk = _step$value[0];
            deviceArr = _step$value[1];
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _iteratorError2 = undefined;
            context$2$0.prev = 17;
            _iterator2 = _getIterator(deviceArr);

          case 19:
            if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
              context$2$0.next = 27;
              break;
            }

            device = _step2.value;

            if (!(device.udid === this.udid)) {
              context$2$0.next = 24;
              break;
            }

            device.sdk = sdk;
            return context$2$0.abrupt('return', device);

          case 24:
            _iteratorNormalCompletion2 = true;
            context$2$0.next = 19;
            break;

          case 27:
            context$2$0.next = 33;
            break;

          case 29:
            context$2$0.prev = 29;
            context$2$0.t3 = context$2$0['catch'](17);
            _didIteratorError2 = true;
            _iteratorError2 = context$2$0.t3;

          case 33:
            context$2$0.prev = 33;
            context$2$0.prev = 34;

            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
              _iterator2['return']();
            }

          case 36:
            context$2$0.prev = 36;

            if (!_didIteratorError2) {
              context$2$0.next = 39;
              break;
            }

            throw _iteratorError2;

          case 39:
            return context$2$0.finish(36);

          case 40:
            return context$2$0.finish(33);

          case 41:
            _iteratorNormalCompletion = true;
            context$2$0.next = 10;
            break;

          case 44:
            context$2$0.next = 50;
            break;

          case 46:
            context$2$0.prev = 46;
            context$2$0.t4 = context$2$0['catch'](3);
            _didIteratorError = true;
            _iteratorError = context$2$0.t4;

          case 50:
            context$2$0.prev = 50;
            context$2$0.prev = 51;

            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }

          case 53:
            context$2$0.prev = 53;

            if (!_didIteratorError) {
              context$2$0.next = 56;
              break;
            }

            throw _iteratorError;

          case 56:
            return context$2$0.finish(53);

          case 57:
            return context$2$0.finish(50);

          case 58:
            return context$2$0.abrupt('return', {});

          case 59:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[3, 46, 50, 58], [17, 29, 33, 41], [34,, 36, 40], [51,, 53, 57]]);
    }

    /**
     * This is a best-bet heuristic for whether or not a sim has been booted
     * before. We usually want to start a simulator to "warm" it up, have
     * Xcode populate it with plists for us to manipulate before a real
     * test run.
     *
     * @return {boolean} True if the current Simulator has never been started before
     */
  }, {
    key: 'isFresh',
    value: function isFresh() {
      var files, pv, dir, existences, fresh;
      return _regeneratorRuntime.async(function isFresh$(context$2$0) {
        var _this2 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            // if the following files don't exist, it hasn't been booted.
            // THIS IS NOT AN EXHAUSTIVE LIST
            _logger2['default'].debug('Checking whether simulator has been run before');
            files = this.isFreshFiles;
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(this.getPlatformVersion());

          case 4:
            pv = context$2$0.sent;

            if (pv !== '7.1') {
              files.push('Library/Preferences/com.apple.Preferences.plist');
            } else {
              files.push('Applications');
            }

            dir = this.getDir();

            files = files.map(function (s) {
              return _path2['default'].resolve(dir, s);
            });

            context$2$0.next = 10;
            return _regeneratorRuntime.awrap((0, _asyncbox.asyncmap)(files, function callee$2$0(f) {
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    context$3$0.next = 2;
                    return _regeneratorRuntime.awrap(_appiumSupport.fs.hasAccess(f));

                  case 2:
                    return context$3$0.abrupt('return', context$3$0.sent);

                  case 3:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this2);
            }));

          case 10:
            existences = context$2$0.sent;
            fresh = _lodash2['default'].compact(existences).length !== files.length;

            _logger2['default'].debug('Simulator ' + (fresh ? 'has not' : 'has') + ' been run before');
            return context$2$0.abrupt('return', fresh);

          case 14:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Retrieves the state of the current Simulator. One should distinguish the
     * states of Simulator UI and the Simulator itself.
     *
     * @return {boolean} True if the current Simulator is running.
     */
  }, {
    key: 'isRunning',
    value: function isRunning() {
      var stat;
      return _regeneratorRuntime.async(function isRunning$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.stat());

          case 2:
            stat = context$2$0.sent;
            return context$2$0.abrupt('return', stat.state === 'Booted');

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Verify whether the Simulator booting is completed and/or wait for it
     * until the timeout expires.
     *
     * @param {number} startupTimeout - the number of milliseconds to wait until booting is completed.
     * @emits BOOT_COMPLETED_EVENT if the current Simulator is ready to accept simctl commands, like 'install'.
     */
  }, {
    key: 'waitForBoot',
    value: function waitForBoot(startupTimeout) {
      var bootedIndicator;
      return _regeneratorRuntime.async(function waitForBoot$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.getBootedIndicatorString());

          case 2:
            bootedIndicator = context$2$0.sent;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.tailLogsUntil(bootedIndicator, startupTimeout));

          case 5:

            // so sorry, but we should wait another two seconds, just to make sure we've really started
            // we can't look for another magic log line, because they seem to be app-dependent (not system dependent)
            _logger2['default'].debug('Waiting an extra ' + this.extraStartupTime + 'ms for the simulator to really finish booting');
            context$2$0.next = 8;
            return _regeneratorRuntime.awrap(_bluebird2['default'].delay(this.extraStartupTime));

          case 8:
            _logger2['default'].debug('Done waiting extra time for simulator');

            this.emit(BOOT_COMPLETED_EVENT);

          case 10:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Returns a magic string, which, if present in logs, reflects the fact that simulator booting has been completed.
     *
     * @return {string} The magic log string.
     */
  }, {
    key: 'getBootedIndicatorString',
    value: function getBootedIndicatorString() {
      var indicator, platformVersion;
      return _regeneratorRuntime.async(function getBootedIndicatorString$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            indicator = undefined;
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.getPlatformVersion());

          case 3:
            platformVersion = context$2$0.sent;
            context$2$0.t0 = platformVersion;
            context$2$0.next = context$2$0.t0 === '7.1' ? 7 : context$2$0.t0 === '8.1' ? 7 : context$2$0.t0 === '8.2' ? 7 : context$2$0.t0 === '8.3' ? 7 : context$2$0.t0 === '8.4' ? 7 : context$2$0.t0 === '9.0' ? 9 : context$2$0.t0 === '9.1' ? 9 : context$2$0.t0 === '9.2' ? 9 : context$2$0.t0 === '9.3' ? 9 : context$2$0.t0 === '10.0' ? 11 : 13;
            break;

          case 7:
            indicator = 'profiled: Service starting...';
            return context$2$0.abrupt('break', 15);

          case 9:
            indicator = 'System app "com.apple.springboard" finished startup';
            return context$2$0.abrupt('break', 15);

          case 11:
            indicator = 'Switching to keyboard';
            return context$2$0.abrupt('break', 15);

          case 13:
            _logger2['default'].warn('No boot indicator case for platform version \'' + platformVersion + '\'');
            indicator = 'no boot indicator string available';

          case 15:
            return context$2$0.abrupt('return', indicator);

          case 16:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Start the Simulator UI client with the given arguments
     *
     * @param {object} opts - One or more of available Simulator UI client options:
     *   - {string} scaleFactor: can be one of ['1.0', '0.75', '0.5', '0.33', '0.25'].
     *   Defines the window scale value for the UI client window for the current Simulator.
     *   Equals to null by default, which keeps the current scale unchanged.
     *   - {boolean} connectHardwareKeyboard: whether to connect the hardware keyboard to the
     *   Simulator UI client. Equals to false by default.
     *   - {number} startupTimeout: number of milliseconds to wait until Simulator booting
     *   process is completed. The default timeout will be used if not set explicitly.
     */
  }, {
    key: 'startUIClient',
    value: function startUIClient() {
      var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
      var simulatorApp, args, stat, formattedDeviceName, argumentName;
      return _regeneratorRuntime.async(function startUIClient$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            opts = _Object$assign({
              scaleFactor: null,
              connectHardwareKeyboard: false,
              startupTimeout: this.startupTimeout
            }, opts);

            context$2$0.t0 = _path2['default'];
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap((0, _appiumXcode.getPath)());

          case 4:
            context$2$0.t1 = context$2$0.sent;
            context$2$0.t2 = this.simulatorApp;
            simulatorApp = context$2$0.t0.resolve.call(context$2$0.t0, context$2$0.t1, 'Applications', context$2$0.t2);
            args = ['-Fn', simulatorApp, '--args', '-CurrentDeviceUDID', this.udid];

            if (!opts.scaleFactor) {
              context$2$0.next = 15;
              break;
            }

            context$2$0.next = 11;
            return _regeneratorRuntime.awrap(this.stat());

          case 11:
            stat = context$2$0.sent;
            formattedDeviceName = stat.name.replace(/\s+/g, '-');
            argumentName = '-SimulatorWindowLastScale-com.apple.CoreSimulator.SimDeviceType.' + formattedDeviceName;

            args.push(argumentName, opts.scaleFactor);

          case 15:

            if (_lodash2['default'].isBoolean(opts.connectHardwareKeyboard)) {
              args.push('-ConnectHardwareKeyboard', opts.connectHardwareKeyboard ? '1' : '0');
            }

            _logger2['default'].info('Starting Simulator UI with command: open ' + args.join(' '));
            context$2$0.next = 19;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('open', args, { timeout: opts.startupTimeout }));

          case 19:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Executes given Simulator with options. The Simulator will not be restarted if
     * it is already running.
     *
     * @param {object} opts - One or more of available Simulator options.
     *   See {#startUIClient(opts)} documentation for more details on other supported keys.
     */
  }, {
    key: 'run',
    value: function run() {
      var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var _ref2, state, isServerRunning, isUIClientRunning, startTime;

      return _regeneratorRuntime.async(function run$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            opts = _Object$assign({
              startupTimeout: this.startupTimeout
            }, opts);
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.stat());

          case 3:
            _ref2 = context$2$0.sent;
            state = _ref2.state;
            isServerRunning = state === 'Booted';
            context$2$0.next = 8;
            return _regeneratorRuntime.awrap(this.isUIClientRunning());

          case 8:
            isUIClientRunning = context$2$0.sent;

            if (!(isServerRunning && isUIClientRunning)) {
              context$2$0.next = 12;
              break;
            }

            _logger2['default'].info('Both Simulator with UDID ' + this.udid + ' and the UI client are currently running');
            return context$2$0.abrupt('return');

          case 12:
            startTime = process.hrtime();
            context$2$0.prev = 13;
            context$2$0.next = 16;
            return _regeneratorRuntime.awrap(this.shutdown());

          case 16:
            context$2$0.next = 21;
            break;

          case 18:
            context$2$0.prev = 18;
            context$2$0.t0 = context$2$0['catch'](13);

            _logger2['default'].warn('Error on Simulator shutdown: ' + context$2$0.t0.message);

          case 21:
            context$2$0.next = 23;
            return _regeneratorRuntime.awrap(this.startUIClient(opts));

          case 23:
            context$2$0.next = 25;
            return _regeneratorRuntime.awrap(this.waitForBoot(opts.startupTimeout));

          case 25:
            _logger2['default'].info('Simulator with UDID ' + this.udid + ' booted in ' + process.hrtime(startTime)[0] + ' seconds');

          case 26:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[13, 18]]);
    }

    // TODO keep keychains
    /**
     * Reset the current Simulator to the clean state.
     */
  }, {
    key: 'clean',
    value: function clean() {
      return _regeneratorRuntime.async(function clean$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.endSimulatorDaemon());

          case 2:
            _logger2['default'].info('Cleaning simulator ' + this.udid);
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(simctl.eraseDevice(this.udid, 10000));

          case 5:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Scrub (delete the preferences and changed files) the particular application on Simulator.
     *
     * @param {string} appFile - Application name minus ".app".
     * @param {string} appBundleId - Bundle identifier of the application.
     */
  }, {
    key: 'scrubCustomApp',
    value: function scrubCustomApp(appFile, appBundleId) {
      return _regeneratorRuntime.async(function scrubCustomApp$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.cleanCustomApp(appFile, appBundleId, true));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Clean/scrub the particular application on Simulator.
     *
     * @param {string} appFile - Application name minus ".app".
     * @param {string} appBundleId - Bundle identifier of the application.
     * @param {boolean} scrub - If `scrub` is false, we want to clean by deleting the app and all
     *   files associated with it. If `scrub` is true, we just want to delete the preferences and
     *   changed files.
     */
  }, {
    key: 'cleanCustomApp',
    value: function cleanCustomApp(appFile, appBundleId) {
      var scrub = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var appDirs, deletePromises, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, dir, relRmPath, rmPath;

      return _regeneratorRuntime.async(function cleanCustomApp$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Cleaning app data files for \'' + appFile + '\', \'' + appBundleId + '\'');
            if (!scrub) {
              _logger2['default'].debug('Deleting app altogether');
            }

            // get the directories to be deleted
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(this.getAppDirs(appFile, appBundleId, scrub));

          case 4:
            appDirs = context$2$0.sent;

            if (!(appDirs.length === 0)) {
              context$2$0.next = 8;
              break;
            }

            _logger2['default'].debug("Could not find app directories to delete. It is probably not installed");
            return context$2$0.abrupt('return');

          case 8:
            deletePromises = [];
            _iteratorNormalCompletion3 = true;
            _didIteratorError3 = false;
            _iteratorError3 = undefined;
            context$2$0.prev = 12;

            for (_iterator3 = _getIterator(appDirs); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              dir = _step3.value;

              _logger2['default'].debug('Deleting directory: \'' + dir + '\'');
              deletePromises.push(_appiumSupport.fs.rimraf(dir));
            }

            context$2$0.next = 20;
            break;

          case 16:
            context$2$0.prev = 16;
            context$2$0.t0 = context$2$0['catch'](12);
            _didIteratorError3 = true;
            _iteratorError3 = context$2$0.t0;

          case 20:
            context$2$0.prev = 20;
            context$2$0.prev = 21;

            if (!_iteratorNormalCompletion3 && _iterator3['return']) {
              _iterator3['return']();
            }

          case 23:
            context$2$0.prev = 23;

            if (!_didIteratorError3) {
              context$2$0.next = 26;
              break;
            }

            throw _iteratorError3;

          case 26:
            return context$2$0.finish(23);

          case 27:
            return context$2$0.finish(20);

          case 28:
            context$2$0.next = 30;
            return _regeneratorRuntime.awrap(this.getPlatformVersion());

          case 30:
            context$2$0.t1 = context$2$0.sent;

            if (!(context$2$0.t1 >= 8)) {
              context$2$0.next = 36;
              break;
            }

            relRmPath = 'Library/Preferences/' + appBundleId + '.plist';
            rmPath = _path2['default'].resolve(this.getRootDir(), relRmPath);

            _logger2['default'].debug('Deleting file: \'' + rmPath + '\'');
            deletePromises.push(_appiumSupport.fs.rimraf(rmPath));

          case 36:
            context$2$0.next = 38;
            return _regeneratorRuntime.awrap(_bluebird2['default'].all(deletePromises));

          case 38:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[12, 16, 20, 28], [21,, 23, 27]]);
    }

    /**
     * Retrieve paths to dirs where application data is stored. iOS 8+ stores app data in two places,
     * and iOS 7.1 has only one directory
     *
     * @param {string} appFile - Application name minus ".app".
     * @param {string} appBundleId - Bundle identifier of the application.
     * @param {boolean} scrub - The `Bundle` directory has the actual app in it. If we are just scrubbing,
     *   we want this to stay. If we are cleaning we delete.
     * @return {array<string>} Array of application data paths.
     */
  }, {
    key: 'getAppDirs',
    value: function getAppDirs(appFile, appBundleId) {
      var scrub = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var dirs, data, bundle, _arr, _i, src;

      return _regeneratorRuntime.async(function getAppDirs$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            dirs = [];
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.getPlatformVersion());

          case 3:
            context$2$0.t0 = context$2$0.sent;

            if (!(context$2$0.t0 >= 8)) {
              context$2$0.next = 22;
              break;
            }

            context$2$0.next = 7;
            return _regeneratorRuntime.awrap(this.getAppDir(appBundleId));

          case 7:
            data = context$2$0.sent;

            if (data) {
              context$2$0.next = 10;
              break;
            }

            return context$2$0.abrupt('return', dirs);

          case 10:
            if (scrub) {
              context$2$0.next = 16;
              break;
            }

            context$2$0.next = 13;
            return _regeneratorRuntime.awrap(this.getAppDir(appBundleId, 'Bundle'));

          case 13:
            context$2$0.t1 = context$2$0.sent;
            context$2$0.next = 17;
            break;

          case 16:
            context$2$0.t1 = undefined;

          case 17:
            bundle = context$2$0.t1;
            _arr = [data, bundle];

            for (_i = 0; _i < _arr.length; _i++) {
              src = _arr[_i];

              if (src) {
                dirs.push(src);
              }
            }
            context$2$0.next = 26;
            break;

          case 22:
            context$2$0.next = 24;
            return _regeneratorRuntime.awrap(this.getAppDir(appFile));

          case 24:
            data = context$2$0.sent;

            if (data) {
              dirs.push(data);
            }

          case 26:
            return context$2$0.abrupt('return', dirs);

          case 27:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Execute the Simulator in order to have the initial file structure created and shutdown it afterwards.
     *
     * @param {boolean} safari - Whether to execute mobile Safari after startup.
     * @param {number} startupTimeout - How long to wait until Simulator booting is completed (in milliseconds).
     */
  }, {
    key: 'launchAndQuit',
    value: function launchAndQuit() {
      var safari = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
      var startupTimeout = arguments.length <= 1 || arguments[1] === undefined ? this.startupTimeout : arguments[1];
      return _regeneratorRuntime.async(function launchAndQuit$(context$2$0) {
        var _this3 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Attempting to launch and quit the simulator, to create directory structure');
            _logger2['default'].debug('Will launch with Safari? ' + safari);

            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(this.run(startupTimeout));

          case 4:
            if (!safari) {
              context$2$0.next = 7;
              break;
            }

            context$2$0.next = 7;
            return _regeneratorRuntime.awrap(this.openUrl('http://www.appium.io'));

          case 7:
            context$2$0.next = 9;
            return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(20, 250, function callee$2$0() {
              var msg;
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    context$3$0.next = 2;
                    return _regeneratorRuntime.awrap(this.isFresh());

                  case 2:
                    if (!context$3$0.sent) {
                      context$3$0.next = 6;
                      break;
                    }

                    msg = 'Simulator files not fully created. Waiting a bit';

                    _logger2['default'].debug(msg);
                    throw new Error(msg);

                  case 6:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this3);
            }));

          case 9:
            context$2$0.next = 11;
            return _regeneratorRuntime.awrap(this.shutdown());

          case 11:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Looks for launchd daemons corresponding to the sim udid and tries to stop them cleanly
     * This prevents xcrun simctl erase from hanging.
     */
  }, {
    key: 'endSimulatorDaemon',
    value: function endSimulatorDaemon() {
      var launchctlCmd, stopCmd, removeCmd;
      return _regeneratorRuntime.async(function endSimulatorDaemon$(context$2$0) {
        var _this4 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Killing any simulator daemons for ' + this.udid);

            launchctlCmd = 'launchctl list | grep ' + this.udid + ' | cut -f 3 | xargs -n 1 launchctl';
            context$2$0.prev = 2;
            stopCmd = launchctlCmd + ' stop';
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', stopCmd]));

          case 6:
            context$2$0.next = 12;
            break;

          case 8:
            context$2$0.prev = 8;
            context$2$0.t0 = context$2$0['catch'](2);

            _logger2['default'].warn('Could not stop simulator daemons: ' + context$2$0.t0.message);
            _logger2['default'].debug('Carrying on anyway!');

          case 12:
            context$2$0.prev = 12;
            removeCmd = launchctlCmd + ' remove';
            context$2$0.next = 16;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', removeCmd]));

          case 16:
            context$2$0.next = 22;
            break;

          case 18:
            context$2$0.prev = 18;
            context$2$0.t1 = context$2$0['catch'](12);

            _logger2['default'].warn('Could not remove simulator daemons: ' + context$2$0.t1.message);
            _logger2['default'].debug('Carrying on anyway!');

          case 22:
            context$2$0.prev = 22;
            context$2$0.next = 25;
            return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$2$0() {
              var _ref3, stdout;

              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    context$3$0.next = 2;
                    return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', 'ps -e  | grep ' + this.udid + ' | grep launchd_sim | grep -v bash | grep -v grep | awk {\'print$1\'}']));

                  case 2:
                    _ref3 = context$3$0.sent;
                    stdout = _ref3.stdout;
                    return context$3$0.abrupt('return', stdout.trim().length === 0);

                  case 5:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this4);
            }, { waitMs: 10000, intervalMs: 500 }));

          case 25:
            context$2$0.next = 31;
            break;

          case 27:
            context$2$0.prev = 27;
            context$2$0.t2 = context$2$0['catch'](22);

            _logger2['default'].warn('Could not end simulator daemon for ' + this.udid + ': ' + context$2$0.t2.message);
            _logger2['default'].debug('Carrying on anyway!');

          case 31:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[2, 8], [12, 18], [22, 27]]);
    }

    /**
     * Shutdown all the running Simulators and the UI client.
     */
  }, {
    key: 'shutdown',
    value: function shutdown() {
      return _regeneratorRuntime.async(function shutdown$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap((0, _utilsJs.killAllSimulators)());

          case 2:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Delete the particular Simulator from devices list
     */
  }, {
    key: 'delete',
    value: function _delete() {
      return _regeneratorRuntime.async(function _delete$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(simctl.deleteDevice(this.udid));

          case 2:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Update the particular preference file with the given key/value pairs.
     *
     * @param {string} plist - The preferences file to update.
     * @param {object} updates - The key/value pairs to update.
     */
  }, {
    key: 'updateSettings',
    value: function updateSettings(plist, updates) {
      return _regeneratorRuntime.async(function updateSettings$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(settings.updateSettings(this, plist, updates));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Authorize/de-authorize location settings for a particular application.
     *
     * @param {string} bundleId - The application ID to update.
     * @param {boolean} authorized - Whether or not to authorize.
     */
  }, {
    key: 'updateLocationSettings',
    value: function updateLocationSettings(bundleId, authorized) {
      return _regeneratorRuntime.async(function updateLocationSettings$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(settings.updateLocationSettings(this, bundleId, authorized));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Update settings for Safari.
     *
     * @param {object} updates - The hash of key/value pairs to update for Safari.
     */
  }, {
    key: 'updateSafariSettings',
    value: function updateSafariSettings(updates) {
      return _regeneratorRuntime.async(function updateSafariSettings$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(settings.updateSafariUserSettings(this, updates));

          case 2:
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(settings.updateSettings(this, 'mobileSafari', updates));

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Update the locale for the Simulator.
     *
     * @param {string} language - The language for the simulator. E.g., `"fr_US"`.
     * @param {string} locale - The locale to set for the simulator. E.g., `"en"`.
     * @param {string} calendarFormat - The format of the calendar.
     */
  }, {
    key: 'updateLocale',
    value: function updateLocale(language, locale, calendarFormat) {
      return _regeneratorRuntime.async(function updateLocale$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(settings.updateLocale(this, language, locale, calendarFormat));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Completely delete mobile Safari application from the current Simulator.
     */
  }, {
    key: 'deleteSafari',
    value: function deleteSafari() {
      var dirs, pv, deletePromises, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, dir;

      return _regeneratorRuntime.async(function deleteSafari$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Deleting Safari apps from simulator');

            dirs = [];
            context$2$0.t0 = dirs;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.getAppDir('com.apple.mobilesafari'));

          case 5:
            context$2$0.t1 = context$2$0.sent;
            context$2$0.t0.push.call(context$2$0.t0, context$2$0.t1);
            context$2$0.next = 9;
            return _regeneratorRuntime.awrap(this.getPlatformVersion());

          case 9:
            pv = context$2$0.sent;

            if (!(pv >= 8)) {
              context$2$0.next = 16;
              break;
            }

            context$2$0.t2 = dirs;
            context$2$0.next = 14;
            return _regeneratorRuntime.awrap(this.getAppDir('com.apple.mobilesafari', 'Bundle'));

          case 14:
            context$2$0.t3 = context$2$0.sent;
            context$2$0.t2.push.call(context$2$0.t2, context$2$0.t3);

          case 16:
            deletePromises = [];
            _iteratorNormalCompletion4 = true;
            _didIteratorError4 = false;
            _iteratorError4 = undefined;
            context$2$0.prev = 20;

            for (_iterator4 = _getIterator(_lodash2['default'].compact(dirs)); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              dir = _step4.value;

              _logger2['default'].debug('Deleting directory: \'' + dir + '\'');
              deletePromises.push(_appiumSupport.fs.rimraf(dir));
            }
            context$2$0.next = 28;
            break;

          case 24:
            context$2$0.prev = 24;
            context$2$0.t4 = context$2$0['catch'](20);
            _didIteratorError4 = true;
            _iteratorError4 = context$2$0.t4;

          case 28:
            context$2$0.prev = 28;
            context$2$0.prev = 29;

            if (!_iteratorNormalCompletion4 && _iterator4['return']) {
              _iterator4['return']();
            }

          case 31:
            context$2$0.prev = 31;

            if (!_didIteratorError4) {
              context$2$0.next = 34;
              break;
            }

            throw _iteratorError4;

          case 34:
            return context$2$0.finish(31);

          case 35:
            return context$2$0.finish(28);

          case 36:
            context$2$0.next = 38;
            return _regeneratorRuntime.awrap(_bluebird2['default'].all(deletePromises));

          case 38:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[20, 24, 28, 36], [29,, 31, 35]]);
    }

    /**
     * Clean up the directories for mobile Safari.
     *
     * @param {boolean} keepPrefs - Whether to keep Safari preferences from being deleted.
     */
  }, {
    key: 'cleanSafari',
    value: function cleanSafari() {
      var keepPrefs = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

      var libraryDir, safariRoot, safariLibraryDir, filesToDelete, deletePromises, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, file;

      return _regeneratorRuntime.async(function cleanSafari$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Cleaning mobile safari data files');
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.isFresh());

          case 3:
            if (!context$2$0.sent) {
              context$2$0.next = 6;
              break;
            }

            _logger2['default'].info('Could not find Safari support directories to clean out old ' + 'data. Probably there is nothing to clean out');
            return context$2$0.abrupt('return');

          case 6:
            libraryDir = _path2['default'].resolve(this.getDir(), 'Library');
            context$2$0.next = 9;
            return _regeneratorRuntime.awrap(this.getAppDir('com.apple.mobilesafari'));

          case 9:
            safariRoot = context$2$0.sent;

            if (safariRoot) {
              context$2$0.next = 13;
              break;
            }

            _logger2['default'].info('Could not find Safari support directories to clean out old ' + 'data. Probably there is nothing to clean out');
            return context$2$0.abrupt('return');

          case 13:
            safariLibraryDir = _path2['default'].resolve(safariRoot, 'Library');
            filesToDelete = ['Caches/Snapshots/com.apple.mobilesafari', 'Caches/com.apple.mobilesafari/*', 'Caches/com.apple.WebAppCache/*', 'Caches/com.apple.WebKit.Networking/*', 'Caches/com.apple.WebKit.WebContent/*', 'Image Cache/*', 'WebKit/com.apple.mobilesafari/*', 'WebKit/GeolocationSites.plist', 'WebKit/LocalStorage/*.*', 'Safari/*', 'Cookies/*.binarycookies', 'Caches/com.apple.UIStatusBar/*', 'Caches/com.apple.keyboards/images/*', 'Caches/com.apple.Safari.SafeBrowsing/*', '../tmp/com.apple.mobilesafari/*'];
            deletePromises = [];
            _iteratorNormalCompletion5 = true;
            _didIteratorError5 = false;
            _iteratorError5 = undefined;
            context$2$0.prev = 19;

            for (_iterator5 = _getIterator(filesToDelete); !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              file = _step5.value;

              deletePromises.push(_appiumSupport.fs.rimraf(_path2['default'].resolve(libraryDir, file)));
              deletePromises.push(_appiumSupport.fs.rimraf(_path2['default'].resolve(safariLibraryDir, file)));
            }

            context$2$0.next = 27;
            break;

          case 23:
            context$2$0.prev = 23;
            context$2$0.t0 = context$2$0['catch'](19);
            _didIteratorError5 = true;
            _iteratorError5 = context$2$0.t0;

          case 27:
            context$2$0.prev = 27;
            context$2$0.prev = 28;

            if (!_iteratorNormalCompletion5 && _iterator5['return']) {
              _iterator5['return']();
            }

          case 30:
            context$2$0.prev = 30;

            if (!_didIteratorError5) {
              context$2$0.next = 33;
              break;
            }

            throw _iteratorError5;

          case 33:
            return context$2$0.finish(30);

          case 34:
            return context$2$0.finish(27);

          case 35:
            if (!keepPrefs) {
              deletePromises.push(_appiumSupport.fs.rimraf(_path2['default'].resolve(safariLibraryDir, 'Preferences/*.plist')));
            }

            context$2$0.next = 38;
            return _regeneratorRuntime.awrap(_bluebird2['default'].all(deletePromises));

          case 38:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[19, 23, 27, 35], [28,, 30, 34]]);
    }

    /**
     * Uninstall the given application from the current Simulator.
     *
     * @param {string} bundleId - The buindle ID of the application to be removed.
     */
  }, {
    key: 'removeApp',
    value: function removeApp(bundleId) {
      return _regeneratorRuntime.async(function removeApp$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(simctl.removeApp(this.udid, bundleId));

          case 2:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Move a built-in application to a new place (actually, rename it).
     *
     * @param {string} appName - The name of the app to be moved.
     * @param {string} appPath - The current path to the application.
     * @param {string} newAppPath - The new path to the application.
     *   If some application already exists by this path then it's going to be removed.
     */
  }, {
    key: 'moveBuiltInApp',
    value: function moveBuiltInApp(appName, appPath, newAppPath) {
      return _regeneratorRuntime.async(function moveBuiltInApp$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap((0, _utilsJs.safeRimRaf)(newAppPath));

          case 2:
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.copyFile(appPath, newAppPath));

          case 4:
            _logger2['default'].debug('Copied \'' + appName + '\' to \'' + newAppPath + '\'');

            context$2$0.next = 7;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(appPath));

          case 7:
            _logger2['default'].debug('Temporarily deleted original app at \'' + appPath + '\'');

            return context$2$0.abrupt('return', [newAppPath, appPath]);

          case 9:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Open the given URL in mobile Safari browser.
     * The browser will be started automatically if it is not running.
     *
     * @param {string} url - The URL to be opened.
     */
  }, {
    key: 'openUrl',
    value: function openUrl(url) {
      var SAFARI_BOOTED_INDICATOR, SAFARI_STARTUP_TIMEOUT, EXTRA_STARTUP_TIME;
      return _regeneratorRuntime.async(function openUrl$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            SAFARI_BOOTED_INDICATOR = 'MobileSafari[';
            SAFARI_STARTUP_TIMEOUT = 15 * 1000;
            EXTRA_STARTUP_TIME = 3 * 1000;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.isRunning());

          case 5:
            if (!context$2$0.sent) {
              context$2$0.next = 17;
              break;
            }

            context$2$0.next = 8;
            return _regeneratorRuntime.awrap((0, _asyncbox.retry)(5000, simctl.openUrl, this.udid, url));

          case 8:
            context$2$0.next = 10;
            return _regeneratorRuntime.awrap(this.tailLogsUntil(SAFARI_BOOTED_INDICATOR, SAFARI_STARTUP_TIMEOUT));

          case 10:
            // So sorry, but the logs have nothing else for Safari starting.. just delay a little bit
            _logger2['default'].debug('Safari started, waiting ' + EXTRA_STARTUP_TIME + 'ms for it to fully start');
            context$2$0.next = 13;
            return _regeneratorRuntime.awrap(_bluebird2['default'].delay(EXTRA_STARTUP_TIME));

          case 13:
            _logger2['default'].debug('Done waiting for Safari');
            return context$2$0.abrupt('return');

          case 17:
            throw new Error('Tried to open a url, but the Simulator is not Booted');

          case 18:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Perform Simulator caches cleanup.
     *
     * @param {...string} folderNames - The names of Caches subfolders to be cleaned.
     *   Non-accessible/non-existing subfolders will be skipped.
     *   All existing subfolders under Caches will be deleted if this parameter is omitted.
     * @returns {number} The count of cleaned cache items.
     *   Zero is returned if no items were matched for cleanup (either not accessible or not directories).
     */
  }, {
    key: 'clearCaches',
    value: function clearCaches() {
      for (var _len = arguments.length, folderNames = Array(_len), _key = 0; _key < _len; _key++) {
        folderNames[_key] = arguments[_key];
      }

      var cachesRoot, itemsToRemove;
      return _regeneratorRuntime.async(function clearCaches$(context$2$0) {
        var _this5 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            cachesRoot = _path2['default'].resolve(this.getDir(), 'Library', 'Caches');
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.hasAccess(cachesRoot));

          case 3:
            if (context$2$0.sent) {
              context$2$0.next = 6;
              break;
            }

            _logger2['default'].debug('Caches root at \'' + cachesRoot + '\' does not exist or is not accessible. Nothing to do there');
            return context$2$0.abrupt('return', 0);

          case 6:
            if (!folderNames.length) {
              context$2$0.next = 10;
              break;
            }

            context$2$0.t0 = folderNames;
            context$2$0.next = 13;
            break;

          case 10:
            context$2$0.next = 12;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.readdir(cachesRoot));

          case 12:
            context$2$0.t0 = context$2$0.sent;

          case 13:
            itemsToRemove = context$2$0.t0;

            itemsToRemove = itemsToRemove.map(function (x) {
              return _path2['default'].resolve(cachesRoot, x);
            });

            if (!folderNames.length) {
              context$2$0.next = 19;
              break;
            }

            context$2$0.next = 18;
            return _regeneratorRuntime.awrap(_bluebird2['default'].filter(itemsToRemove, function (x) {
              return _appiumSupport.fs.hasAccess(x);
            }));

          case 18:
            itemsToRemove = context$2$0.sent;

          case 19:
            context$2$0.next = 21;
            return _regeneratorRuntime.awrap(_bluebird2['default'].filter(itemsToRemove, function callee$2$0(x) {
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    context$3$0.next = 2;
                    return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(x));

                  case 2:
                    return context$3$0.abrupt('return', context$3$0.sent.isDirectory());

                  case 3:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this5);
            }));

          case 21:
            itemsToRemove = context$2$0.sent;

            if (itemsToRemove.length) {
              context$2$0.next = 25;
              break;
            }

            _logger2['default'].debug('No Simulator cache items for cleanup were matched in \'' + cachesRoot + '\'');
            return context$2$0.abrupt('return', 0);

          case 25:

            _logger2['default'].debug('Matched ' + itemsToRemove.length + ' Simulator cache ' + ('item' + (itemsToRemove.length === 1 ? '' : 's') + ' for cleanup: ' + itemsToRemove));
            context$2$0.prev = 26;
            context$2$0.next = 29;
            return _regeneratorRuntime.awrap(_bluebird2['default'].all(itemsToRemove, function (x) {
              return _appiumSupport.fs.rimraf(x);
            }));

          case 29:
            context$2$0.next = 34;
            break;

          case 31:
            context$2$0.prev = 31;
            context$2$0.t1 = context$2$0['catch'](26);

            _logger2['default'].warn('Got an exception while cleaning Simulator caches: ' + context$2$0.t1.message);

          case 34:
            return context$2$0.abrupt('return', itemsToRemove.length);

          case 35:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[26, 31]]);
    }

    /**
     * Blocks until the given indicater string appears in Simulator logs.
     *
     * @param {string} bootedIndicator - The magic string, which appears in logs after Simulator booting is completed.
     * @param {number} timeoutMs - The maximumm number of milliseconds to wait for the string indicator presence.
     * @returns {Promise} A promise that resolves when the ios simulator logs output a line matching `bootedIndicator`
     * times out after timeoutMs
     */
  }, {
    key: 'tailLogsUntil',
    value: function tailLogsUntil(bootedIndicator, timeoutMs) {
      var simLog;
      return _regeneratorRuntime.async(function tailLogsUntil$(context$2$0) {
        var _this6 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            simLog = _path2['default'].resolve(this.getLogDir(), 'system.log');
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(200, 200, function callee$2$0() {
              var exists;
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    context$3$0.next = 2;
                    return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(simLog));

                  case 2:
                    exists = context$3$0.sent;

                    if (exists) {
                      context$3$0.next = 5;
                      break;
                    }

                    throw new Error('Could not find Simulator log: \'' + simLog + '\'');

                  case 5:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this6);
            }));

          case 3:

            _logger2['default'].info('Simulator log at \'' + simLog + '\'');
            _logger2['default'].info('Tailing simulator logs until we encounter the string "' + bootedIndicator + '"');
            _logger2['default'].info('We will time out after ' + timeoutMs + 'ms');
            context$2$0.prev = 6;
            context$2$0.next = 9;
            return _regeneratorRuntime.awrap((0, _tailUntilJs.tailUntil)(simLog, bootedIndicator, timeoutMs));

          case 9:
            context$2$0.next = 14;
            break;

          case 11:
            context$2$0.prev = 11;
            context$2$0.t0 = context$2$0['catch'](6);

            _logger2['default'].debug('Simulator startup timed out. Continuing anyway.');

          case 14:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[6, 11]]);
    }

    /**
     * Enable Calendar access for the given application.
     *
     * @param {string} bundleID - Bundle ID of the application, for which the access should be granted.
     */
  }, {
    key: 'enableCalendarAccess',
    value: function enableCalendarAccess(bundleID) {
      return _regeneratorRuntime.async(function enableCalendarAccess$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.calendar.enableCalendarAccess(bundleID));

          case 2:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Disable Calendar access for the given application.
     *
     * @param {string} bundleID - Bundle ID of the application, for which the access should be denied.
     */
  }, {
    key: 'disableCalendarAccess',
    value: function disableCalendarAccess(bundleID) {
      return _regeneratorRuntime.async(function disableCalendarAccess$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.calendar.disableCalendarAccess(bundleID));

          case 2:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Check whether the given application has access to Calendar.
     *
     * @return {boolean} True if the given application has the access.
     */
  }, {
    key: 'hasCalendarAccess',
    value: function hasCalendarAccess(bundleID) {
      return _regeneratorRuntime.async(function hasCalendarAccess$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.calendar.hasCalendarAccess(bundleID));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Generate Apple script, which activates Simulator.
     *
     * @returns {string} the generated Apple Script snippet.
     */
  }, {
    key: 'generateWindowActivationScript',
    value: function generateWindowActivationScript() {
      return _regeneratorRuntime.async(function generateWindowActivationScript$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            return context$2$0.abrupt('return', '\n      tell application "System Events"\n        tell process "Simulator"\n          set frontmost to false\n          set frontmost to true\n        end tell\n      end tell\n    ');

          case 1:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Execute given Apple Script inside a critical section, so other
     * sessions cannot influence the UI client at the same time.
     *
     * @param {string} appleScript - The valid Apple Script snippet to be executed.
     * @return {string} The stdout output produced by the script.
     * @throws {Error} If osascript tool returns non-zero exit code.
     */
  }, {
    key: 'executeUIClientScript',
    value: function executeUIClientScript(appleScript) {
      var windowActivationScript, resultScript;
      return _regeneratorRuntime.async(function executeUIClientScript$(context$2$0) {
        var _this7 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.generateWindowActivationScript());

          case 2:
            windowActivationScript = context$2$0.sent;
            resultScript = windowActivationScript + '\n' + appleScript;

            _logger2['default'].debug('Executing UI Apple Script on Simulator with UDID ' + this.udid + ': ' + resultScript);
            context$2$0.next = 7;
            return _regeneratorRuntime.awrap(UI_CLIENT_ACCESS_GUARD.acquire(this.simulatorApp, function callee$2$0() {
              var _ref4, stdout;

              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    context$3$0.prev = 0;
                    context$3$0.next = 3;
                    return _regeneratorRuntime.awrap((0, _teen_process.exec)('osascript', ['-e', resultScript]));

                  case 3:
                    _ref4 = context$3$0.sent;
                    stdout = _ref4.stdout;
                    return context$3$0.abrupt('return', stdout);

                  case 8:
                    context$3$0.prev = 8;
                    context$3$0.t0 = context$3$0['catch'](0);

                    _logger2['default'].errorAndThrow('Could not complete operation. Make sure Simulator UI is running and the parent Appium application (e. g. Appium.app or Terminal.app) ' + 'is present in System Preferences > Security & Privacy > Privacy > Accessibility list. If the operation is still unsuccessful then ' + 'it is not supported by this Simulator. ' + ('Original error: ' + context$3$0.t0.message));

                  case 11:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this7, [[0, 8]]);
            }));

          case 7:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 8:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Get the current state of Touch ID Enrollment feature.
     *
     * @return {boolean} True if Touch ID Enrollment menu item is checked in Simulator menu
     */
  }, {
    key: 'isBiometricEnrolled',
    value: function isBiometricEnrolled() {
      var output;
      return _regeneratorRuntime.async(function isBiometricEnrolled$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.executeUIClientScript('\n      tell application "System Events"\n        tell process "Simulator"\n          set dstMenuItem to menu item "Toggle Enrolled State" of menu 1 of menu item "Touch ID" of menu 1 of menu bar item "Hardware" of menu bar 1\n          set isChecked to (value of attribute "AXMenuItemMarkChar" of dstMenuItem) is ""\n        end tell\n      end tell\n    '));

          case 2:
            output = context$2$0.sent;

            _logger2['default'].debug('Touch ID enrolled state: ' + output);
            return context$2$0.abrupt('return', _lodash2['default'].isString(output) && output.trim() === 'true');

          case 5:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Execute a special Apple script, which changes Touch ID feature testing in Simulator UI client.
     *
     * @param {boolean} isEnabled - Set it to false in order to uncheck 'Toggle Enrolled State' flag
     */
  }, {
    key: 'enrollBiometric',
    value: function enrollBiometric() {
      var isEnabled = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
      return _regeneratorRuntime.async(function enrollBiometric$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.executeUIClientScript('\n      tell application "System Events"\n        tell process "Simulator"\n          set dstMenuItem to menu item "Toggle Enrolled State" of menu 1 of menu item "Touch ID" of menu 1 of menu bar item "Hardware" of menu bar 1\n          set isChecked to (value of attribute "AXMenuItemMarkChar" of dstMenuItem) is ""\n          if ' + (isEnabled ? 'not ' : '') + 'isChecked then\n            click dstMenuItem\n          end if\n        end tell\n      end tell\n    '));

          case 2:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Execute a special Apple script, which clicks the particular button on Database alert.
     *
     * @param {boolean} increase - Click the button with 'Increase' title on the alert if this
     *   parameter is true. The 'Cancel' button will be clicked otherwise.
     */
  }, {
    key: 'dismissDatabaseAlert',
    value: function dismissDatabaseAlert() {
      var increase = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
      var button;
      return _regeneratorRuntime.async(function dismissDatabaseAlert$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            button = increase ? 'Increase' : 'Cancel';

            _logger2['default'].debug('Attempting to dismiss database alert with \'' + button + '\' button');
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(this.executeUIClientScript('\n      tell application "System Events"\n        tell process "Simulator"\n          click button "' + button + '" of window 1\n        end tell\n      end tell\n    '));

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    //region Keychains Interaction
    /**
     * Create the backup of keychains folder.
     * The previously created backup will be automatically
     * deleted if this method was called twice in a row without
     * `restoreKeychains` being invoked.
     *
     * @returns {boolean} True if the backup operation was successfull.
     */
  }, {
    key: 'backupKeychains',
    value: function backupKeychains() {
      var backupPath, zipArgs;
      return _regeneratorRuntime.async(function backupKeychains$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(this.keychainPath));

          case 2:
            if (context$2$0.sent) {
              context$2$0.next = 4;
              break;
            }

            return context$2$0.abrupt('return', false);

          case 4:
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(_appiumSupport.tempDir.path({
              prefix: 'keychains_backup_' + Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1),
              suffix: '.zip'
            }));

          case 6:
            backupPath = context$2$0.sent;
            zipArgs = ['-r', backupPath, '' + this.keychainPath + _path2['default'].sep];

            _logger2['default'].debug('Creating keychains backup with \'zip ' + zipArgs.join(' ') + '\' command');
            context$2$0.next = 11;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('zip', zipArgs));

          case 11:
            context$2$0.t0 = _lodash2['default'].isString(this._keychainsBackupPath);

            if (!context$2$0.t0) {
              context$2$0.next = 16;
              break;
            }

            context$2$0.next = 15;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(this._keychainsBackupPath));

          case 15:
            context$2$0.t0 = context$2$0.sent;

          case 16:
            if (!context$2$0.t0) {
              context$2$0.next = 19;
              break;
            }

            context$2$0.next = 19;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.unlink(this._keychainsBackupPath));

          case 19:
            this._keychainsBackupPath = backupPath;
            return context$2$0.abrupt('return', true);

          case 21:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Restore the previsouly created keychains backup.
     *
     * @param {?string|Array<string>} excludePatterns - The list
     * of file name patterns to be excluded from restore. The format
     * of each item should be the same as '-x' option format for
     * 'unzip' utility. This can also be a comma-separated string,
     * which is going be transformed into a list automatically,
     * for example: '*.db*,blabla.sqlite'
     * @returns {boolean} If the restore opration was successful.
     * @throws {Error} If there is no keychains backup available for restore.
     */
  }, {
    key: 'restoreKeychains',
    value: function restoreKeychains() {
      var excludePatterns = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
      var unzipArgs;
      return _regeneratorRuntime.async(function restoreKeychains$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.t0 = !_lodash2['default'].isString(this._keychainsBackupPath);

            if (context$2$0.t0) {
              context$2$0.next = 5;
              break;
            }

            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(this._keychainsBackupPath));

          case 4:
            context$2$0.t0 = !context$2$0.sent;

          case 5:
            if (!context$2$0.t0) {
              context$2$0.next = 7;
              break;
            }

            throw new Error('The keychains backup archive does not exist. ' + 'Are you sure it was created before?');

          case 7:

            if (_lodash2['default'].isString(excludePatterns)) {
              excludePatterns = excludePatterns.split(',').map(function (x) {
                return x.trim();
              });
            }
            context$2$0.next = 10;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(this.keychainPath));

          case 10:
            context$2$0.next = 12;
            return _regeneratorRuntime.awrap((0, _appiumSupport.mkdirp)(this.keychainPath));

          case 12:
            unzipArgs = ['-o', this._keychainsBackupPath].concat(_toConsumableArray(_lodash2['default'].flatMap(excludePatterns.map(function (x) {
              return ['-x', x];
            }))), ['-d', '/']);

            _logger2['default'].debug('Restoring keychains with \'unzip ' + unzipArgs.join(' ') + '\' command');
            context$2$0.next = 16;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('unzip', unzipArgs));

          case 16:
            context$2$0.next = 18;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.unlink(this._keychainsBackupPath));

          case 18:
            this._keychainsBackupPath = null;
            return context$2$0.abrupt('return', true);

          case 20:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    //endregion

  }, {
    key: 'getWebInspectorSocket',

    /*
     * @return {?string} The full path to the simulator's WebInspector Unix Domain Socket
     *   or `null` if there is no socket.
     */
    value: function getWebInspectorSocket() {
      return _regeneratorRuntime.async(function getWebInspectorSocket$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            return context$2$0.abrupt('return', null);

          case 1:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'startupTimeout',
    get: function get() {
      return STARTUP_TIMEOUT;
    }
  }], [{
    key: '_getDeviceStringPlatformVersion',
    value: function _getDeviceStringPlatformVersion(platformVersion) {
      var reqVersion;
      return _regeneratorRuntime.async(function _getDeviceStringPlatformVersion$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            reqVersion = platformVersion;

            if (reqVersion) {
              context$2$0.next = 7;
              break;
            }

            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(_appiumXcode2['default'].getMaxIOSSDK());

          case 4:
            reqVersion = context$2$0.sent;

            _logger2['default'].warn('No platform version set. Using max SDK version: ' + reqVersion);
            // this will be a number, and possibly an integer (e.g., if max iOS SDK is 9)
            // so turn it into a string and add a .0 if necessary
            if (!_lodash2['default'].isString(reqVersion)) {
              reqVersion = reqVersion % 1 ? String(reqVersion) : reqVersion + '.0';
            }

          case 7:
            return context$2$0.abrupt('return', reqVersion);

          case 8:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    // change the format in subclasses, as necessary
  }, {
    key: '_getDeviceStringVersionString',
    value: function _getDeviceStringVersionString(platformVersion) {
      var reqVersion;
      return _regeneratorRuntime.async(function _getDeviceStringVersionString$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this._getDeviceStringPlatformVersion(platformVersion));

          case 2:
            reqVersion = context$2$0.sent;
            return context$2$0.abrupt('return', '(' + reqVersion + ' Simulator)');

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    // change the format in subclasses, as necessary
  }, {
    key: '_getDeviceStringConfigFix',
    value: function _getDeviceStringConfigFix() {
      // some devices need to be updated
      return {
        'iPad Simulator (7.1 Simulator)': 'iPad 2 (7.1 Simulator)',
        'iPad Simulator (8.0 Simulator)': 'iPad 2 (8.0 Simulator)',
        'iPad Simulator (8.1 Simulator)': 'iPad 2 (8.1 Simulator)',
        'iPad Simulator (8.2 Simulator)': 'iPad 2 (8.2 Simulator)',
        'iPad Simulator (8.3 Simulator)': 'iPad 2 (8.3 Simulator)',
        'iPad Simulator (8.4 Simulator)': 'iPad 2 (8.4 Simulator)',
        'iPhone Simulator (7.1 Simulator)': 'iPhone 5s (7.1 Simulator)',
        'iPhone Simulator (8.4 Simulator)': 'iPhone 6 (8.4 Simulator)',
        'iPhone Simulator (8.3 Simulator)': 'iPhone 6 (8.3 Simulator)',
        'iPhone Simulator (8.2 Simulator)': 'iPhone 6 (8.2 Simulator)',
        'iPhone Simulator (8.1 Simulator)': 'iPhone 6 (8.1 Simulator)',
        'iPhone Simulator (8.0 Simulator)': 'iPhone 6 (8.0 Simulator)'
      };
    }

    /**
     * Takes a set of options and finds the correct device string in order for Instruments to
     * identify the correct simulator.
     *
     * @param {object} opts - The options available are:
     *   - `deviceName` - a name for the device. If the given device name starts with `=`, the name, less the equals sign, is returned.
     *   - `platformVersion` - the version of iOS to use. Defaults to the current Xcode's maximum SDK version.
     *   - `forceIphone` - force the configuration of the device string to iPhone. Defaults to `false`.
     *   - `forceIpad` - force the configuration of the device string to iPad. Defaults to `false`.
     *   If both `forceIphone` and `forceIpad` are true, the device will be forced to iPhone.
     *
     * @return {string} The found device string.
     */
  }, {
    key: 'getDeviceString',
    value: function getDeviceString(opts) {
      var logOpts, isiPhone, device, iosDeviceString, CONFIG_FIX, configFix;
      return _regeneratorRuntime.async(function getDeviceString$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            opts = _Object$assign({}, {
              deviceName: null,
              platformVersion: null,
              forceIphone: false,
              forceIpad: false
            }, opts);
            logOpts = {
              deviceName: opts.deviceName,
              platformVersion: opts.platformVersion,
              forceIphone: opts.forceIphone,
              forceIpad: opts.forceIpad
            };

            _logger2['default'].debug('Getting device string from options: ' + JSON.stringify(logOpts));

            // short circuit if we already have a device name

            if (!((opts.deviceName || '')[0] === '=')) {
              context$2$0.next = 5;
              break;
            }

            return context$2$0.abrupt('return', opts.deviceName.substring(1));

          case 5:
            isiPhone = !!opts.forceIphone || !opts.forceIpad;

            if (opts.deviceName) {
              device = opts.deviceName.toLowerCase();

              if (device.indexOf('iphone') !== -1) {
                isiPhone = true;
              } else if (device.indexOf('ipad') !== -1) {
                isiPhone = false;
              }
            }

            iosDeviceString = opts.deviceName || (isiPhone ? 'iPhone Simulator' : 'iPad Simulator');

            // if someone passes in just "iPhone", make that "iPhone Simulator" to
            // conform to all the logic below
            if (/^(iPhone|iPad)$/.test(iosDeviceString)) {
              iosDeviceString += " Simulator";
            }

            // we support deviceName: "iPhone Simulator", and also want to support
            // "iPhone XYZ Simulator", but these strings aren't in the device list.
            // So, if someone sent in "iPhone XYZ Simulator", strip off " Simulator"
            // in order to allow the default "iPhone XYZ" match
            if (/[^(iPhone|iPad)] Simulator/.test(iosDeviceString)) {
              iosDeviceString = iosDeviceString.replace(" Simulator", "");
            }
            context$2$0.next = 12;
            return _regeneratorRuntime.awrap(this._getDeviceStringVersionString(opts.platformVersion));

          case 12:
            context$2$0.t0 = context$2$0.sent;
            iosDeviceString += ' ' + context$2$0.t0;
            CONFIG_FIX = this._getDeviceStringConfigFix();
            configFix = CONFIG_FIX;

            if (configFix[iosDeviceString]) {
              iosDeviceString = configFix[iosDeviceString];
              _logger2['default'].debug('Fixing device. Changed from \'' + opts.deviceName + '\' ' + ('to \'' + iosDeviceString + '\''));
            }

            _logger2['default'].debug('Final device string is \'' + iosDeviceString + '\'');
            return context$2$0.abrupt('return', iosDeviceString);

          case 19:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }]);

  return SimulatorXcode6;
})(EventEmitter);

var _iteratorNormalCompletion6 = true;
var _didIteratorError6 = false;
var _iteratorError6 = undefined;

try {

  for (var _iterator6 = _getIterator(_lodash2['default'].toPairs(_extensionsIndex2['default'])), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
    var _step6$value = _slicedToArray(_step6.value, 2);

    var cmd = _step6$value[0];
    var fn = _step6$value[1];

    SimulatorXcode6.prototype[cmd] = fn;
  }
} catch (err) {
  _didIteratorError6 = true;
  _iteratorError6 = err;
} finally {
  try {
    if (!_iteratorNormalCompletion6 && _iterator6['return']) {
      _iterator6['return']();
    }
  } finally {
    if (_didIteratorError6) {
      throw _iteratorError6;
    }
  }
}

exports['default'] = SimulatorXcode6;
exports.SimulatorXcode6 = SimulatorXcode6;
exports.BOOT_COMPLETED_EVENT = BOOT_COMPLETED_EVENT;

// `appFile` argument only necessary for iOS below version 8

// reduce the list of path-bundle pairs to an object where bundleIds are mapped to paths

// wait for the simulator to boot
// waiting for the simulator status to be 'booted' isn't good enough
// it claims to be booted way before finishing loading
// let's tail the simulator system log until we see a magic line (this.bootedIndicator)
// eslint-disable-line curly

// wait for the system to create the files we will manipulate
// need quite a high retry number, in order to accommodate iOS 7.1
// locally, 7.1 averages 8.5 retries (from 6 - 12)
//          8 averages 0.6 retries (from 0 - 2)
//          9 averages 14 retries

// and quit

// Waits 10 sec for the simulator launchd services to stop.

// get the data directory

// get the bundle directory

// we need to make sure log file exists before we can tail it

// there is no WebInspector socket for this version of Xcode
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9zaW11bGF0b3IteGNvZGUtNi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQWlCLE1BQU07Ozs7MEJBQ0MsYUFBYTs7SUFBekIsTUFBTTs7MkJBQ3dDLGNBQWM7Ozs7c0JBQ3hELFVBQVU7Ozs7NkJBQ1UsZ0JBQWdCOzt3QkFDdEMsVUFBVTs7OztzQkFDVixRQUFROzs7O3lCQUNBLFlBQVk7Ozs7dUJBQ1ksWUFBWTs7d0JBQ08sVUFBVTs7d0JBQ2pELFlBQVk7O0lBQTFCLFFBQVE7OzRCQUNDLGNBQWM7OzJCQUNULGlCQUFpQjs7K0JBQ3BCLG9CQUFvQjs7OztzQkFDeEIsUUFBUTs7Ozt3QkFDTixZQUFZOzs7O0lBQ3pCLFlBQVksdUJBQVosWUFBWTs7QUFHcEIsSUFBTSxlQUFlLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQztBQUNsQyxJQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQztBQUNoQyxJQUFNLHNCQUFzQixHQUFHLDRCQUFlLENBQUM7Ozs7Ozs7Ozs7QUFVL0MsSUFBTSxvQkFBb0IsR0FBRyxlQUFlLENBQUM7O0lBR3ZDLGVBQWU7WUFBZixlQUFlOzs7Ozs7Ozs7QUFRUCxXQVJSLGVBQWUsQ0FRTixJQUFJLEVBQUUsWUFBWSxFQUFFOzBCQVI3QixlQUFlOztBQVNqQiwrQkFURSxlQUFlLDZDQVNUO0FBQ1IsUUFBSSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDekIsUUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7Ozs7O0FBS2pDLFFBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7O0FBRTdCLFFBQUksQ0FBQyxZQUFZLEdBQUcsa0JBQUssT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxTQUFTLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDeEUsUUFBSSxDQUFDLFlBQVksR0FBRyxtQkFBbUIsQ0FBQzs7QUFFeEMsUUFBSSxDQUFDLGtCQUFrQixHQUFHLEVBQUUsQ0FBQzs7Ozs7QUFLN0IsUUFBSSxDQUFDLFlBQVksR0FBRyxDQUNsQiwrQkFBK0IsRUFDL0IsaUJBQWlCLEVBQ2pCLDhDQUE4QyxFQUM5QyxpREFBaUQsRUFDakQsb0JBQW9CLENBQ3JCLENBQUM7OztBQUdGLFFBQUksQ0FBQyxnQkFBZ0IsR0FBRyxrQkFBa0IsQ0FBQzs7QUFFM0MsUUFBSSxDQUFDLFFBQVEsR0FBRywwQkFBYSxZQUFZLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7R0FDM0Q7Ozs7Ozs7O2VBdENHLGVBQWU7O1dBNkNLOzs7Ozs7NkNBRWQsd0JBQUssT0FBTyxFQUFFLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7OztnREFDckQsSUFBSTs7Ozs7Z0RBRUosS0FBSzs7Ozs7OztLQUVmOzs7Ozs7Ozs7Ozs7Ozs7V0FnQndCO2dCQUVoQixHQUFHOzs7OztnQkFETCxJQUFJLENBQUMsZ0JBQWdCOzs7Ozs7NkNBQ04sSUFBSSxDQUFDLElBQUksRUFBRTs7OztBQUF4QixlQUFHLFFBQUgsR0FBRzs7QUFDUixnQkFBSSxDQUFDLGdCQUFnQixHQUFHLEdBQUcsQ0FBQzs7O2dEQUV2QixJQUFJLENBQUMsZ0JBQWdCOzs7Ozs7O0tBQzdCOzs7Ozs7Ozs7V0FPVSxzQkFBRztBQUNaLFVBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO0FBQzVCLGFBQU8sa0JBQUssT0FBTyxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLGVBQWUsRUFBRSxTQUFTLENBQUMsQ0FBQztLQUMvRTs7Ozs7Ozs7O1dBT00sa0JBQUc7QUFDUixhQUFPLGtCQUFLLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztLQUMzRDs7Ozs7Ozs7O1dBT1MscUJBQUc7QUFDWCxVQUFJLElBQUksR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztBQUM1QixhQUFPLGtCQUFLLE9BQU8sQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxlQUFlLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzFFOzs7Ozs7Ozs7V0FPZ0Isb0JBQUMsR0FBRzs7Ozs7NkNBQ04sTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQzs7Ozs7Ozs7OztLQUMvQzs7Ozs7Ozs7Ozs7V0FTb0Isd0JBQUMsUUFBUTtVQUFFLE9BQU8seURBQUcsSUFBSTtVQUV4QyxPQUFPOzs7Ozs2Q0FBUyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUM7OztBQUFsRCxtQkFBTztnREFDSixPQUFPLENBQUMsTUFBTSxLQUFLLENBQUM7Ozs7Ozs7S0FDNUI7Ozs7Ozs7Ozs7O1dBU2UsbUJBQUMsRUFBRTtVQUFFLE1BQU0seURBQUcsTUFBTTs7OztBQUNsQyxnQkFBSSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7NkJBQ3BFLG9CQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLENBQUM7Ozs7Ozs7OzZDQUFXLElBQUksQ0FBQyxPQUFPLEVBQUU7Ozs7Ozs7Ozs7Ozs2Q0FDN0IsSUFBSSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQzs7O0FBQXZFLGdCQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDOzs7Z0RBRTFCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUM7Ozs7Ozs7S0FDM0M7Ozs7Ozs7Ozs7Ozs7O1dBWXdCO1VBQUMsTUFBTSx5REFBRyxNQUFNO1VBRW5DLGVBQWUsRUFDZixjQUFjLEVBZ0NkLGNBQWMsRUFDZCxlQUFlOzs7Ozs7QUFuQ25CLGdDQUFJLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO0FBQ2xDLDJCQUFlO0FBQ2YsMEJBQWM7OzZDQUNSLElBQUksQ0FBQyxrQkFBa0IsRUFBRTs7Ozs7cUNBQUssS0FBSzs7Ozs7Ozs7Ozs7O0FBUTNDLDJCQUFlLEdBQUcsa0JBQUssT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxjQUFjLENBQUMsQ0FBQztBQUM5RCwwQkFBYyxHQUFHLG9CQUFPLEdBQUc7a0JBRXJCLFFBQVEsRUFDUixRQUFROzs7O0FBRlosdUJBQUcsR0FBRyxrQkFBSyxPQUFPLENBQUMsZUFBZSxFQUFFLEdBQUcsQ0FBQyxDQUFDOztxREFDcEIsa0JBQUcsSUFBSSxDQUFJLEdBQUcsWUFBUzs7O0FBQXhDLDRCQUFRO0FBQ1IsNEJBQVEsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3REFDN0MsRUFBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBUixRQUFRLEVBQUM7Ozs7Ozs7YUFDN0IsQ0FBQzs7Ozs7O0FBRUYsNkJBQWUsR0FBRyxrQkFBSyxPQUFPLENBQUMsTUFBSyxNQUFNLEVBQUUsRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLGFBQWEsQ0FBQyxDQUFDOztBQUVuRixrQkFBSSxZQUFZLEdBQUcsU0FBZixZQUFZLENBQVUsR0FBRztvQkFDdkIsS0FBSyxFQUNMLFFBQVE7Ozs7QUFEUiwyQkFBSyxHQUFHLGtCQUFLLE9BQU8sQ0FBQyxHQUFHLEVBQUUsb0RBQW9ELENBQUM7O3VEQUM5RCxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQzs7O0FBQXJDLDhCQUFROzBEQUNMLFFBQVEsQ0FBQyxxQkFBcUI7Ozs7Ozs7ZUFDdEMsQ0FBQzs7QUFFRiw0QkFBYyxHQUFHLG9CQUFPLEdBQUc7b0JBRXJCLFFBQVE7Ozs7QUFEWix5QkFBRyxHQUFHLGtCQUFLLE9BQU8sQ0FBQyxlQUFlLEVBQUUsR0FBRyxDQUFDLENBQUM7O3VEQUNwQixZQUFZLENBQUMsR0FBRyxDQUFDOzs7QUFBbEMsOEJBQVE7MERBQ0wsRUFBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBUixRQUFRLEVBQUM7Ozs7Ozs7ZUFDN0IsQ0FBQzs7Ozs7NkNBR3VCLGtCQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUM7OztBQUFsRCwwQkFBYzs7NkNBQ1Usd0JBQVMsY0FBYyxFQUFFLG9CQUFPLEdBQUc7Ozs7O3FEQUNoRCxjQUFjLENBQUMsR0FBRyxDQUFDOzs7Ozs7Ozs7O2FBQ2pDLEVBQUUsS0FBSyxDQUFDOzs7QUFGTCwyQkFBZTtnREFLWixlQUFlLENBQUMsTUFBTSxDQUFDLFVBQUMsU0FBUyxFQUFFLFVBQVUsRUFBSztBQUN2RCx1QkFBUyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDO0FBQ2pELHFCQUFPLFNBQVMsQ0FBQzthQUNsQixFQUFFLEVBQUUsQ0FBQzs7Ozs7OztLQUNQOzs7Ozs7Ozs7Ozs7OztXQVlVO3VHQUNDLEdBQUcsRUFBRSxTQUFTLHVGQUNiLE1BQU07Ozs7Ozs7Ozs7OzZDQUQ0QixNQUFNLENBQUMsVUFBVSxFQUFFOzs7Ozt1Q0FBakMsT0FBTzs7Ozs7Ozs7O0FBQTVCLGVBQUc7QUFBRSxxQkFBUzs7Ozs7c0NBQ0gsU0FBUzs7Ozs7Ozs7QUFBbkIsa0JBQU07O2tCQUNULE1BQU0sQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQTs7Ozs7QUFDM0Isa0JBQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO2dEQUNWLE1BQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFLWixFQUFFOzs7Ozs7O0tBQ1Y7Ozs7Ozs7Ozs7OztXQVVhO1VBSVIsS0FBSyxFQUVMLEVBQUUsRUFPQSxHQUFHLEVBR0wsVUFBVSxFQUNWLEtBQUs7Ozs7Ozs7O0FBZFQsZ0NBQUksS0FBSyxDQUFDLGdEQUFnRCxDQUFDLENBQUM7QUFDeEQsaUJBQUssR0FBRyxJQUFJLENBQUMsWUFBWTs7NkNBRWQsSUFBSSxDQUFDLGtCQUFrQixFQUFFOzs7QUFBcEMsY0FBRTs7QUFDTixnQkFBSSxFQUFFLEtBQUssS0FBSyxFQUFFO0FBQ2hCLG1CQUFLLENBQUMsSUFBSSxDQUFDLGlEQUFpRCxDQUFDLENBQUM7YUFDL0QsTUFBTTtBQUNMLG1CQUFLLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO2FBQzVCOztBQUVLLGVBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFOztBQUN6QixpQkFBSyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBQyxDQUFDO3FCQUFLLGtCQUFLLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO2FBQUEsQ0FBQyxDQUFDOzs7NkNBRXhCLHdCQUFTLEtBQUssRUFBRSxvQkFBTyxDQUFDOzs7OztxREFBb0Isa0JBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7OzthQUFHLENBQUM7OztBQUFsRixzQkFBVTtBQUNWLGlCQUFLLEdBQUcsb0JBQUUsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLE1BQU0sS0FBSyxLQUFLLENBQUMsTUFBTTs7QUFDekQsZ0NBQUksS0FBSyxpQkFBYyxLQUFLLEdBQUcsU0FBUyxHQUFHLEtBQUssQ0FBQSxzQkFBbUIsQ0FBQztnREFDN0QsS0FBSzs7Ozs7OztLQUNiOzs7Ozs7Ozs7O1dBUWU7VUFDVixJQUFJOzs7Ozs2Q0FBUyxJQUFJLENBQUMsSUFBSSxFQUFFOzs7QUFBeEIsZ0JBQUk7Z0RBQ0QsSUFBSSxDQUFDLEtBQUssS0FBSyxRQUFROzs7Ozs7O0tBQy9COzs7Ozs7Ozs7OztXQVNpQixxQkFBQyxjQUFjO1VBSzNCLGVBQWU7Ozs7OzZDQUFTLElBQUksQ0FBQyx3QkFBd0IsRUFBRTs7O0FBQXZELDJCQUFlOzs2Q0FDYixJQUFJLENBQUMsYUFBYSxDQUFDLGVBQWUsRUFBRSxjQUFjLENBQUM7Ozs7OztBQUl6RCxnQ0FBSSxLQUFLLHVCQUFxQixJQUFJLENBQUMsZ0JBQWdCLG1EQUFnRCxDQUFDOzs2Q0FDOUYsc0JBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQzs7O0FBQ3BDLGdDQUFJLEtBQUssQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDOztBQUVuRCxnQkFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDOzs7Ozs7O0tBQ2pDOzs7Ozs7Ozs7V0FPOEI7VUFDekIsU0FBUyxFQUNULGVBQWU7Ozs7QUFEZixxQkFBUzs7NkNBQ2UsSUFBSSxDQUFDLGtCQUFrQixFQUFFOzs7QUFBakQsMkJBQWU7NkJBQ1gsZUFBZTtrREFDaEIsS0FBSywwQkFDTCxLQUFLLDBCQUNMLEtBQUssMEJBQ0wsS0FBSywwQkFDTCxLQUFLLDBCQUdMLEtBQUssMEJBQ0wsS0FBSywwQkFDTCxLQUFLLDBCQUNMLEtBQUssMEJBR0wsTUFBTTs7OztBQVJULHFCQUFTLEdBQUcsK0JBQStCLENBQUM7Ozs7QUFNNUMscUJBQVMsR0FBRyxxREFBcUQsQ0FBQzs7OztBQUdsRSxxQkFBUyxHQUFHLHVCQUF1QixDQUFDOzs7O0FBR3BDLGdDQUFJLElBQUksb0RBQWlELGVBQWUsUUFBSSxDQUFDO0FBQzdFLHFCQUFTLEdBQUcsb0NBQW9DLENBQUM7OztnREFFOUMsU0FBUzs7Ozs7OztLQUNqQjs7Ozs7Ozs7Ozs7Ozs7OztXQWNtQjtVQUFDLElBQUkseURBQUcsRUFBRTtVQU90QixZQUFZLEVBQ1osSUFBSSxFQUdGLElBQUksRUFDSixtQkFBbUIsRUFDbkIsWUFBWTs7OztBQVpwQixnQkFBSSxHQUFHLGVBQWM7QUFDbkIseUJBQVcsRUFBRSxJQUFJO0FBQ2pCLHFDQUF1QixFQUFFLEtBQUs7QUFDOUIsNEJBQWMsRUFBRSxJQUFJLENBQUMsY0FBYzthQUNwQyxFQUFFLElBQUksQ0FBQyxDQUFDOzs7OzZDQUUrQiwyQkFBYzs7Ozs2QkFBa0IsSUFBSSxDQUFDLFlBQVk7QUFBbkYsd0JBQVksa0JBQVEsT0FBTyxzQ0FBdUIsY0FBYztBQUNoRSxnQkFBSSxHQUFHLENBQUMsS0FBSyxFQUFFLFlBQVksRUFBRSxRQUFRLEVBQUUsb0JBQW9CLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQzs7aUJBRXpFLElBQUksQ0FBQyxXQUFXOzs7Ozs7NkNBQ0MsSUFBSSxDQUFDLElBQUksRUFBRTs7O0FBQXhCLGdCQUFJO0FBQ0osK0JBQW1CLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQztBQUNwRCx3QkFBWSx3RUFBc0UsbUJBQW1COztBQUMzRyxnQkFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDOzs7O0FBRzVDLGdCQUFJLG9CQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsRUFBRTtBQUM3QyxrQkFBSSxDQUFDLElBQUksQ0FBQywwQkFBMEIsRUFBRSxJQUFJLENBQUMsdUJBQXVCLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2FBQ2pGOztBQUVELGdDQUFJLElBQUksK0NBQTZDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUcsQ0FBQzs7NkNBQ2pFLHdCQUFLLE1BQU0sRUFBRSxJQUFJLEVBQUUsRUFBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLGNBQWMsRUFBQyxDQUFDOzs7Ozs7O0tBQ3pEOzs7Ozs7Ozs7OztXQVNTO1VBQUMsSUFBSSx5REFBRyxFQUFFOztpQkFJWCxLQUFLLEVBQ04sZUFBZSxFQUNmLGlCQUFpQixFQUtqQixTQUFTOzs7OztBQVZmLGdCQUFJLEdBQUcsZUFBYztBQUNuQiw0QkFBYyxFQUFFLElBQUksQ0FBQyxjQUFjO2FBQ3BDLEVBQUUsSUFBSSxDQUFDLENBQUM7OzZDQUNhLElBQUksQ0FBQyxJQUFJLEVBQUU7Ozs7QUFBMUIsaUJBQUssU0FBTCxLQUFLO0FBQ04sMkJBQWUsR0FBRyxLQUFLLEtBQUssUUFBUTs7NkNBQ1YsSUFBSSxDQUFDLGlCQUFpQixFQUFFOzs7QUFBbEQsNkJBQWlCOztrQkFDbkIsZUFBZSxJQUFJLGlCQUFpQixDQUFBOzs7OztBQUN0QyxnQ0FBSSxJQUFJLCtCQUE2QixJQUFJLENBQUMsSUFBSSw4Q0FBMkMsQ0FBQzs7OztBQUd0RixxQkFBUyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUU7Ozs2Q0FFMUIsSUFBSSxDQUFDLFFBQVEsRUFBRTs7Ozs7Ozs7OztBQUVyQixnQ0FBSSxJQUFJLG1DQUFpQyxlQUFJLE9BQU8sQ0FBRyxDQUFDOzs7OzZDQUVwRCxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQzs7Ozs2Q0FFeEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDOzs7QUFDM0MsZ0NBQUksSUFBSSwwQkFBd0IsSUFBSSxDQUFDLElBQUksbUJBQWMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBVyxDQUFDOzs7Ozs7O0tBQ2hHOzs7Ozs7OztXQU1XOzs7Ozs2Q0FDSixJQUFJLENBQUMsa0JBQWtCLEVBQUU7OztBQUMvQixnQ0FBSSxJQUFJLHlCQUF1QixJQUFJLENBQUMsSUFBSSxDQUFHLENBQUM7OzZDQUN0QyxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDOzs7Ozs7O0tBQzNDOzs7Ozs7Ozs7O1dBUW9CLHdCQUFDLE9BQU8sRUFBRSxXQUFXOzs7Ozs2Q0FDM0IsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsV0FBVyxFQUFFLElBQUksQ0FBQzs7Ozs7Ozs7OztLQUM3RDs7Ozs7Ozs7Ozs7OztXQVdvQix3QkFBQyxPQUFPLEVBQUUsV0FBVztVQUFFLEtBQUsseURBQUcsS0FBSzs7VUFPbkQsT0FBTyxFQU9QLGNBQWMsdUZBRVQsR0FBRyxFQU1OLFNBQVMsRUFDVCxNQUFNOzs7OztBQXRCWixnQ0FBSSxLQUFLLG9DQUFpQyxPQUFPLGNBQU8sV0FBVyxRQUFJLENBQUM7QUFDeEUsZ0JBQUksQ0FBQyxLQUFLLEVBQUU7QUFDVixrQ0FBSSxLQUFLLDJCQUEyQixDQUFDO2FBQ3RDOzs7OzZDQUdtQixJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxXQUFXLEVBQUUsS0FBSyxDQUFDOzs7QUFBNUQsbUJBQU87O2tCQUVQLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFBOzs7OztBQUN0QixnQ0FBSSxLQUFLLENBQUMsd0VBQXdFLENBQUMsQ0FBQzs7OztBQUlsRiwwQkFBYyxHQUFHLEVBQUU7Ozs7OztBQUV2QiwyQ0FBZ0IsT0FBTyx5R0FBRTtBQUFoQixpQkFBRzs7QUFDVixrQ0FBSSxLQUFLLDRCQUF5QixHQUFHLFFBQUksQ0FBQztBQUMxQyw0QkFBYyxDQUFDLElBQUksQ0FBQyxrQkFBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzthQUNyQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2Q0FFUyxJQUFJLENBQUMsa0JBQWtCLEVBQUU7Ozs7O29DQUFJLENBQUM7Ozs7O0FBQ2xDLHFCQUFTLDRCQUEwQixXQUFXO0FBQzlDLGtCQUFNLEdBQUcsa0JBQUssT0FBTyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsRUFBRSxTQUFTLENBQUM7O0FBQ3ZELGdDQUFJLEtBQUssdUJBQW9CLE1BQU0sUUFBSSxDQUFDO0FBQ3hDLDBCQUFjLENBQUMsSUFBSSxDQUFDLGtCQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDOzs7OzZDQUduQyxzQkFBRSxHQUFHLENBQUMsY0FBYyxDQUFDOzs7Ozs7O0tBQzVCOzs7Ozs7Ozs7Ozs7OztXQVlnQixvQkFBQyxPQUFPLEVBQUUsV0FBVztVQUFFLEtBQUsseURBQUcsS0FBSzs7VUFDL0MsSUFBSSxFQWFGLElBQUksRUFSSixNQUFNLFlBRUQsR0FBRzs7Ozs7QUFQVixnQkFBSSxHQUFHLEVBQUU7OzZDQUNILElBQUksQ0FBQyxrQkFBa0IsRUFBRTs7Ozs7b0NBQUksQ0FBQzs7Ozs7OzZDQUNyQixJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQzs7O0FBQXhDLGdCQUFJOztnQkFDSCxJQUFJOzs7OztnREFBUyxJQUFJOzs7Z0JBRVIsS0FBSzs7Ozs7OzZDQUFTLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLFFBQVEsQ0FBQzs7Ozs7Ozs7NkJBQUcsU0FBUzs7O0FBQXpFLGtCQUFNO21CQUVNLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQzs7QUFBOUIsaURBQWdDO0FBQXZCLGlCQUFHOztBQUNWLGtCQUFJLEdBQUcsRUFBRTtBQUNQLG9CQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2VBQ2hCO2FBQ0Y7Ozs7Ozs2Q0FFZ0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUM7OztBQUFwQyxnQkFBSTs7QUFDUixnQkFBSSxJQUFJLEVBQUU7QUFDUixrQkFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNqQjs7O2dEQUVJLElBQUk7Ozs7Ozs7S0FDWjs7Ozs7Ozs7OztXQVFtQjtVQUFDLE1BQU0seURBQUcsS0FBSztVQUFFLGNBQWMseURBQUcsSUFBSSxDQUFDLGNBQWM7Ozs7OztBQUN2RSxnQ0FBSSxLQUFLLENBQUMsNEVBQTRFLENBQUMsQ0FBQztBQUN4RixnQ0FBSSxLQUFLLCtCQUE2QixNQUFNLENBQUcsQ0FBQzs7OzZDQUUxQyxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQzs7O2lCQUUxQixNQUFNOzs7Ozs7NkNBQ0YsSUFBSSxDQUFDLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQzs7Ozs2Q0FRdEMsNkJBQWMsRUFBRSxFQUFFLEdBQUcsRUFBRTtrQkFFckIsR0FBRzs7Ozs7cURBREMsSUFBSSxDQUFDLE9BQU8sRUFBRTs7Ozs7Ozs7QUFDbEIsdUJBQUcsR0FBRyxrREFBa0Q7O0FBQzVELHdDQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzswQkFDVCxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUM7Ozs7Ozs7YUFFdkIsQ0FBQzs7Ozs2Q0FHSSxJQUFJLENBQUMsUUFBUSxFQUFFOzs7Ozs7O0tBQ3RCOzs7Ozs7OztXQU13QjtVQUduQixZQUFZLEVBRVYsT0FBTyxFQU9QLFNBQVM7Ozs7OztBQVhmLGdDQUFJLEtBQUssd0NBQXNDLElBQUksQ0FBQyxJQUFJLENBQUcsQ0FBQzs7QUFFeEQsd0JBQVksOEJBQTRCLElBQUksQ0FBQyxJQUFJOztBQUUvQyxtQkFBTyxHQUFNLFlBQVk7OzZDQUN2Qix3QkFBSyxNQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7Ozs7Ozs7Ozs7QUFFbkMsZ0NBQUksSUFBSSx3Q0FBc0MsZUFBSSxPQUFPLENBQUcsQ0FBQztBQUM3RCxnQ0FBSSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQzs7OztBQUc3QixxQkFBUyxHQUFNLFlBQVk7OzZDQUN6Qix3QkFBSyxNQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7Ozs7Ozs7Ozs7QUFFckMsZ0NBQUksSUFBSSwwQ0FBd0MsZUFBSSxPQUFPLENBQUcsQ0FBQztBQUMvRCxnQ0FBSSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQzs7Ozs7NkNBSTNCLGdDQUFpQjt5QkFDaEIsTUFBTTs7Ozs7O3FEQUFVLHdCQUFLLE1BQU0sRUFBRSxDQUFDLElBQUkscUJBQ3BCLElBQUksQ0FBQyxJQUFJLDJFQUFzRSxDQUFDOzs7O0FBRDlGLDBCQUFNLFNBQU4sTUFBTTt3REFFSixNQUFNLENBQUMsSUFBSSxFQUFFLENBQUMsTUFBTSxLQUFLLENBQUM7Ozs7Ozs7YUFDbEMsRUFBRSxFQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLEdBQUcsRUFBQyxDQUFDOzs7Ozs7Ozs7O0FBRXBDLGdDQUFJLElBQUkseUNBQXVDLElBQUksQ0FBQyxJQUFJLFVBQUssZUFBSSxPQUFPLENBQUcsQ0FBQztBQUM1RSxnQ0FBSSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQzs7Ozs7OztLQUVwQzs7Ozs7OztXQUtjOzs7Ozs2Q0FDUCxpQ0FBbUI7Ozs7Ozs7S0FDMUI7Ozs7Ozs7V0FLWTs7Ozs7NkNBQ0wsTUFBTSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDOzs7Ozs7O0tBQ3JDOzs7Ozs7Ozs7O1dBUW9CLHdCQUFDLEtBQUssRUFBRSxPQUFPOzs7Ozs2Q0FDckIsUUFBUSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBQzs7Ozs7Ozs7OztLQUMzRDs7Ozs7Ozs7OztXQVE0QixnQ0FBQyxRQUFRLEVBQUUsVUFBVTs7Ozs7NkNBQ25DLFFBQVEsQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLFVBQVUsQ0FBQzs7Ozs7Ozs7OztLQUN6RTs7Ozs7Ozs7O1dBTzBCLDhCQUFDLE9BQU87Ozs7OzZDQUMzQixRQUFRLENBQUMsd0JBQXdCLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQzs7Ozs2Q0FDaEQsUUFBUSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsY0FBYyxFQUFFLE9BQU8sQ0FBQzs7Ozs7OztLQUM3RDs7Ozs7Ozs7Ozs7V0FTa0Isc0JBQUMsUUFBUSxFQUFFLE1BQU0sRUFBRSxjQUFjOzs7Ozs2Q0FDckMsUUFBUSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxjQUFjLENBQUM7Ozs7Ozs7Ozs7S0FDM0U7Ozs7Ozs7V0FLa0I7VUFHYixJQUFJLEVBS0osRUFBRSxFQU1GLGNBQWMsdUZBQ1QsR0FBRzs7Ozs7QUFkWixnQ0FBSSxLQUFLLENBQUMscUNBQXFDLENBQUMsQ0FBQzs7QUFFN0MsZ0JBQUksR0FBRyxFQUFFOzZCQUdiLElBQUk7OzZDQUFZLElBQUksQ0FBQyxTQUFTLENBQUMsd0JBQXdCLENBQUM7Ozs7MkJBQW5ELElBQUk7OzZDQUVNLElBQUksQ0FBQyxrQkFBa0IsRUFBRTs7O0FBQXBDLGNBQUU7O2tCQUNGLEVBQUUsSUFBSSxDQUFDLENBQUE7Ozs7OzZCQUVULElBQUk7OzZDQUFZLElBQUksQ0FBQyxTQUFTLENBQUMsd0JBQXdCLEVBQUUsUUFBUSxDQUFDOzs7OzJCQUE3RCxJQUFJOzs7QUFHUCwwQkFBYyxHQUFHLEVBQUU7Ozs7OztBQUN2QiwyQ0FBZ0Isb0JBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyx5R0FBRTtBQUF4QixpQkFBRzs7QUFDVixrQ0FBSSxLQUFLLDRCQUF5QixHQUFHLFFBQUksQ0FBQztBQUMxQyw0QkFBYyxDQUFDLElBQUksQ0FBQyxrQkFBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzthQUNyQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZDQUNLLHNCQUFFLEdBQUcsQ0FBQyxjQUFjLENBQUM7Ozs7Ozs7S0FDNUI7Ozs7Ozs7OztXQU9pQjtVQUFDLFNBQVMseURBQUcsSUFBSTs7VUFRN0IsVUFBVSxFQUNWLFVBQVUsRUFNVixnQkFBZ0IsRUFDaEIsYUFBYSxFQWlCYixjQUFjLHVGQUVULElBQUk7Ozs7O0FBbENiLGdDQUFJLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDOzs2Q0FDckMsSUFBSSxDQUFDLE9BQU8sRUFBRTs7Ozs7Ozs7QUFDdEIsZ0NBQUksSUFBSSxDQUFDLDZEQUE2RCxHQUM3RCw4Q0FBOEMsQ0FBQyxDQUFDOzs7O0FBSXZELHNCQUFVLEdBQUcsa0JBQUssT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxTQUFTLENBQUM7OzZDQUNoQyxJQUFJLENBQUMsU0FBUyxDQUFDLHdCQUF3QixDQUFDOzs7QUFBM0Qsc0JBQVU7O2dCQUNULFVBQVU7Ozs7O0FBQ2IsZ0NBQUksSUFBSSxDQUFDLDZEQUE2RCxHQUM3RCw4Q0FBOEMsQ0FBQyxDQUFDOzs7O0FBR3ZELDRCQUFnQixHQUFHLGtCQUFLLE9BQU8sQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDO0FBQ3RELHlCQUFhLEdBQUcsQ0FDbEIseUNBQXlDLEVBQ3pDLGlDQUFpQyxFQUNqQyxnQ0FBZ0MsRUFDaEMsc0NBQXNDLEVBQ3RDLHNDQUFzQyxFQUN0QyxlQUFlLEVBQ2YsaUNBQWlDLEVBQ2pDLCtCQUErQixFQUMvQix5QkFBeUIsRUFDekIsVUFBVSxFQUNWLHlCQUF5QixFQUN6QixnQ0FBZ0MsRUFDaEMscUNBQXFDLEVBQ3JDLHdDQUF3QyxFQUN4QyxpQ0FBaUMsQ0FDbEM7QUFDRywwQkFBYyxHQUFHLEVBQUU7Ozs7OztBQUV2QiwyQ0FBaUIsYUFBYSx5R0FBRTtBQUF2QixrQkFBSTs7QUFDWCw0QkFBYyxDQUFDLElBQUksQ0FBQyxrQkFBRyxNQUFNLENBQUMsa0JBQUssT0FBTyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDL0QsNEJBQWMsQ0FBQyxJQUFJLENBQUMsa0JBQUcsTUFBTSxDQUFDLGtCQUFLLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDdEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVELGdCQUFJLENBQUMsU0FBUyxFQUFFO0FBQ2QsNEJBQWMsQ0FBQyxJQUFJLENBQUMsa0JBQUcsTUFBTSxDQUFDLGtCQUFLLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUN2Rjs7OzZDQUVLLHNCQUFFLEdBQUcsQ0FBQyxjQUFjLENBQUM7Ozs7Ozs7S0FDNUI7Ozs7Ozs7OztXQU9lLG1CQUFDLFFBQVE7Ozs7OzZDQUNqQixNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDOzs7Ozs7O0tBQzVDOzs7Ozs7Ozs7Ozs7V0FVb0Isd0JBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxVQUFVOzs7Ozs2Q0FDMUMseUJBQVcsVUFBVSxDQUFDOzs7OzZDQUN0QixrQkFBRyxRQUFRLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQzs7O0FBQ3RDLGdDQUFJLEtBQUssZUFBWSxPQUFPLGdCQUFTLFVBQVUsUUFBSSxDQUFDOzs7NkNBRTlDLGtCQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUM7OztBQUN4QixnQ0FBSSxLQUFLLDRDQUF5QyxPQUFPLFFBQUksQ0FBQzs7Z0RBRXZELENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQzs7Ozs7OztLQUM3Qjs7Ozs7Ozs7OztXQVFhLGlCQUFDLEdBQUc7VUFDVix1QkFBdUIsRUFDdkIsc0JBQXNCLEVBQ3RCLGtCQUFrQjs7OztBQUZsQixtQ0FBdUIsR0FBRyxlQUFlO0FBQ3pDLGtDQUFzQixHQUFHLEVBQUUsR0FBRyxJQUFJO0FBQ2xDLDhCQUFrQixHQUFHLENBQUMsR0FBRyxJQUFJOzs2Q0FFekIsSUFBSSxDQUFDLFNBQVMsRUFBRTs7Ozs7Ozs7OzZDQUNsQixxQkFBTSxJQUFJLEVBQUUsTUFBTSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQzs7Ozs2Q0FDM0MsSUFBSSxDQUFDLGFBQWEsQ0FBQyx1QkFBdUIsRUFBRSxzQkFBc0IsQ0FBQzs7OztBQUV6RSxnQ0FBSSxLQUFLLDhCQUE0QixrQkFBa0IsOEJBQTJCLENBQUM7OzZDQUM3RSxzQkFBRSxLQUFLLENBQUMsa0JBQWtCLENBQUM7OztBQUNqQyxnQ0FBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQzs7OztrQkFHL0IsSUFBSSxLQUFLLENBQUMsc0RBQXNELENBQUM7Ozs7Ozs7S0FFMUU7Ozs7Ozs7Ozs7Ozs7V0FXaUI7d0NBQUksV0FBVztBQUFYLG1CQUFXOzs7VUFDekIsVUFBVSxFQU1aLGFBQWE7Ozs7OztBQU5YLHNCQUFVLEdBQUcsa0JBQUssT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxTQUFTLEVBQUUsUUFBUSxDQUFDOzs2Q0FDdkQsa0JBQUcsU0FBUyxDQUFDLFVBQVUsQ0FBQzs7Ozs7Ozs7QUFDbEMsZ0NBQUksS0FBSyx1QkFBb0IsVUFBVSxpRUFBNkQsQ0FBQztnREFDOUYsQ0FBQzs7O2lCQUdVLFdBQVcsQ0FBQyxNQUFNOzs7Ozs2QkFBRyxXQUFXOzs7Ozs7NkNBQVUsa0JBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQzs7Ozs7O0FBQWhGLHlCQUFhOztBQUNqQix5QkFBYSxHQUFHLGFBQWEsQ0FBQyxHQUFHLENBQUMsVUFBQyxDQUFDO3FCQUFLLGtCQUFLLE9BQU8sQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO2FBQUEsQ0FBQyxDQUFDOztpQkFDbEUsV0FBVyxDQUFDLE1BQU07Ozs7Ozs2Q0FDRSxzQkFBRSxNQUFNLENBQUMsYUFBYSxFQUFFLFVBQUMsQ0FBQztxQkFBSyxrQkFBRyxTQUFTLENBQUMsQ0FBQyxDQUFDO2FBQUEsQ0FBQzs7O0FBQXJFLHlCQUFhOzs7OzZDQUVPLHNCQUFFLE1BQU0sQ0FBQyxhQUFhLEVBQUUsb0JBQU8sQ0FBQzs7Ozs7cURBQVksa0JBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQzs7O3lFQUFFLFdBQVc7Ozs7Ozs7YUFBRSxDQUFDOzs7QUFBNUYseUJBQWE7O2dCQUNSLGFBQWEsQ0FBQyxNQUFNOzs7OztBQUN2QixnQ0FBSSxLQUFLLDZEQUEwRCxVQUFVLFFBQUksQ0FBQztnREFDM0UsQ0FBQzs7OztBQUdWLGdDQUFJLEtBQUssQ0FBQyxhQUFXLGFBQWEsQ0FBQyxNQUFNLG9DQUNoQyxhQUFhLENBQUMsTUFBTSxLQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFBLHNCQUFpQixhQUFhLENBQUUsQ0FBQyxDQUFDOzs7NkNBRXhFLHNCQUFFLEdBQUcsQ0FBQyxhQUFhLEVBQUUsVUFBQyxDQUFDO3FCQUFLLGtCQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7YUFBQSxDQUFDOzs7Ozs7Ozs7O0FBRS9DLGdDQUFJLElBQUksd0RBQXNELGVBQUUsT0FBTyxDQUFHLENBQUM7OztnREFFdEUsYUFBYSxDQUFDLE1BQU07Ozs7Ozs7S0FDNUI7Ozs7Ozs7Ozs7OztXQVVtQix1QkFBQyxlQUFlLEVBQUUsU0FBUztVQUN6QyxNQUFNOzs7Ozs7QUFBTixrQkFBTSxHQUFHLGtCQUFLLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUUsWUFBWSxDQUFDOzs2Q0FHbkQsNkJBQWMsR0FBRyxFQUFFLEdBQUcsRUFBRTtrQkFDeEIsTUFBTTs7Ozs7cURBQVMsa0JBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQzs7O0FBQWhDLDBCQUFNOzt3QkFDTCxNQUFNOzs7OzswQkFDSCxJQUFJLEtBQUssc0NBQW1DLE1BQU0sUUFBSTs7Ozs7OzthQUUvRCxDQUFDOzs7O0FBRUYsZ0NBQUksSUFBSSx5QkFBc0IsTUFBTSxRQUFJLENBQUM7QUFDekMsZ0NBQUksSUFBSSw0REFBMEQsZUFBZSxPQUFJLENBQUM7QUFDdEYsZ0NBQUksSUFBSSw2QkFBMkIsU0FBUyxRQUFLLENBQUM7Ozs2Q0FFMUMsNEJBQVUsTUFBTSxFQUFFLGVBQWUsRUFBRSxTQUFTLENBQUM7Ozs7Ozs7Ozs7QUFFbkQsZ0NBQUksS0FBSyxDQUFDLGlEQUFpRCxDQUFDLENBQUM7Ozs7Ozs7S0FFaEU7Ozs7Ozs7OztXQU8wQiw4QkFBQyxRQUFROzs7Ozs2Q0FDNUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQyxRQUFRLENBQUM7Ozs7Ozs7S0FDbkQ7Ozs7Ozs7OztXQU8yQiwrQkFBQyxRQUFROzs7Ozs2Q0FDN0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxRQUFRLENBQUM7Ozs7Ozs7S0FDcEQ7Ozs7Ozs7OztXQU91QiwyQkFBQyxRQUFROzs7Ozs2Q0FDbEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUM7Ozs7Ozs7Ozs7S0FDdkQ7Ozs7Ozs7OztXQU9vQzs7Ozs7Ozs7Ozs7S0FTcEM7Ozs7Ozs7Ozs7OztXQVUyQiwrQkFBQyxXQUFXO1VBQ2hDLHNCQUFzQixFQUN0QixZQUFZOzs7Ozs7OzZDQURtQixJQUFJLENBQUMsOEJBQThCLEVBQUU7OztBQUFwRSxrQ0FBc0I7QUFDdEIsd0JBQVksR0FBTSxzQkFBc0IsVUFBSyxXQUFXOztBQUM5RCxnQ0FBSSxLQUFLLHVEQUFxRCxJQUFJLENBQUMsSUFBSSxVQUFLLFlBQVksQ0FBRyxDQUFDOzs2Q0FDL0Usc0JBQXNCLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7eUJBRXBELE1BQU07Ozs7Ozs7cURBQVUsd0JBQUssV0FBVyxFQUFFLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxDQUFDOzs7O0FBQXZELDBCQUFNLFNBQU4sTUFBTTt3REFDTixNQUFNOzs7Ozs7QUFFYix3Q0FBSSxhQUFhLENBQUMsOFFBQ29JLDRDQUMzRix5QkFDdEIsZUFBSSxPQUFPLENBQUUsQ0FBQyxDQUFDOzs7Ozs7O2FBRXZELENBQUM7Ozs7Ozs7Ozs7S0FDSDs7Ozs7Ozs7O1dBT3lCO1VBQ2xCLE1BQU07Ozs7OzZDQUFTLElBQUksQ0FBQyxxQkFBcUIsd1dBTzdDOzs7QUFQSSxrQkFBTTs7QUFRWixnQ0FBSSxLQUFLLCtCQUE2QixNQUFNLENBQUcsQ0FBQztnREFDekMsb0JBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEVBQUUsS0FBSyxNQUFNOzs7Ozs7O0tBQ3REOzs7Ozs7Ozs7V0FPcUI7VUFBQyxTQUFTLHlEQUFHLElBQUk7Ozs7OzZDQUMvQixJQUFJLENBQUMscUJBQXFCLGtWQUtyQixTQUFTLEdBQUcsTUFBTSxHQUFHLEVBQUUsQ0FBQSw2R0FLaEM7Ozs7Ozs7S0FDSDs7Ozs7Ozs7OztXQVEwQjtVQUFDLFFBQVEseURBQUcsSUFBSTtVQUNyQyxNQUFNOzs7O0FBQU4sa0JBQU0sR0FBRyxRQUFRLEdBQUcsVUFBVSxHQUFHLFFBQVE7O0FBQzdDLGdDQUFJLEtBQUssa0RBQStDLE1BQU0sZUFBVyxDQUFDOzs2Q0FDcEUsSUFBSSxDQUFDLHFCQUFxQiwwR0FHVixNQUFNLDJEQUcxQjs7Ozs7OztLQUNIOzs7Ozs7Ozs7Ozs7O1dBV3FCO1VBS2QsVUFBVSxFQUlWLE9BQU87Ozs7OzZDQVJGLGtCQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDOzs7Ozs7OztnREFDOUIsS0FBSzs7Ozs2Q0FHVyx1QkFBUSxJQUFJLENBQUM7QUFDcEMsb0JBQU0sd0JBQXNCLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFBLEdBQUksT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQUFBRTtBQUNqRyxvQkFBTSxFQUFFLE1BQU07YUFDZixDQUFDOzs7QUFISSxzQkFBVTtBQUlWLG1CQUFPLEdBQUcsQ0FDZCxJQUFJLEVBQUUsVUFBVSxPQUNiLElBQUksQ0FBQyxZQUFZLEdBQUcsa0JBQUssR0FBRyxDQUNoQzs7QUFDRCxnQ0FBSSxLQUFLLDJDQUF3QyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBWSxDQUFDOzs2Q0FDekUsd0JBQUssS0FBSyxFQUFFLE9BQU8sQ0FBQzs7OzZCQUN0QixvQkFBRSxRQUFRLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDOzs7Ozs7Ozs2Q0FBVSxrQkFBRyxNQUFNLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDOzs7Ozs7Ozs7Ozs7NkNBQy9FLGtCQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUM7OztBQUU1QyxnQkFBSSxDQUFDLG9CQUFvQixHQUFHLFVBQVUsQ0FBQztnREFDaEMsSUFBSTs7Ozs7OztLQUNaOzs7Ozs7Ozs7Ozs7Ozs7O1dBY3NCO1VBQUMsZUFBZSx5REFBRyxFQUFFO1VBV3BDLFNBQVM7Ozs7NkJBVlgsQ0FBQyxvQkFBRSxRQUFRLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDOzs7Ozs7Ozs2Q0FBVyxrQkFBRyxNQUFNLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDOzs7Ozs7Ozs7OztrQkFDakYsSUFBSSxLQUFLLENBQUMsdUZBQ3FDLENBQUM7Ozs7QUFHeEQsZ0JBQUksb0JBQUUsUUFBUSxDQUFDLGVBQWUsQ0FBQyxFQUFFO0FBQy9CLDZCQUFlLEdBQUcsZUFBZSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBQyxDQUFDO3VCQUFLLENBQUMsQ0FBQyxJQUFJLEVBQUU7ZUFBQSxDQUFDLENBQUM7YUFDbkU7OzZDQUNLLGtCQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDOzs7OzZDQUM1QiwyQkFBTyxJQUFJLENBQUMsWUFBWSxDQUFDOzs7QUFDekIscUJBQVMsSUFDYixJQUFJLEVBQUUsSUFBSSxDQUFDLG9CQUFvQiw0QkFDM0Isb0JBQUUsT0FBTyxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsVUFBQyxDQUFDO3FCQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQzthQUFBLENBQUMsQ0FBQyxJQUNwRCxJQUFJLEVBQUUsR0FBRzs7QUFFWCxnQ0FBSSxLQUFLLHVDQUFvQyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBWSxDQUFDOzs2Q0FDdkUsd0JBQUssT0FBTyxFQUFFLFNBQVMsQ0FBQzs7Ozs2Q0FDeEIsa0JBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQzs7O0FBQzFDLGdCQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDO2dEQUMxQixJQUFJOzs7Ozs7O0tBQ1o7Ozs7Ozs7Ozs7O1dBeUgyQjs7OztnREFFbkIsSUFBSTs7Ozs7OztLQUNaOzs7U0F4aENrQixlQUFHO0FBQ3BCLGFBQU8sZUFBZSxDQUFDO0tBQ3hCOzs7V0E2NUI0Qyx5Q0FBQyxlQUFlO1VBQ3ZELFVBQVU7Ozs7QUFBVixzQkFBVSxHQUFHLGVBQWU7O2dCQUMzQixVQUFVOzs7Ozs7NkNBQ00seUJBQU0sWUFBWSxFQUFFOzs7QUFBdkMsc0JBQVU7O0FBQ1YsZ0NBQUksSUFBSSxzREFBb0QsVUFBVSxDQUFHLENBQUM7OztBQUcxRSxnQkFBSSxDQUFDLG9CQUFFLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRTtBQUMzQix3QkFBVSxHQUFHLEFBQUMsVUFBVSxHQUFHLENBQUMsR0FBSSxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQU0sVUFBVSxPQUFJLENBQUM7YUFDeEU7OztnREFFSSxVQUFVOzs7Ozs7O0tBQ2xCOzs7OztXQUcwQyx1Q0FBQyxlQUFlO1VBQ3JELFVBQVU7Ozs7OzZDQUFTLElBQUksQ0FBQywrQkFBK0IsQ0FBQyxlQUFlLENBQUM7OztBQUF4RSxzQkFBVTtzREFFSCxVQUFVOzs7Ozs7O0tBQ3RCOzs7OztXQUdnQyxxQ0FBRzs7QUFFbEMsYUFBTztBQUNMLHdDQUFnQyxFQUFFLHdCQUF3QjtBQUMxRCx3Q0FBZ0MsRUFBRSx3QkFBd0I7QUFDMUQsd0NBQWdDLEVBQUUsd0JBQXdCO0FBQzFELHdDQUFnQyxFQUFFLHdCQUF3QjtBQUMxRCx3Q0FBZ0MsRUFBRSx3QkFBd0I7QUFDMUQsd0NBQWdDLEVBQUUsd0JBQXdCO0FBQzFELDBDQUFrQyxFQUFFLDJCQUEyQjtBQUMvRCwwQ0FBa0MsRUFBRSwwQkFBMEI7QUFDOUQsMENBQWtDLEVBQUUsMEJBQTBCO0FBQzlELDBDQUFrQyxFQUFFLDBCQUEwQjtBQUM5RCwwQ0FBa0MsRUFBRSwwQkFBMEI7QUFDOUQsMENBQWtDLEVBQUUsMEJBQTBCO09BQy9ELENBQUM7S0FDSDs7Ozs7Ozs7Ozs7Ozs7Ozs7V0FlNEIseUJBQUMsSUFBSTtVQU81QixPQUFPLEVBYVAsUUFBUSxFQUdOLE1BQU0sRUFRUixlQUFlLEVBaUJmLFVBQVUsRUFFVixTQUFTOzs7O0FBakRiLGdCQUFJLEdBQUcsZUFBYyxFQUFFLEVBQUU7QUFDdkIsd0JBQVUsRUFBRSxJQUFJO0FBQ2hCLDZCQUFlLEVBQUUsSUFBSTtBQUNyQix5QkFBVyxFQUFFLEtBQUs7QUFDbEIsdUJBQVMsRUFBRSxLQUFLO2FBQ2pCLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDTCxtQkFBTyxHQUFHO0FBQ1osd0JBQVUsRUFBRSxJQUFJLENBQUMsVUFBVTtBQUMzQiw2QkFBZSxFQUFFLElBQUksQ0FBQyxlQUFlO0FBQ3JDLHlCQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVc7QUFDN0IsdUJBQVMsRUFBRSxJQUFJLENBQUMsU0FBUzthQUMxQjs7QUFDRCxnQ0FBSSxLQUFLLDBDQUF3QyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFHLENBQUM7Ozs7a0JBR3hFLENBQUMsSUFBSSxDQUFDLFVBQVUsSUFBSSxFQUFFLENBQUEsQ0FBRSxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUE7Ozs7O2dEQUM3QixJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7OztBQUdqQyxvQkFBUSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVM7O0FBRXBELGdCQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7QUFDZixvQkFBTSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFOztBQUMxQyxrQkFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO0FBQ25DLHdCQUFRLEdBQUcsSUFBSSxDQUFDO2VBQ2pCLE1BQU0sSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO0FBQ3hDLHdCQUFRLEdBQUcsS0FBSyxDQUFDO2VBQ2xCO2FBQ0Y7O0FBRUcsMkJBQWUsR0FBRyxJQUFJLENBQUMsVUFBVSxLQUFLLFFBQVEsR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0IsQ0FBQSxBQUFDOzs7O0FBSTNGLGdCQUFJLGlCQUFpQixDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsRUFBRTtBQUMzQyw2QkFBZSxJQUFJLFlBQVksQ0FBQzthQUNqQzs7Ozs7O0FBTUQsZ0JBQUksNEJBQTRCLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFO0FBQ3RELDZCQUFlLEdBQUcsZUFBZSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsRUFBRSxDQUFDLENBQUM7YUFDN0Q7OzZDQUM0QixJQUFJLENBQUMsNkJBQTZCLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQzs7OztBQUFyRiwyQkFBZTtBQUVYLHNCQUFVLEdBQUcsSUFBSSxDQUFDLHlCQUF5QixFQUFFO0FBRTdDLHFCQUFTLEdBQUcsVUFBVTs7QUFDMUIsZ0JBQUksU0FBUyxDQUFDLGVBQWUsQ0FBQyxFQUFFO0FBQzlCLDZCQUFlLEdBQUcsU0FBUyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQzdDLGtDQUFJLEtBQUssQ0FBQyxtQ0FBZ0MsSUFBSSxDQUFDLFVBQVUsc0JBQ3JDLGVBQWUsUUFBRyxDQUFDLENBQUM7YUFDekM7O0FBRUQsZ0NBQUksS0FBSywrQkFBNEIsZUFBZSxRQUFJLENBQUM7Z0RBQ2xELGVBQWU7Ozs7Ozs7S0FDdkI7OztTQTFrQ0csZUFBZTtHQUFTLFlBQVk7Ozs7Ozs7O0FBc2xDMUMscUNBQXNCLG9CQUFFLE9BQU8sOEJBQVksaUhBQUU7OztRQUFuQyxHQUFHO1FBQUUsRUFBRTs7QUFDZixtQkFBZSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7R0FDckM7Ozs7Ozs7Ozs7Ozs7Ozs7cUJBRWMsZUFBZTtRQUNyQixlQUFlLEdBQWYsZUFBZTtRQUFFLG9CQUFvQixHQUFwQixvQkFBb0IiLCJmaWxlIjoibGliL3NpbXVsYXRvci14Y29kZS02LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBzaW1jdGwgZnJvbSAnbm9kZS1zaW1jdGwnO1xuaW1wb3J0IHsgZGVmYXVsdCBhcyB4Y29kZSwgZ2V0UGF0aCBhcyBnZXRYY29kZVBhdGggfSBmcm9tICdhcHBpdW0teGNvZGUnO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgeyBmcywgdGVtcERpciwgbWtkaXJwIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBBc3luY0xvY2sgZnJvbSAnYXN5bmMtbG9jayc7XG5pbXBvcnQgeyBraWxsQWxsU2ltdWxhdG9ycywgc2FmZVJpbVJhZiB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgYXN5bmNtYXAsIHJldHJ5SW50ZXJ2YWwsIHdhaXRGb3JDb25kaXRpb24sIHJldHJ5IH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0ICogYXMgc2V0dGluZ3MgZnJvbSAnLi9zZXR0aW5ncyc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCB7IHRhaWxVbnRpbCB9IGZyb20gJy4vdGFpbC11bnRpbC5qcyc7XG5pbXBvcnQgZXh0ZW5zaW9ucyBmcm9tICcuL2V4dGVuc2lvbnMvaW5kZXgnO1xuaW1wb3J0IGV2ZW50cyBmcm9tICdldmVudHMnO1xuaW1wb3J0IENhbGVuZGFyIGZyb20gJy4vY2FsZW5kYXInO1xuY29uc3QgeyBFdmVudEVtaXR0ZXIgfSA9IGV2ZW50cztcblxuXG5jb25zdCBTVEFSVFVQX1RJTUVPVVQgPSA2MCAqIDEwMDA7XG5jb25zdCBFWFRSQV9TVEFSVFVQX1RJTUUgPSAyMDAwO1xuY29uc3QgVUlfQ0xJRU5UX0FDQ0VTU19HVUFSRCA9IG5ldyBBc3luY0xvY2soKTtcblxuLypcbiAqIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCBhcyBzb29uIGFzIGlPUyBTaW11bGF0b3JcbiAqIGhhcyBmaW5pc2hlZCBib290aW5nIGFuZCBpdCBpcyByZWFkeSB0byBhY2NlcHQgeGNydW4gY29tbWFuZHMuXG4gKiBUaGUgZXZlbnQgaGFuZGxlciBpcyBjYWxsZWQgYWZ0ZXIgJ3J1bicgbWV0aG9kIGlzIGNvbXBsZXRlZFxuICogZm9yIFhjb2RlIDcgYW5kIG9sZGVyIGFuZCBpcyBvbmx5IHVzZWZ1bCBpbiBYY29kZSA4KyxcbiAqIHNpbmNlIG9uZSBjYW4gc3RhcnQgZG9pbmcgc3R1ZmYgKGZvciBleGFtcGxlIGluc3RhbGwvdW5pbnN0YWxsIGFuIGFwcCkgaW4gcGFyYWxsZWxcbiAqIHdpdGggU2ltdWxhdG9yIFVJIHN0YXJ0dXAsIHdoaWNoIHNob3J0ZW5zIHNlc3Npb24gc3RhcnR1cCB0aW1lLlxuICovXG5jb25zdCBCT09UX0NPTVBMRVRFRF9FVkVOVCA9ICdib290Q29tcGxldGVkJztcblxuXG5jbGFzcyBTaW11bGF0b3JYY29kZTYgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIHRoZSBvYmplY3Qgd2l0aCB0aGUgYHVkaWRgIGFuZCB2ZXJzaW9uIG9mIFhjb2RlLiBVc2UgdGhlIGV4cG9ydGVkIGBnZXRTaW11bGF0b3IodWRpZClgIG1ldGhvZCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdWRpZCAtIFRoZSBTaW11bGF0b3IgSUQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB4Y29kZVZlcnNpb24gLSBUaGUgdGFyZ2V0IFhjb2RlIHZlcnNpb24gaW4gZm9ybWF0IHttYWpvciwgbWlub3IsIGJ1aWxkfS5cbiAgICovXG4gIGNvbnN0cnVjdG9yICh1ZGlkLCB4Y29kZVZlcnNpb24pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudWRpZCA9IFN0cmluZyh1ZGlkKTtcbiAgICB0aGlzLnhjb2RlVmVyc2lvbiA9IHhjb2RlVmVyc2lvbjtcblxuICAgIC8vIHBsYXRmb3JtVmVyc2lvbiBjYW5ub3QgYmUgZm91bmQgaW5pdGlhbGx5LCBzaW5jZSBnZXR0aW5nIGl0IGhhcyBzaWRlIGVmZmVjdHMgZm9yXG4gICAgLy8gb3VyIGxvZ2ljIGZvciBmaWd1cmluZyBvdXQgaWYgYSBzaW0gaGFzIGJlZW4gcnVuXG4gICAgLy8gaXQgd2lsbCBiZSBzZXQgd2hlbiBpdCBpcyBuZWVkZWRcbiAgICB0aGlzLl9wbGF0Zm9ybVZlcnNpb24gPSBudWxsO1xuXG4gICAgdGhpcy5rZXljaGFpblBhdGggPSBwYXRoLnJlc29sdmUodGhpcy5nZXREaXIoKSwgJ0xpYnJhcnknLCAnS2V5Y2hhaW5zJyk7XG4gICAgdGhpcy5zaW11bGF0b3JBcHAgPSAnaU9TIFNpbXVsYXRvci5hcHAnO1xuXG4gICAgdGhpcy5hcHBEYXRhQnVuZGxlUGF0aHMgPSB7fTtcblxuICAgIC8vIGxpc3Qgb2YgZmlsZXMgdG8gY2hlY2sgZm9yIHdoZW4gc2VlaW5nIGlmIGEgc2ltdWxhdG9yIGlzIFwiZnJlc2hcIlxuICAgIC8vIChtZWFuaW5nIGl0IGhhcyBuZXZlciBiZWVuIGJvb3RlZCkuXG4gICAgLy8gSWYgdGhlc2UgZmlsZXMgYXJlIHByZXNlbnQsIHdlIGFzc3VtZSBpdCdzIGJlZW4gc3VjY2Vzc2Z1bGx5IGJvb3RlZFxuICAgIHRoaXMuaXNGcmVzaEZpbGVzID0gW1xuICAgICAgJ0xpYnJhcnkvQ29uZmlndXJhdGlvblByb2ZpbGVzJyxcbiAgICAgICdMaWJyYXJ5L0Nvb2tpZXMnLFxuICAgICAgJ0xpYnJhcnkvUHJlZmVyZW5jZXMvLkdsb2JhbFByZWZlcmVuY2VzLnBsaXN0JyxcbiAgICAgICdMaWJyYXJ5L1ByZWZlcmVuY2VzL2NvbS5hcHBsZS5zcHJpbmdib2FyZC5wbGlzdCcsXG4gICAgICAndmFyL3J1bi9zeXNsb2cucGlkJ1xuICAgIF07XG5cbiAgICAvLyBleHRyYSB0aW1lIHRvIHdhaXQgZm9yIHNpbXVsYXRvciB0byBiZSBkZWVtZWQgYm9vdGVkXG4gICAgdGhpcy5leHRyYVN0YXJ0dXBUaW1lID0gRVhUUkFfU1RBUlRVUF9USU1FO1xuXG4gICAgdGhpcy5jYWxlbmRhciA9IG5ldyBDYWxlbmRhcih4Y29kZVZlcnNpb24sIHRoaXMuZ2V0RGlyKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSBzdGF0ZSBvZiBTaW11bGF0b3IgVUkgY2xpZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIG9mIGlmIFVJIGNsaWVudCBpcyBydW5uaW5nIG9yIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGFzeW5jIGlzVUlDbGllbnRSdW5uaW5nICgpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZXhlYygncGdyZXAnLCBbJy14JywgdGhpcy5zaW11bGF0b3JBcHAuc3BsaXQoJy4nKVswXV0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhvdyBsb25nIHRvIHdhaXQgYmVmb3JlIHRocm93aW5nIGFuIGVycm9yIGFib3V0IFNpbXVsYXRvciBzdGFydHVwIHRpbWVvdXQgaGFwcGVuZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gICAqL1xuICBnZXQgc3RhcnR1cFRpbWVvdXQgKCkge1xuICAgIHJldHVybiBTVEFSVFVQX1RJTUVPVVQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwbGF0Zm9ybSB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IFNpbXVsYXRvci5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBTREsgdmVyc2lvbiwgZm9yIGV4YW1wbGUgJzguMycuXG4gICAqL1xuICBhc3luYyBnZXRQbGF0Zm9ybVZlcnNpb24gKCkge1xuICAgIGlmICghdGhpcy5fcGxhdGZvcm1WZXJzaW9uKSB7XG4gICAgICBsZXQge3Nka30gPSBhd2FpdCB0aGlzLnN0YXQoKTtcbiAgICAgIHRoaXMuX3BsYXRmb3JtVmVyc2lvbiA9IHNkaztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BsYXRmb3JtVmVyc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgZnVsbCBwYXRoIHRvIHRoZSBkaXJlY3Rvcnkgd2hlcmUgU2ltdWxhdG9yIHN0dWZmIGlzIGxvY2F0ZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHBhdGggc3RyaW5nLlxuICAgKi9cbiAgZ2V0Um9vdERpciAoKSB7XG4gICAgbGV0IGhvbWUgPSBwcm9jZXNzLmVudi5IT01FO1xuICAgIHJldHVybiBwYXRoLnJlc29sdmUoaG9tZSwgJ0xpYnJhcnknLCAnRGV2ZWxvcGVyJywgJ0NvcmVTaW11bGF0b3InLCAnRGV2aWNlcycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBmdWxsIHBhdGggdG8gdGhlIGRpcmVjdG9yeSB3aGVyZSBTaW11bGF0b3IgYXBwbGljYXRpb25zIGRhdGEgaXMgbG9jYXRlZC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgcGF0aCBzdHJpbmcuXG4gICAqL1xuICBnZXREaXIgKCkge1xuICAgIHJldHVybiBwYXRoLnJlc29sdmUodGhpcy5nZXRSb290RGlyKCksIHRoaXMudWRpZCwgJ2RhdGEnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgZnVsbCBwYXRoIHRvIHRoZSBkaXJlY3Rvcnkgd2hlcmUgU2ltdWxhdG9yIGxvZ3MgYXJlIHN0b3JlZC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgcGF0aCBzdHJpbmcuXG4gICAqL1xuICBnZXRMb2dEaXIgKCkge1xuICAgIGxldCBob21lID0gcHJvY2Vzcy5lbnYuSE9NRTtcbiAgICByZXR1cm4gcGF0aC5yZXNvbHZlKGhvbWUsICdMaWJyYXJ5JywgJ0xvZ3MnLCAnQ29yZVNpbXVsYXRvcicsIHRoaXMudWRpZCk7XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFsbCB2YWxpZCAuYXBwIHBhY2thZ2Ugb24gU2ltdWxhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXBwIC0gVGhlIHBhdGggdG8gdGhlIC5hcHAgcGFja2FnZS5cbiAgICovXG4gIGFzeW5jIGluc3RhbGxBcHAgKGFwcCkge1xuICAgIHJldHVybiBhd2FpdCBzaW1jdGwuaW5zdGFsbEFwcCh0aGlzLnVkaWQsIGFwcCk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHdoZXRoZXIgdGhlIHBhcnRpY3VsYXIgYXBwbGljYXRpb24gaXMgaW5zdGFsbGVkIG9uIFNpbXVsYXRvci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJ1bmRsZUlkIC0gVGhlIGJ1bmRsZSBpZCBvZiB0aGUgYXBwbGljYXRpb24gdG8gYmUgY2hlY2tlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFwcEZ1bGUgLSBBcHBsaWNhdGlvbiBuYW1lIG1pbnVzIFwiLmFwcFwiIChmb3IgaU9TIDcuMSlcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2l2ZW4gYXBwbGljYXRpb24gaXMgaW5zdGFsbGVkXG4gICAqL1xuICBhc3luYyBpc0FwcEluc3RhbGxlZCAoYnVuZGxlSWQsIGFwcEZpbGUgPSBudWxsKSB7XG4gICAgLy8gYGFwcEZpbGVgIGFyZ3VtZW50IG9ubHkgbmVjZXNzYXJ5IGZvciBpT1MgYmVsb3cgdmVyc2lvbiA4XG4gICAgbGV0IGFwcERpcnMgPSBhd2FpdCB0aGlzLmdldEFwcERpcnMoYXBwRmlsZSwgYnVuZGxlSWQpO1xuICAgIHJldHVybiBhcHBEaXJzLmxlbmd0aCAhPT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgZGlyZWN0b3J5IGZvciBhIHBhcnRpY3VsYXIgYXBwbGljYXRpb24ncyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBFaXRoZXIgYSBidW5kbGVJZCAoZS5nLiwgY29tLmFwcGxlLm1vYmlsZXNhZmFyaSkgb3IsIGZvciBpT1MgNy4xLCB0aGUgYXBwIG5hbWUgd2l0aG91dCBgLmFwcGAgKGUuZy4sIE1vYmlsZVNhZmFyaSlcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN1YmRpciAtIFRoZSBzdWItZGlyZWN0b3J5IHdlIGV4cGVjdCB0byBiZSB3aXRoaW4gdGhlIGFwcGxpY2F0aW9uIGRpcmVjdG9yeS4gRGVmYXVsdHMgdG8gXCJEYXRhXCIuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHJvb3QgYXBwbGljYXRpb24gZm9sZGVyLlxuICAgKi9cbiAgYXN5bmMgZ2V0QXBwRGlyIChpZCwgc3ViRGlyID0gJ0RhdGEnKSB7XG4gICAgdGhpcy5hcHBEYXRhQnVuZGxlUGF0aHNbc3ViRGlyXSA9IHRoaXMuYXBwRGF0YUJ1bmRsZVBhdGhzW3N1YkRpcl0gfHwge307XG4gICAgaWYgKF8uaXNFbXB0eSh0aGlzLmFwcERhdGFCdW5kbGVQYXRoc1tzdWJEaXJdKSAmJiAhYXdhaXQgdGhpcy5pc0ZyZXNoKCkpIHtcbiAgICAgIHRoaXMuYXBwRGF0YUJ1bmRsZVBhdGhzW3N1YkRpcl0gPSBhd2FpdCB0aGlzLmJ1aWxkQnVuZGxlUGF0aE1hcChzdWJEaXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hcHBEYXRhQnVuZGxlUGF0aHNbc3ViRGlyXVtpZF07XG4gIH1cblxuICAvKipcbiAgICogVGhlIHhjb2RlIDYgc2ltdWxhdG9ycyBhcmUgcmVhbGx5IGFubm95aW5nLCBhbmQgYnVyeSB0aGUgbWFpbiBhcHBcbiAgICogZGlyZWN0b3JpZXMgaW5zaWRlIGRpcmVjdG9yaWVzIGp1c3QgbmFtZWQgd2l0aCBIYXNoZXMuXG4gICAqIFRoaXMgZnVuY3Rpb24gZmluZHMgdGhlIHByb3BlciBkaXJlY3RvcnkgYnkgdHJhdmVyc2luZyBhbGwgb2YgdGhlbVxuICAgKiBhbmQgcmVhZGluZyBhIG1ldGFkYXRhIHBsaXN0IChNb2JpbGUgQ29udGFpbmVyIE1hbmFnZXIpIHRvIGdldCB0aGVcbiAgICogYnVuZGxlIGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViZGlyIC0gVGhlIHN1Yi1kaXJlY3Rvcnkgd2UgZXhwZWN0IHRvIGJlIHdpdGhpbiB0aGUgYXBwbGljYXRpb24gZGlyZWN0b3J5LiBEZWZhdWx0cyB0byBcIkRhdGFcIi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgbGlzdCBvZiBwYXRoLWJ1bmRsZSBwYWlycyB0byBhbiBvYmplY3Qgd2hlcmUgYnVuZGxlSWRzIGFyZSBtYXBwZWQgdG8gcGF0aHMuXG4gICAqL1xuICBhc3luYyBidWlsZEJ1bmRsZVBhdGhNYXAgKHN1YkRpciA9ICdEYXRhJykge1xuICAgIGxvZy5kZWJ1ZygnQnVpbGRpbmcgYnVuZGxlIHBhdGggbWFwJyk7XG4gICAgbGV0IGFwcGxpY2F0aW9uTGlzdDtcbiAgICBsZXQgcGF0aEJ1bmRsZVBhaXI7XG4gICAgaWYgKGF3YWl0IHRoaXMuZ2V0UGxhdGZvcm1WZXJzaW9uKCkgPT09ICc3LjEnKSB7XG4gICAgICAvLyBhcHBzIGF2YWlsYWJsZVxuICAgICAgLy8gICBXZWIuYXBwLFxuICAgICAgLy8gICBXZWJWaWV3U2VydmljZS5hcHAsXG4gICAgICAvLyAgIE1vYmlsZVNhZmFyaS5hcHAsXG4gICAgICAvLyAgIFdlYkNvbnRlbnRBbmFseXNpc1VJLmFwcCxcbiAgICAgIC8vICAgRERBY3Rpb25zU2VydmljZS5hcHAsXG4gICAgICAvLyAgIFN0b3JlS2l0VUlTZXJ2aWNlLmFwcFxuICAgICAgYXBwbGljYXRpb25MaXN0ID0gcGF0aC5yZXNvbHZlKHRoaXMuZ2V0RGlyKCksICdBcHBsaWNhdGlvbnMnKTtcbiAgICAgIHBhdGhCdW5kbGVQYWlyID0gYXN5bmMgKGRpcikgPT4ge1xuICAgICAgICBkaXIgPSBwYXRoLnJlc29sdmUoYXBwbGljYXRpb25MaXN0LCBkaXIpO1xuICAgICAgICBsZXQgYXBwRmlsZXMgPSBhd2FpdCBmcy5nbG9iKGAke2Rpcn0vKi5hcHBgKTtcbiAgICAgICAgbGV0IGJ1bmRsZUlkID0gYXBwRmlsZXNbMF0ubWF0Y2goLy4qXFwvKC4qKVxcLmFwcC8pWzFdO1xuICAgICAgICByZXR1cm4ge3BhdGg6IGRpciwgYnVuZGxlSWR9O1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwbGljYXRpb25MaXN0ID0gcGF0aC5yZXNvbHZlKHRoaXMuZ2V0RGlyKCksICdDb250YWluZXJzJywgc3ViRGlyLCAnQXBwbGljYXRpb24nKTtcbiAgICAgIC8vIGdpdmVuIGEgZGlyZWN0b3J5LCBmaW5kIHRoZSBwbGlzdCBmaWxlIGFuZCBwdWxsIHRoZSBidW5kbGUgaWQgZnJvbSBpdFxuICAgICAgbGV0IHJlYWRCdW5kbGVJZCA9IGFzeW5jIChkaXIpID0+IHtcbiAgICAgICAgbGV0IHBsaXN0ID0gcGF0aC5yZXNvbHZlKGRpciwgJy5jb20uYXBwbGUubW9iaWxlX2NvbnRhaW5lcl9tYW5hZ2VyLm1ldGFkYXRhLnBsaXN0Jyk7XG4gICAgICAgIGxldCBtZXRhZGF0YSA9IGF3YWl0IHNldHRpbmdzLnJlYWQocGxpc3QpO1xuICAgICAgICByZXR1cm4gbWV0YWRhdGEuTUNNTWV0YWRhdGFJZGVudGlmaWVyO1xuICAgICAgfTtcbiAgICAgIC8vIGdpdmVuIGEgZGlyZWN0b3J5LCByZXR1cm4gdGhlIHBhdGggYW5kIGJ1bmRsZSBpZCBhc3NvY2lhdGVkIHdpdGggaXRcbiAgICAgIHBhdGhCdW5kbGVQYWlyID0gYXN5bmMgKGRpcikgPT4ge1xuICAgICAgICBkaXIgPSBwYXRoLnJlc29sdmUoYXBwbGljYXRpb25MaXN0LCBkaXIpO1xuICAgICAgICBsZXQgYnVuZGxlSWQgPSBhd2FpdCByZWFkQnVuZGxlSWQoZGlyKTtcbiAgICAgICAgcmV0dXJuIHtwYXRoOiBkaXIsIGJ1bmRsZUlkfTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGV0IGJ1bmRsZVBhdGhEaXJzID0gYXdhaXQgZnMucmVhZGRpcihhcHBsaWNhdGlvbkxpc3QpO1xuICAgIGxldCBidW5kbGVQYXRoUGFpcnMgPSBhd2FpdCBhc3luY21hcChidW5kbGVQYXRoRGlycywgYXN5bmMgKGRpcikgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHBhdGhCdW5kbGVQYWlyKGRpcik7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgLy8gcmVkdWNlIHRoZSBsaXN0IG9mIHBhdGgtYnVuZGxlIHBhaXJzIHRvIGFuIG9iamVjdCB3aGVyZSBidW5kbGVJZHMgYXJlIG1hcHBlZCB0byBwYXRoc1xuICAgIHJldHVybiBidW5kbGVQYXRoUGFpcnMucmVkdWNlKChidW5kbGVNYXAsIGJ1bmRsZVBhdGgpID0+IHtcbiAgICAgIGJ1bmRsZU1hcFtidW5kbGVQYXRoLmJ1bmRsZUlkXSA9IGJ1bmRsZVBhdGgucGF0aDtcbiAgICAgIHJldHVybiBidW5kbGVNYXA7XG4gICAgfSwge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhdGUgYW5kIHNwZWNpZmljcyBvZiB0aGlzIHNpbS5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSBTaW11bGF0b3Igc3RhdHMgbWFwcGluZywgZm9yIGV4YW1wbGU6XG4gICAqIHsgbmFtZTogJ2lQaG9uZSA0cycsXG4gICAqICAgdWRpZDogJ0MwOUIzNEU1LTdEQ0ItNDQyRS1CNzlDLUFCNkJDMDM1NzQxNycsXG4gICAqICAgc3RhdGU6ICdTaHV0ZG93bicsXG4gICAqICAgc2RrOiAnOC4zJ1xuICAgKiB9XG4gICAqL1xuICBhc3luYyBzdGF0ICgpIHtcbiAgICBmb3IgKGxldCBbc2RrLCBkZXZpY2VBcnJdIG9mIF8udG9QYWlycyhhd2FpdCBzaW1jdGwuZ2V0RGV2aWNlcygpKSkge1xuICAgICAgZm9yIChsZXQgZGV2aWNlIG9mIGRldmljZUFycikge1xuICAgICAgICBpZiAoZGV2aWNlLnVkaWQgPT09IHRoaXMudWRpZCkge1xuICAgICAgICAgIGRldmljZS5zZGsgPSBzZGs7XG4gICAgICAgICAgcmV0dXJuIGRldmljZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgYmVzdC1iZXQgaGV1cmlzdGljIGZvciB3aGV0aGVyIG9yIG5vdCBhIHNpbSBoYXMgYmVlbiBib290ZWRcbiAgICogYmVmb3JlLiBXZSB1c3VhbGx5IHdhbnQgdG8gc3RhcnQgYSBzaW11bGF0b3IgdG8gXCJ3YXJtXCIgaXQgdXAsIGhhdmVcbiAgICogWGNvZGUgcG9wdWxhdGUgaXQgd2l0aCBwbGlzdHMgZm9yIHVzIHRvIG1hbmlwdWxhdGUgYmVmb3JlIGEgcmVhbFxuICAgKiB0ZXN0IHJ1bi5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY3VycmVudCBTaW11bGF0b3IgaGFzIG5ldmVyIGJlZW4gc3RhcnRlZCBiZWZvcmVcbiAgICovXG4gIGFzeW5jIGlzRnJlc2ggKCkge1xuICAgIC8vIGlmIHRoZSBmb2xsb3dpbmcgZmlsZXMgZG9uJ3QgZXhpc3QsIGl0IGhhc24ndCBiZWVuIGJvb3RlZC5cbiAgICAvLyBUSElTIElTIE5PVCBBTiBFWEhBVVNUSVZFIExJU1RcbiAgICBsb2cuZGVidWcoJ0NoZWNraW5nIHdoZXRoZXIgc2ltdWxhdG9yIGhhcyBiZWVuIHJ1biBiZWZvcmUnKTtcbiAgICBsZXQgZmlsZXMgPSB0aGlzLmlzRnJlc2hGaWxlcztcblxuICAgIGxldCBwdiA9IGF3YWl0IHRoaXMuZ2V0UGxhdGZvcm1WZXJzaW9uKCk7XG4gICAgaWYgKHB2ICE9PSAnNy4xJykge1xuICAgICAgZmlsZXMucHVzaCgnTGlicmFyeS9QcmVmZXJlbmNlcy9jb20uYXBwbGUuUHJlZmVyZW5jZXMucGxpc3QnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsZXMucHVzaCgnQXBwbGljYXRpb25zJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGlyID0gdGhpcy5nZXREaXIoKTtcbiAgICBmaWxlcyA9IGZpbGVzLm1hcCgocykgPT4gcGF0aC5yZXNvbHZlKGRpciwgcykpO1xuXG4gICAgbGV0IGV4aXN0ZW5jZXMgPSBhd2FpdCBhc3luY21hcChmaWxlcywgYXN5bmMgKGYpID0+IHsgcmV0dXJuIGF3YWl0IGZzLmhhc0FjY2VzcyhmKTsgfSk7XG4gICAgbGV0IGZyZXNoID0gXy5jb21wYWN0KGV4aXN0ZW5jZXMpLmxlbmd0aCAhPT0gZmlsZXMubGVuZ3RoO1xuICAgIGxvZy5kZWJ1ZyhgU2ltdWxhdG9yICR7ZnJlc2ggPyAnaGFzIG5vdCcgOiAnaGFzJ30gYmVlbiBydW4gYmVmb3JlYCk7XG4gICAgcmV0dXJuIGZyZXNoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgU2ltdWxhdG9yLiBPbmUgc2hvdWxkIGRpc3Rpbmd1aXNoIHRoZVxuICAgKiBzdGF0ZXMgb2YgU2ltdWxhdG9yIFVJIGFuZCB0aGUgU2ltdWxhdG9yIGl0c2VsZi5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY3VycmVudCBTaW11bGF0b3IgaXMgcnVubmluZy5cbiAgICovXG4gIGFzeW5jIGlzUnVubmluZyAoKSB7XG4gICAgbGV0IHN0YXQgPSBhd2FpdCB0aGlzLnN0YXQoKTtcbiAgICByZXR1cm4gc3RhdC5zdGF0ZSA9PT0gJ0Jvb3RlZCc7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHdoZXRoZXIgdGhlIFNpbXVsYXRvciBib290aW5nIGlzIGNvbXBsZXRlZCBhbmQvb3Igd2FpdCBmb3IgaXRcbiAgICogdW50aWwgdGhlIHRpbWVvdXQgZXhwaXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0dXBUaW1lb3V0IC0gdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCB1bnRpbCBib290aW5nIGlzIGNvbXBsZXRlZC5cbiAgICogQGVtaXRzIEJPT1RfQ09NUExFVEVEX0VWRU5UIGlmIHRoZSBjdXJyZW50IFNpbXVsYXRvciBpcyByZWFkeSB0byBhY2NlcHQgc2ltY3RsIGNvbW1hbmRzLCBsaWtlICdpbnN0YWxsJy5cbiAgICovXG4gIGFzeW5jIHdhaXRGb3JCb290IChzdGFydHVwVGltZW91dCkge1xuICAgIC8vIHdhaXQgZm9yIHRoZSBzaW11bGF0b3IgdG8gYm9vdFxuICAgIC8vIHdhaXRpbmcgZm9yIHRoZSBzaW11bGF0b3Igc3RhdHVzIHRvIGJlICdib290ZWQnIGlzbid0IGdvb2QgZW5vdWdoXG4gICAgLy8gaXQgY2xhaW1zIHRvIGJlIGJvb3RlZCB3YXkgYmVmb3JlIGZpbmlzaGluZyBsb2FkaW5nXG4gICAgLy8gbGV0J3MgdGFpbCB0aGUgc2ltdWxhdG9yIHN5c3RlbSBsb2cgdW50aWwgd2Ugc2VlIGEgbWFnaWMgbGluZSAodGhpcy5ib290ZWRJbmRpY2F0b3IpXG4gICAgbGV0IGJvb3RlZEluZGljYXRvciA9IGF3YWl0IHRoaXMuZ2V0Qm9vdGVkSW5kaWNhdG9yU3RyaW5nKCk7XG4gICAgYXdhaXQgdGhpcy50YWlsTG9nc1VudGlsKGJvb3RlZEluZGljYXRvciwgc3RhcnR1cFRpbWVvdXQpO1xuXG4gICAgLy8gc28gc29ycnksIGJ1dCB3ZSBzaG91bGQgd2FpdCBhbm90aGVyIHR3byBzZWNvbmRzLCBqdXN0IHRvIG1ha2Ugc3VyZSB3ZSd2ZSByZWFsbHkgc3RhcnRlZFxuICAgIC8vIHdlIGNhbid0IGxvb2sgZm9yIGFub3RoZXIgbWFnaWMgbG9nIGxpbmUsIGJlY2F1c2UgdGhleSBzZWVtIHRvIGJlIGFwcC1kZXBlbmRlbnQgKG5vdCBzeXN0ZW0gZGVwZW5kZW50KVxuICAgIGxvZy5kZWJ1ZyhgV2FpdGluZyBhbiBleHRyYSAke3RoaXMuZXh0cmFTdGFydHVwVGltZX1tcyBmb3IgdGhlIHNpbXVsYXRvciB0byByZWFsbHkgZmluaXNoIGJvb3RpbmdgKTtcbiAgICBhd2FpdCBCLmRlbGF5KHRoaXMuZXh0cmFTdGFydHVwVGltZSk7XG4gICAgbG9nLmRlYnVnKCdEb25lIHdhaXRpbmcgZXh0cmEgdGltZSBmb3Igc2ltdWxhdG9yJyk7XG5cbiAgICB0aGlzLmVtaXQoQk9PVF9DT01QTEVURURfRVZFTlQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBtYWdpYyBzdHJpbmcsIHdoaWNoLCBpZiBwcmVzZW50IGluIGxvZ3MsIHJlZmxlY3RzIHRoZSBmYWN0IHRoYXQgc2ltdWxhdG9yIGJvb3RpbmcgaGFzIGJlZW4gY29tcGxldGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBtYWdpYyBsb2cgc3RyaW5nLlxuICAgKi9cbiAgYXN5bmMgZ2V0Qm9vdGVkSW5kaWNhdG9yU3RyaW5nICgpIHtcbiAgICBsZXQgaW5kaWNhdG9yO1xuICAgIGxldCBwbGF0Zm9ybVZlcnNpb24gPSBhd2FpdCB0aGlzLmdldFBsYXRmb3JtVmVyc2lvbigpO1xuICAgIHN3aXRjaCAocGxhdGZvcm1WZXJzaW9uKSB7XG4gICAgICBjYXNlICc3LjEnOlxuICAgICAgY2FzZSAnOC4xJzpcbiAgICAgIGNhc2UgJzguMic6XG4gICAgICBjYXNlICc4LjMnOlxuICAgICAgY2FzZSAnOC40JzpcbiAgICAgICAgaW5kaWNhdG9yID0gJ3Byb2ZpbGVkOiBTZXJ2aWNlIHN0YXJ0aW5nLi4uJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc5LjAnOlxuICAgICAgY2FzZSAnOS4xJzpcbiAgICAgIGNhc2UgJzkuMic6XG4gICAgICBjYXNlICc5LjMnOlxuICAgICAgICBpbmRpY2F0b3IgPSAnU3lzdGVtIGFwcCBcImNvbS5hcHBsZS5zcHJpbmdib2FyZFwiIGZpbmlzaGVkIHN0YXJ0dXAnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzEwLjAnOlxuICAgICAgICBpbmRpY2F0b3IgPSAnU3dpdGNoaW5nIHRvIGtleWJvYXJkJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsb2cud2FybihgTm8gYm9vdCBpbmRpY2F0b3IgY2FzZSBmb3IgcGxhdGZvcm0gdmVyc2lvbiAnJHtwbGF0Zm9ybVZlcnNpb259J2ApO1xuICAgICAgICBpbmRpY2F0b3IgPSAnbm8gYm9vdCBpbmRpY2F0b3Igc3RyaW5nIGF2YWlsYWJsZSc7XG4gICAgfVxuICAgIHJldHVybiBpbmRpY2F0b3I7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIFNpbXVsYXRvciBVSSBjbGllbnQgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gT25lIG9yIG1vcmUgb2YgYXZhaWxhYmxlIFNpbXVsYXRvciBVSSBjbGllbnQgb3B0aW9uczpcbiAgICogICAtIHtzdHJpbmd9IHNjYWxlRmFjdG9yOiBjYW4gYmUgb25lIG9mIFsnMS4wJywgJzAuNzUnLCAnMC41JywgJzAuMzMnLCAnMC4yNSddLlxuICAgKiAgIERlZmluZXMgdGhlIHdpbmRvdyBzY2FsZSB2YWx1ZSBmb3IgdGhlIFVJIGNsaWVudCB3aW5kb3cgZm9yIHRoZSBjdXJyZW50IFNpbXVsYXRvci5cbiAgICogICBFcXVhbHMgdG8gbnVsbCBieSBkZWZhdWx0LCB3aGljaCBrZWVwcyB0aGUgY3VycmVudCBzY2FsZSB1bmNoYW5nZWQuXG4gICAqICAgLSB7Ym9vbGVhbn0gY29ubmVjdEhhcmR3YXJlS2V5Ym9hcmQ6IHdoZXRoZXIgdG8gY29ubmVjdCB0aGUgaGFyZHdhcmUga2V5Ym9hcmQgdG8gdGhlXG4gICAqICAgU2ltdWxhdG9yIFVJIGNsaWVudC4gRXF1YWxzIHRvIGZhbHNlIGJ5IGRlZmF1bHQuXG4gICAqICAgLSB7bnVtYmVyfSBzdGFydHVwVGltZW91dDogbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IHVudGlsIFNpbXVsYXRvciBib290aW5nXG4gICAqICAgcHJvY2VzcyBpcyBjb21wbGV0ZWQuIFRoZSBkZWZhdWx0IHRpbWVvdXQgd2lsbCBiZSB1c2VkIGlmIG5vdCBzZXQgZXhwbGljaXRseS5cbiAgICovXG4gIGFzeW5jIHN0YXJ0VUlDbGllbnQgKG9wdHMgPSB7fSkge1xuICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHNjYWxlRmFjdG9yOiBudWxsLFxuICAgICAgY29ubmVjdEhhcmR3YXJlS2V5Ym9hcmQ6IGZhbHNlLFxuICAgICAgc3RhcnR1cFRpbWVvdXQ6IHRoaXMuc3RhcnR1cFRpbWVvdXQsXG4gICAgfSwgb3B0cyk7XG5cbiAgICBjb25zdCBzaW11bGF0b3JBcHAgPSBwYXRoLnJlc29sdmUoYXdhaXQgZ2V0WGNvZGVQYXRoKCksICdBcHBsaWNhdGlvbnMnLCB0aGlzLnNpbXVsYXRvckFwcCk7XG4gICAgY29uc3QgYXJncyA9IFsnLUZuJywgc2ltdWxhdG9yQXBwLCAnLS1hcmdzJywgJy1DdXJyZW50RGV2aWNlVURJRCcsIHRoaXMudWRpZF07XG5cbiAgICBpZiAob3B0cy5zY2FsZUZhY3Rvcikge1xuICAgICAgY29uc3Qgc3RhdCA9IGF3YWl0IHRoaXMuc3RhdCgpO1xuICAgICAgY29uc3QgZm9ybWF0dGVkRGV2aWNlTmFtZSA9IHN0YXQubmFtZS5yZXBsYWNlKC9cXHMrL2csICctJyk7XG4gICAgICBjb25zdCBhcmd1bWVudE5hbWUgPSBgLVNpbXVsYXRvcldpbmRvd0xhc3RTY2FsZS1jb20uYXBwbGUuQ29yZVNpbXVsYXRvci5TaW1EZXZpY2VUeXBlLiR7Zm9ybWF0dGVkRGV2aWNlTmFtZX1gO1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50TmFtZSwgb3B0cy5zY2FsZUZhY3Rvcik7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNCb29sZWFuKG9wdHMuY29ubmVjdEhhcmR3YXJlS2V5Ym9hcmQpKSB7XG4gICAgICBhcmdzLnB1c2goJy1Db25uZWN0SGFyZHdhcmVLZXlib2FyZCcsIG9wdHMuY29ubmVjdEhhcmR3YXJlS2V5Ym9hcmQgPyAnMScgOiAnMCcpO1xuICAgIH1cblxuICAgIGxvZy5pbmZvKGBTdGFydGluZyBTaW11bGF0b3IgVUkgd2l0aCBjb21tYW5kOiBvcGVuICR7YXJncy5qb2luKCcgJyl9YCk7XG4gICAgYXdhaXQgZXhlYygnb3BlbicsIGFyZ3MsIHt0aW1lb3V0OiBvcHRzLnN0YXJ0dXBUaW1lb3V0fSk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgZ2l2ZW4gU2ltdWxhdG9yIHdpdGggb3B0aW9ucy4gVGhlIFNpbXVsYXRvciB3aWxsIG5vdCBiZSByZXN0YXJ0ZWQgaWZcbiAgICogaXQgaXMgYWxyZWFkeSBydW5uaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIE9uZSBvciBtb3JlIG9mIGF2YWlsYWJsZSBTaW11bGF0b3Igb3B0aW9ucy5cbiAgICogICBTZWUgeyNzdGFydFVJQ2xpZW50KG9wdHMpfSBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGRldGFpbHMgb24gb3RoZXIgc3VwcG9ydGVkIGtleXMuXG4gICAqL1xuICBhc3luYyBydW4gKG9wdHMgPSB7fSkge1xuICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHN0YXJ0dXBUaW1lb3V0OiB0aGlzLnN0YXJ0dXBUaW1lb3V0LFxuICAgIH0sIG9wdHMpO1xuICAgIGNvbnN0IHtzdGF0ZX0gPSBhd2FpdCB0aGlzLnN0YXQoKTtcbiAgICBjb25zdCBpc1NlcnZlclJ1bm5pbmcgPSBzdGF0ZSA9PT0gJ0Jvb3RlZCc7XG4gICAgY29uc3QgaXNVSUNsaWVudFJ1bm5pbmcgPSBhd2FpdCB0aGlzLmlzVUlDbGllbnRSdW5uaW5nKCk7XG4gICAgaWYgKGlzU2VydmVyUnVubmluZyAmJiBpc1VJQ2xpZW50UnVubmluZykge1xuICAgICAgbG9nLmluZm8oYEJvdGggU2ltdWxhdG9yIHdpdGggVURJRCAke3RoaXMudWRpZH0gYW5kIHRoZSBVSSBjbGllbnQgYXJlIGN1cnJlbnRseSBydW5uaW5nYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuc2h1dGRvd24oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKGBFcnJvciBvbiBTaW11bGF0b3Igc2h1dGRvd246ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuc3RhcnRVSUNsaWVudChvcHRzKTtcblxuICAgIGF3YWl0IHRoaXMud2FpdEZvckJvb3Qob3B0cy5zdGFydHVwVGltZW91dCk7XG4gICAgbG9nLmluZm8oYFNpbXVsYXRvciB3aXRoIFVESUQgJHt0aGlzLnVkaWR9IGJvb3RlZCBpbiAke3Byb2Nlc3MuaHJ0aW1lKHN0YXJ0VGltZSlbMF19IHNlY29uZHNgKTtcbiAgfVxuXG4gIC8vIFRPRE8ga2VlcCBrZXljaGFpbnNcbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBjdXJyZW50IFNpbXVsYXRvciB0byB0aGUgY2xlYW4gc3RhdGUuXG4gICAqL1xuICBhc3luYyBjbGVhbiAoKSB7XG4gICAgYXdhaXQgdGhpcy5lbmRTaW11bGF0b3JEYWVtb24oKTtcbiAgICBsb2cuaW5mbyhgQ2xlYW5pbmcgc2ltdWxhdG9yICR7dGhpcy51ZGlkfWApO1xuICAgIGF3YWl0IHNpbWN0bC5lcmFzZURldmljZSh0aGlzLnVkaWQsIDEwMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY3J1YiAoZGVsZXRlIHRoZSBwcmVmZXJlbmNlcyBhbmQgY2hhbmdlZCBmaWxlcykgdGhlIHBhcnRpY3VsYXIgYXBwbGljYXRpb24gb24gU2ltdWxhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXBwRmlsZSAtIEFwcGxpY2F0aW9uIG5hbWUgbWludXMgXCIuYXBwXCIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcHBCdW5kbGVJZCAtIEJ1bmRsZSBpZGVudGlmaWVyIG9mIHRoZSBhcHBsaWNhdGlvbi5cbiAgICovXG4gIGFzeW5jIHNjcnViQ3VzdG9tQXBwIChhcHBGaWxlLCBhcHBCdW5kbGVJZCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNsZWFuQ3VzdG9tQXBwKGFwcEZpbGUsIGFwcEJ1bmRsZUlkLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbi9zY3J1YiB0aGUgcGFydGljdWxhciBhcHBsaWNhdGlvbiBvbiBTaW11bGF0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcHBGaWxlIC0gQXBwbGljYXRpb24gbmFtZSBtaW51cyBcIi5hcHBcIi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFwcEJ1bmRsZUlkIC0gQnVuZGxlIGlkZW50aWZpZXIgb2YgdGhlIGFwcGxpY2F0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNjcnViIC0gSWYgYHNjcnViYCBpcyBmYWxzZSwgd2Ugd2FudCB0byBjbGVhbiBieSBkZWxldGluZyB0aGUgYXBwIGFuZCBhbGxcbiAgICogICBmaWxlcyBhc3NvY2lhdGVkIHdpdGggaXQuIElmIGBzY3J1YmAgaXMgdHJ1ZSwgd2UganVzdCB3YW50IHRvIGRlbGV0ZSB0aGUgcHJlZmVyZW5jZXMgYW5kXG4gICAqICAgY2hhbmdlZCBmaWxlcy5cbiAgICovXG4gIGFzeW5jIGNsZWFuQ3VzdG9tQXBwIChhcHBGaWxlLCBhcHBCdW5kbGVJZCwgc2NydWIgPSBmYWxzZSkge1xuICAgIGxvZy5kZWJ1ZyhgQ2xlYW5pbmcgYXBwIGRhdGEgZmlsZXMgZm9yICcke2FwcEZpbGV9JywgJyR7YXBwQnVuZGxlSWR9J2ApO1xuICAgIGlmICghc2NydWIpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgRGVsZXRpbmcgYXBwIGFsdG9nZXRoZXJgKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIGRpcmVjdG9yaWVzIHRvIGJlIGRlbGV0ZWRcbiAgICBsZXQgYXBwRGlycyA9IGF3YWl0IHRoaXMuZ2V0QXBwRGlycyhhcHBGaWxlLCBhcHBCdW5kbGVJZCwgc2NydWIpO1xuXG4gICAgaWYgKGFwcERpcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsb2cuZGVidWcoXCJDb3VsZCBub3QgZmluZCBhcHAgZGlyZWN0b3JpZXMgdG8gZGVsZXRlLiBJdCBpcyBwcm9iYWJseSBub3QgaW5zdGFsbGVkXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBkZWxldGVQcm9taXNlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgZGlyIG9mIGFwcERpcnMpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgRGVsZXRpbmcgZGlyZWN0b3J5OiAnJHtkaXJ9J2ApO1xuICAgICAgZGVsZXRlUHJvbWlzZXMucHVzaChmcy5yaW1yYWYoZGlyKSk7XG4gICAgfVxuXG4gICAgaWYgKGF3YWl0IHRoaXMuZ2V0UGxhdGZvcm1WZXJzaW9uKCkgPj0gOCkge1xuICAgICAgbGV0IHJlbFJtUGF0aCA9IGBMaWJyYXJ5L1ByZWZlcmVuY2VzLyR7YXBwQnVuZGxlSWR9LnBsaXN0YDtcbiAgICAgIGxldCBybVBhdGggPSBwYXRoLnJlc29sdmUodGhpcy5nZXRSb290RGlyKCksIHJlbFJtUGF0aCk7XG4gICAgICBsb2cuZGVidWcoYERlbGV0aW5nIGZpbGU6ICcke3JtUGF0aH0nYCk7XG4gICAgICBkZWxldGVQcm9taXNlcy5wdXNoKGZzLnJpbXJhZihybVBhdGgpKTtcbiAgICB9XG5cbiAgICBhd2FpdCBCLmFsbChkZWxldGVQcm9taXNlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgcGF0aHMgdG8gZGlycyB3aGVyZSBhcHBsaWNhdGlvbiBkYXRhIGlzIHN0b3JlZC4gaU9TIDgrIHN0b3JlcyBhcHAgZGF0YSBpbiB0d28gcGxhY2VzLFxuICAgKiBhbmQgaU9TIDcuMSBoYXMgb25seSBvbmUgZGlyZWN0b3J5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcHBGaWxlIC0gQXBwbGljYXRpb24gbmFtZSBtaW51cyBcIi5hcHBcIi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFwcEJ1bmRsZUlkIC0gQnVuZGxlIGlkZW50aWZpZXIgb2YgdGhlIGFwcGxpY2F0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNjcnViIC0gVGhlIGBCdW5kbGVgIGRpcmVjdG9yeSBoYXMgdGhlIGFjdHVhbCBhcHAgaW4gaXQuIElmIHdlIGFyZSBqdXN0IHNjcnViYmluZyxcbiAgICogICB3ZSB3YW50IHRoaXMgdG8gc3RheS4gSWYgd2UgYXJlIGNsZWFuaW5nIHdlIGRlbGV0ZS5cbiAgICogQHJldHVybiB7YXJyYXk8c3RyaW5nPn0gQXJyYXkgb2YgYXBwbGljYXRpb24gZGF0YSBwYXRocy5cbiAgICovXG4gIGFzeW5jIGdldEFwcERpcnMgKGFwcEZpbGUsIGFwcEJ1bmRsZUlkLCBzY3J1YiA9IGZhbHNlKSB7XG4gICAgbGV0IGRpcnMgPSBbXTtcbiAgICBpZiAoYXdhaXQgdGhpcy5nZXRQbGF0Zm9ybVZlcnNpb24oKSA+PSA4KSB7XG4gICAgICBsZXQgZGF0YSA9IGF3YWl0IHRoaXMuZ2V0QXBwRGlyKGFwcEJ1bmRsZUlkKTtcbiAgICAgIGlmICghZGF0YSkgcmV0dXJuIGRpcnM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY3VybHlcblxuICAgICAgbGV0IGJ1bmRsZSA9ICFzY3J1YiA/IGF3YWl0IHRoaXMuZ2V0QXBwRGlyKGFwcEJ1bmRsZUlkLCAnQnVuZGxlJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGZvciAobGV0IHNyYyBvZiBbZGF0YSwgYnVuZGxlXSkge1xuICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgZGlycy5wdXNoKHNyYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRhdGEgPSBhd2FpdCB0aGlzLmdldEFwcERpcihhcHBGaWxlKTtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGRpcnMucHVzaChkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpcnM7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSB0aGUgU2ltdWxhdG9yIGluIG9yZGVyIHRvIGhhdmUgdGhlIGluaXRpYWwgZmlsZSBzdHJ1Y3R1cmUgY3JlYXRlZCBhbmQgc2h1dGRvd24gaXQgYWZ0ZXJ3YXJkcy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBzYWZhcmkgLSBXaGV0aGVyIHRvIGV4ZWN1dGUgbW9iaWxlIFNhZmFyaSBhZnRlciBzdGFydHVwLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnR1cFRpbWVvdXQgLSBIb3cgbG9uZyB0byB3YWl0IHVudGlsIFNpbXVsYXRvciBib290aW5nIGlzIGNvbXBsZXRlZCAoaW4gbWlsbGlzZWNvbmRzKS5cbiAgICovXG4gIGFzeW5jIGxhdW5jaEFuZFF1aXQgKHNhZmFyaSA9IGZhbHNlLCBzdGFydHVwVGltZW91dCA9IHRoaXMuc3RhcnR1cFRpbWVvdXQpIHtcbiAgICBsb2cuZGVidWcoJ0F0dGVtcHRpbmcgdG8gbGF1bmNoIGFuZCBxdWl0IHRoZSBzaW11bGF0b3IsIHRvIGNyZWF0ZSBkaXJlY3Rvcnkgc3RydWN0dXJlJyk7XG4gICAgbG9nLmRlYnVnKGBXaWxsIGxhdW5jaCB3aXRoIFNhZmFyaT8gJHtzYWZhcml9YCk7XG5cbiAgICBhd2FpdCB0aGlzLnJ1bihzdGFydHVwVGltZW91dCk7XG5cbiAgICBpZiAoc2FmYXJpKSB7XG4gICAgICBhd2FpdCB0aGlzLm9wZW5VcmwoJ2h0dHA6Ly93d3cuYXBwaXVtLmlvJyk7XG4gICAgfVxuXG4gICAgLy8gd2FpdCBmb3IgdGhlIHN5c3RlbSB0byBjcmVhdGUgdGhlIGZpbGVzIHdlIHdpbGwgbWFuaXB1bGF0ZVxuICAgIC8vIG5lZWQgcXVpdGUgYSBoaWdoIHJldHJ5IG51bWJlciwgaW4gb3JkZXIgdG8gYWNjb21tb2RhdGUgaU9TIDcuMVxuICAgIC8vIGxvY2FsbHksIDcuMSBhdmVyYWdlcyA4LjUgcmV0cmllcyAoZnJvbSA2IC0gMTIpXG4gICAgLy8gICAgICAgICAgOCBhdmVyYWdlcyAwLjYgcmV0cmllcyAoZnJvbSAwIC0gMilcbiAgICAvLyAgICAgICAgICA5IGF2ZXJhZ2VzIDE0IHJldHJpZXNcbiAgICBhd2FpdCByZXRyeUludGVydmFsKDIwLCAyNTAsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChhd2FpdCB0aGlzLmlzRnJlc2goKSkge1xuICAgICAgICBsZXQgbXNnID0gJ1NpbXVsYXRvciBmaWxlcyBub3QgZnVsbHkgY3JlYXRlZC4gV2FpdGluZyBhIGJpdCc7XG4gICAgICAgIGxvZy5kZWJ1Zyhtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGFuZCBxdWl0XG4gICAgYXdhaXQgdGhpcy5zaHV0ZG93bigpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvb2tzIGZvciBsYXVuY2hkIGRhZW1vbnMgY29ycmVzcG9uZGluZyB0byB0aGUgc2ltIHVkaWQgYW5kIHRyaWVzIHRvIHN0b3AgdGhlbSBjbGVhbmx5XG4gICAqIFRoaXMgcHJldmVudHMgeGNydW4gc2ltY3RsIGVyYXNlIGZyb20gaGFuZ2luZy5cbiAgICovXG4gIGFzeW5jIGVuZFNpbXVsYXRvckRhZW1vbiAoKSB7XG4gICAgbG9nLmRlYnVnKGBLaWxsaW5nIGFueSBzaW11bGF0b3IgZGFlbW9ucyBmb3IgJHt0aGlzLnVkaWR9YCk7XG5cbiAgICBsZXQgbGF1bmNoY3RsQ21kID0gYGxhdW5jaGN0bCBsaXN0IHwgZ3JlcCAke3RoaXMudWRpZH0gfCBjdXQgLWYgMyB8IHhhcmdzIC1uIDEgbGF1bmNoY3RsYDtcbiAgICB0cnkge1xuICAgICAgbGV0IHN0b3BDbWQgPSBgJHtsYXVuY2hjdGxDbWR9IHN0b3BgO1xuICAgICAgYXdhaXQgZXhlYygnYmFzaCcsIFsnLWMnLCBzdG9wQ21kXSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cud2FybihgQ291bGQgbm90IHN0b3Agc2ltdWxhdG9yIGRhZW1vbnM6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICBsb2cuZGVidWcoJ0NhcnJ5aW5nIG9uIGFueXdheSEnKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCByZW1vdmVDbWQgPSBgJHtsYXVuY2hjdGxDbWR9IHJlbW92ZWA7XG4gICAgICBhd2FpdCBleGVjKCdiYXNoJywgWyctYycsIHJlbW92ZUNtZF0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oYENvdWxkIG5vdCByZW1vdmUgc2ltdWxhdG9yIGRhZW1vbnM6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICBsb2cuZGVidWcoJ0NhcnJ5aW5nIG9uIGFueXdheSEnKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdhaXRzIDEwIHNlYyBmb3IgdGhlIHNpbXVsYXRvciBsYXVuY2hkIHNlcnZpY2VzIHRvIHN0b3AuXG4gICAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYygnYmFzaCcsIFsnLWMnLFxuICAgICAgICAgIGBwcyAtZSAgfCBncmVwICR7dGhpcy51ZGlkfSB8IGdyZXAgbGF1bmNoZF9zaW0gfCBncmVwIC12IGJhc2ggfCBncmVwIC12IGdyZXAgfCBhd2sgeydwcmludCQxJ31gXSk7XG4gICAgICAgIHJldHVybiBzdGRvdXQudHJpbSgpLmxlbmd0aCA9PT0gMDtcbiAgICAgIH0sIHt3YWl0TXM6IDEwMDAwLCBpbnRlcnZhbE1zOiA1MDB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKGBDb3VsZCBub3QgZW5kIHNpbXVsYXRvciBkYWVtb24gZm9yICR7dGhpcy51ZGlkfTogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIGxvZy5kZWJ1ZygnQ2Fycnlpbmcgb24gYW55d2F5IScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaHV0ZG93biBhbGwgdGhlIHJ1bm5pbmcgU2ltdWxhdG9ycyBhbmQgdGhlIFVJIGNsaWVudC5cbiAgICovXG4gIGFzeW5jIHNodXRkb3duICgpIHtcbiAgICBhd2FpdCBraWxsQWxsU2ltdWxhdG9ycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSB0aGUgcGFydGljdWxhciBTaW11bGF0b3IgZnJvbSBkZXZpY2VzIGxpc3RcbiAgICovXG4gIGFzeW5jIGRlbGV0ZSAoKSB7XG4gICAgYXdhaXQgc2ltY3RsLmRlbGV0ZURldmljZSh0aGlzLnVkaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcGFydGljdWxhciBwcmVmZXJlbmNlIGZpbGUgd2l0aCB0aGUgZ2l2ZW4ga2V5L3ZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGxpc3QgLSBUaGUgcHJlZmVyZW5jZXMgZmlsZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB1cGRhdGVzIC0gVGhlIGtleS92YWx1ZSBwYWlycyB0byB1cGRhdGUuXG4gICAqL1xuICBhc3luYyB1cGRhdGVTZXR0aW5ncyAocGxpc3QsIHVwZGF0ZXMpIHtcbiAgICByZXR1cm4gYXdhaXQgc2V0dGluZ3MudXBkYXRlU2V0dGluZ3ModGhpcywgcGxpc3QsIHVwZGF0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF1dGhvcml6ZS9kZS1hdXRob3JpemUgbG9jYXRpb24gc2V0dGluZ3MgZm9yIGEgcGFydGljdWxhciBhcHBsaWNhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJ1bmRsZUlkIC0gVGhlIGFwcGxpY2F0aW9uIElEIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBhdXRob3JpemVkIC0gV2hldGhlciBvciBub3QgdG8gYXV0aG9yaXplLlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlTG9jYXRpb25TZXR0aW5ncyAoYnVuZGxlSWQsIGF1dGhvcml6ZWQpIHtcbiAgICByZXR1cm4gYXdhaXQgc2V0dGluZ3MudXBkYXRlTG9jYXRpb25TZXR0aW5ncyh0aGlzLCBidW5kbGVJZCwgYXV0aG9yaXplZCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHNldHRpbmdzIGZvciBTYWZhcmkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB1cGRhdGVzIC0gVGhlIGhhc2ggb2Yga2V5L3ZhbHVlIHBhaXJzIHRvIHVwZGF0ZSBmb3IgU2FmYXJpLlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlU2FmYXJpU2V0dGluZ3MgKHVwZGF0ZXMpIHtcbiAgICBhd2FpdCBzZXR0aW5ncy51cGRhdGVTYWZhcmlVc2VyU2V0dGluZ3ModGhpcywgdXBkYXRlcyk7XG4gICAgYXdhaXQgc2V0dGluZ3MudXBkYXRlU2V0dGluZ3ModGhpcywgJ21vYmlsZVNhZmFyaScsIHVwZGF0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgbG9jYWxlIGZvciB0aGUgU2ltdWxhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgLSBUaGUgbGFuZ3VhZ2UgZm9yIHRoZSBzaW11bGF0b3IuIEUuZy4sIGBcImZyX1VTXCJgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxlIC0gVGhlIGxvY2FsZSB0byBzZXQgZm9yIHRoZSBzaW11bGF0b3IuIEUuZy4sIGBcImVuXCJgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FsZW5kYXJGb3JtYXQgLSBUaGUgZm9ybWF0IG9mIHRoZSBjYWxlbmRhci5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZUxvY2FsZSAobGFuZ3VhZ2UsIGxvY2FsZSwgY2FsZW5kYXJGb3JtYXQpIHtcbiAgICByZXR1cm4gYXdhaXQgc2V0dGluZ3MudXBkYXRlTG9jYWxlKHRoaXMsIGxhbmd1YWdlLCBsb2NhbGUsIGNhbGVuZGFyRm9ybWF0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wbGV0ZWx5IGRlbGV0ZSBtb2JpbGUgU2FmYXJpIGFwcGxpY2F0aW9uIGZyb20gdGhlIGN1cnJlbnQgU2ltdWxhdG9yLlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlU2FmYXJpICgpIHtcbiAgICBsb2cuZGVidWcoJ0RlbGV0aW5nIFNhZmFyaSBhcHBzIGZyb20gc2ltdWxhdG9yJyk7XG5cbiAgICBsZXQgZGlycyA9IFtdO1xuXG4gICAgLy8gZ2V0IHRoZSBkYXRhIGRpcmVjdG9yeVxuICAgIGRpcnMucHVzaChhd2FpdCB0aGlzLmdldEFwcERpcignY29tLmFwcGxlLm1vYmlsZXNhZmFyaScpKTtcblxuICAgIGxldCBwdiA9IGF3YWl0IHRoaXMuZ2V0UGxhdGZvcm1WZXJzaW9uKCk7XG4gICAgaWYgKHB2ID49IDgpIHtcbiAgICAgIC8vIGdldCB0aGUgYnVuZGxlIGRpcmVjdG9yeVxuICAgICAgZGlycy5wdXNoKGF3YWl0IHRoaXMuZ2V0QXBwRGlyKCdjb20uYXBwbGUubW9iaWxlc2FmYXJpJywgJ0J1bmRsZScpKTtcbiAgICB9XG5cbiAgICBsZXQgZGVsZXRlUHJvbWlzZXMgPSBbXTtcbiAgICBmb3IgKGxldCBkaXIgb2YgXy5jb21wYWN0KGRpcnMpKSB7XG4gICAgICBsb2cuZGVidWcoYERlbGV0aW5nIGRpcmVjdG9yeTogJyR7ZGlyfSdgKTtcbiAgICAgIGRlbGV0ZVByb21pc2VzLnB1c2goZnMucmltcmFmKGRpcikpO1xuICAgIH1cbiAgICBhd2FpdCBCLmFsbChkZWxldGVQcm9taXNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAgdGhlIGRpcmVjdG9yaWVzIGZvciBtb2JpbGUgU2FmYXJpLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBQcmVmcyAtIFdoZXRoZXIgdG8ga2VlcCBTYWZhcmkgcHJlZmVyZW5jZXMgZnJvbSBiZWluZyBkZWxldGVkLlxuICAgKi9cbiAgYXN5bmMgY2xlYW5TYWZhcmkgKGtlZXBQcmVmcyA9IHRydWUpIHtcbiAgICBsb2cuZGVidWcoJ0NsZWFuaW5nIG1vYmlsZSBzYWZhcmkgZGF0YSBmaWxlcycpO1xuICAgIGlmIChhd2FpdCB0aGlzLmlzRnJlc2goKSkge1xuICAgICAgbG9nLmluZm8oJ0NvdWxkIG5vdCBmaW5kIFNhZmFyaSBzdXBwb3J0IGRpcmVjdG9yaWVzIHRvIGNsZWFuIG91dCBvbGQgJyArXG4gICAgICAgICAgICAgICAnZGF0YS4gUHJvYmFibHkgdGhlcmUgaXMgbm90aGluZyB0byBjbGVhbiBvdXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgbGlicmFyeURpciA9IHBhdGgucmVzb2x2ZSh0aGlzLmdldERpcigpLCAnTGlicmFyeScpO1xuICAgIGxldCBzYWZhcmlSb290ID0gYXdhaXQgdGhpcy5nZXRBcHBEaXIoJ2NvbS5hcHBsZS5tb2JpbGVzYWZhcmknKTtcbiAgICBpZiAoIXNhZmFyaVJvb3QpIHtcbiAgICAgIGxvZy5pbmZvKCdDb3VsZCBub3QgZmluZCBTYWZhcmkgc3VwcG9ydCBkaXJlY3RvcmllcyB0byBjbGVhbiBvdXQgb2xkICcgK1xuICAgICAgICAgICAgICAgJ2RhdGEuIFByb2JhYmx5IHRoZXJlIGlzIG5vdGhpbmcgdG8gY2xlYW4gb3V0Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBzYWZhcmlMaWJyYXJ5RGlyID0gcGF0aC5yZXNvbHZlKHNhZmFyaVJvb3QsICdMaWJyYXJ5Jyk7XG4gICAgbGV0IGZpbGVzVG9EZWxldGUgPSBbXG4gICAgICAnQ2FjaGVzL1NuYXBzaG90cy9jb20uYXBwbGUubW9iaWxlc2FmYXJpJyxcbiAgICAgICdDYWNoZXMvY29tLmFwcGxlLm1vYmlsZXNhZmFyaS8qJyxcbiAgICAgICdDYWNoZXMvY29tLmFwcGxlLldlYkFwcENhY2hlLyonLFxuICAgICAgJ0NhY2hlcy9jb20uYXBwbGUuV2ViS2l0Lk5ldHdvcmtpbmcvKicsXG4gICAgICAnQ2FjaGVzL2NvbS5hcHBsZS5XZWJLaXQuV2ViQ29udGVudC8qJyxcbiAgICAgICdJbWFnZSBDYWNoZS8qJyxcbiAgICAgICdXZWJLaXQvY29tLmFwcGxlLm1vYmlsZXNhZmFyaS8qJyxcbiAgICAgICdXZWJLaXQvR2VvbG9jYXRpb25TaXRlcy5wbGlzdCcsXG4gICAgICAnV2ViS2l0L0xvY2FsU3RvcmFnZS8qLionLFxuICAgICAgJ1NhZmFyaS8qJyxcbiAgICAgICdDb29raWVzLyouYmluYXJ5Y29va2llcycsXG4gICAgICAnQ2FjaGVzL2NvbS5hcHBsZS5VSVN0YXR1c0Jhci8qJyxcbiAgICAgICdDYWNoZXMvY29tLmFwcGxlLmtleWJvYXJkcy9pbWFnZXMvKicsXG4gICAgICAnQ2FjaGVzL2NvbS5hcHBsZS5TYWZhcmkuU2FmZUJyb3dzaW5nLyonLFxuICAgICAgJy4uL3RtcC9jb20uYXBwbGUubW9iaWxlc2FmYXJpLyonXG4gICAgXTtcbiAgICBsZXQgZGVsZXRlUHJvbWlzZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGZpbGUgb2YgZmlsZXNUb0RlbGV0ZSkge1xuICAgICAgZGVsZXRlUHJvbWlzZXMucHVzaChmcy5yaW1yYWYocGF0aC5yZXNvbHZlKGxpYnJhcnlEaXIsIGZpbGUpKSk7XG4gICAgICBkZWxldGVQcm9taXNlcy5wdXNoKGZzLnJpbXJhZihwYXRoLnJlc29sdmUoc2FmYXJpTGlicmFyeURpciwgZmlsZSkpKTtcbiAgICB9XG5cbiAgICBpZiAoIWtlZXBQcmVmcykge1xuICAgICAgZGVsZXRlUHJvbWlzZXMucHVzaChmcy5yaW1yYWYocGF0aC5yZXNvbHZlKHNhZmFyaUxpYnJhcnlEaXIsICdQcmVmZXJlbmNlcy8qLnBsaXN0JykpKTtcbiAgICB9XG5cbiAgICBhd2FpdCBCLmFsbChkZWxldGVQcm9taXNlcyk7XG4gIH1cblxuICAvKipcbiAgICogVW5pbnN0YWxsIHRoZSBnaXZlbiBhcHBsaWNhdGlvbiBmcm9tIHRoZSBjdXJyZW50IFNpbXVsYXRvci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJ1bmRsZUlkIC0gVGhlIGJ1aW5kbGUgSUQgb2YgdGhlIGFwcGxpY2F0aW9uIHRvIGJlIHJlbW92ZWQuXG4gICAqL1xuICBhc3luYyByZW1vdmVBcHAgKGJ1bmRsZUlkKSB7XG4gICAgYXdhaXQgc2ltY3RsLnJlbW92ZUFwcCh0aGlzLnVkaWQsIGJ1bmRsZUlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIGEgYnVpbHQtaW4gYXBwbGljYXRpb24gdG8gYSBuZXcgcGxhY2UgKGFjdHVhbGx5LCByZW5hbWUgaXQpLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXBwTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBhcHAgdG8gYmUgbW92ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcHBQYXRoIC0gVGhlIGN1cnJlbnQgcGF0aCB0byB0aGUgYXBwbGljYXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdBcHBQYXRoIC0gVGhlIG5ldyBwYXRoIHRvIHRoZSBhcHBsaWNhdGlvbi5cbiAgICogICBJZiBzb21lIGFwcGxpY2F0aW9uIGFscmVhZHkgZXhpc3RzIGJ5IHRoaXMgcGF0aCB0aGVuIGl0J3MgZ29pbmcgdG8gYmUgcmVtb3ZlZC5cbiAgICovXG4gIGFzeW5jIG1vdmVCdWlsdEluQXBwIChhcHBOYW1lLCBhcHBQYXRoLCBuZXdBcHBQYXRoKSB7XG4gICAgYXdhaXQgc2FmZVJpbVJhZihuZXdBcHBQYXRoKTtcbiAgICBhd2FpdCBmcy5jb3B5RmlsZShhcHBQYXRoLCBuZXdBcHBQYXRoKTtcbiAgICBsb2cuZGVidWcoYENvcGllZCAnJHthcHBOYW1lfScgdG8gJyR7bmV3QXBwUGF0aH0nYCk7XG5cbiAgICBhd2FpdCBmcy5yaW1yYWYoYXBwUGF0aCk7XG4gICAgbG9nLmRlYnVnKGBUZW1wb3JhcmlseSBkZWxldGVkIG9yaWdpbmFsIGFwcCBhdCAnJHthcHBQYXRofSdgKTtcblxuICAgIHJldHVybiBbbmV3QXBwUGF0aCwgYXBwUGF0aF07XG4gIH1cblxuICAvKipcbiAgICogT3BlbiB0aGUgZ2l2ZW4gVVJMIGluIG1vYmlsZSBTYWZhcmkgYnJvd3Nlci5cbiAgICogVGhlIGJyb3dzZXIgd2lsbCBiZSBzdGFydGVkIGF1dG9tYXRpY2FsbHkgaWYgaXQgaXMgbm90IHJ1bm5pbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIHRvIGJlIG9wZW5lZC5cbiAgICovXG4gIGFzeW5jIG9wZW5VcmwgKHVybCkge1xuICAgIGNvbnN0IFNBRkFSSV9CT09URURfSU5ESUNBVE9SID0gJ01vYmlsZVNhZmFyaVsnO1xuICAgIGNvbnN0IFNBRkFSSV9TVEFSVFVQX1RJTUVPVVQgPSAxNSAqIDEwMDA7XG4gICAgY29uc3QgRVhUUkFfU1RBUlRVUF9USU1FID0gMyAqIDEwMDA7XG5cbiAgICBpZiAoYXdhaXQgdGhpcy5pc1J1bm5pbmcoKSkge1xuICAgICAgYXdhaXQgcmV0cnkoNTAwMCwgc2ltY3RsLm9wZW5VcmwsIHRoaXMudWRpZCwgdXJsKTtcbiAgICAgIGF3YWl0IHRoaXMudGFpbExvZ3NVbnRpbChTQUZBUklfQk9PVEVEX0lORElDQVRPUiwgU0FGQVJJX1NUQVJUVVBfVElNRU9VVCk7XG4gICAgICAvLyBTbyBzb3JyeSwgYnV0IHRoZSBsb2dzIGhhdmUgbm90aGluZyBlbHNlIGZvciBTYWZhcmkgc3RhcnRpbmcuLiBqdXN0IGRlbGF5IGEgbGl0dGxlIGJpdFxuICAgICAgbG9nLmRlYnVnKGBTYWZhcmkgc3RhcnRlZCwgd2FpdGluZyAke0VYVFJBX1NUQVJUVVBfVElNRX1tcyBmb3IgaXQgdG8gZnVsbHkgc3RhcnRgKTtcbiAgICAgIGF3YWl0IEIuZGVsYXkoRVhUUkFfU1RBUlRVUF9USU1FKTtcbiAgICAgIGxvZy5kZWJ1ZygnRG9uZSB3YWl0aW5nIGZvciBTYWZhcmknKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmllZCB0byBvcGVuIGEgdXJsLCBidXQgdGhlIFNpbXVsYXRvciBpcyBub3QgQm9vdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gU2ltdWxhdG9yIGNhY2hlcyBjbGVhbnVwLlxuICAgKlxuICAgKiBAcGFyYW0gey4uLnN0cmluZ30gZm9sZGVyTmFtZXMgLSBUaGUgbmFtZXMgb2YgQ2FjaGVzIHN1YmZvbGRlcnMgdG8gYmUgY2xlYW5lZC5cbiAgICogICBOb24tYWNjZXNzaWJsZS9ub24tZXhpc3Rpbmcgc3ViZm9sZGVycyB3aWxsIGJlIHNraXBwZWQuXG4gICAqICAgQWxsIGV4aXN0aW5nIHN1YmZvbGRlcnMgdW5kZXIgQ2FjaGVzIHdpbGwgYmUgZGVsZXRlZCBpZiB0aGlzIHBhcmFtZXRlciBpcyBvbWl0dGVkLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgY291bnQgb2YgY2xlYW5lZCBjYWNoZSBpdGVtcy5cbiAgICogICBaZXJvIGlzIHJldHVybmVkIGlmIG5vIGl0ZW1zIHdlcmUgbWF0Y2hlZCBmb3IgY2xlYW51cCAoZWl0aGVyIG5vdCBhY2Nlc3NpYmxlIG9yIG5vdCBkaXJlY3RvcmllcykuXG4gICAqL1xuICBhc3luYyBjbGVhckNhY2hlcyAoLi4uZm9sZGVyTmFtZXMpIHtcbiAgICBjb25zdCBjYWNoZXNSb290ID0gcGF0aC5yZXNvbHZlKHRoaXMuZ2V0RGlyKCksICdMaWJyYXJ5JywgJ0NhY2hlcycpO1xuICAgIGlmICghKGF3YWl0IGZzLmhhc0FjY2VzcyhjYWNoZXNSb290KSkpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgQ2FjaGVzIHJvb3QgYXQgJyR7Y2FjaGVzUm9vdH0nIGRvZXMgbm90IGV4aXN0IG9yIGlzIG5vdCBhY2Nlc3NpYmxlLiBOb3RoaW5nIHRvIGRvIHRoZXJlYCk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBsZXQgaXRlbXNUb1JlbW92ZSA9IGZvbGRlck5hbWVzLmxlbmd0aCA/IGZvbGRlck5hbWVzIDogKGF3YWl0IGZzLnJlYWRkaXIoY2FjaGVzUm9vdCkpO1xuICAgIGl0ZW1zVG9SZW1vdmUgPSBpdGVtc1RvUmVtb3ZlLm1hcCgoeCkgPT4gcGF0aC5yZXNvbHZlKGNhY2hlc1Jvb3QsIHgpKTtcbiAgICBpZiAoZm9sZGVyTmFtZXMubGVuZ3RoKSB7XG4gICAgICBpdGVtc1RvUmVtb3ZlID0gYXdhaXQgQi5maWx0ZXIoaXRlbXNUb1JlbW92ZSwgKHgpID0+IGZzLmhhc0FjY2Vzcyh4KSk7XG4gICAgfVxuICAgIGl0ZW1zVG9SZW1vdmUgPSBhd2FpdCBCLmZpbHRlcihpdGVtc1RvUmVtb3ZlLCBhc3luYyAoeCkgPT4gKGF3YWl0IGZzLnN0YXQoeCkpLmlzRGlyZWN0b3J5KCkpO1xuICAgIGlmICghaXRlbXNUb1JlbW92ZS5sZW5ndGgpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgTm8gU2ltdWxhdG9yIGNhY2hlIGl0ZW1zIGZvciBjbGVhbnVwIHdlcmUgbWF0Y2hlZCBpbiAnJHtjYWNoZXNSb290fSdgKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGxvZy5kZWJ1ZyhgTWF0Y2hlZCAke2l0ZW1zVG9SZW1vdmUubGVuZ3RofSBTaW11bGF0b3IgY2FjaGUgYCArXG4gICAgICBgaXRlbSR7aXRlbXNUb1JlbW92ZS5sZW5ndGggPT09IDEgPyAnJyA6ICdzJ30gZm9yIGNsZWFudXA6ICR7aXRlbXNUb1JlbW92ZX1gKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgQi5hbGwoaXRlbXNUb1JlbW92ZSwgKHgpID0+IGZzLnJpbXJhZih4KSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nLndhcm4oYEdvdCBhbiBleGNlcHRpb24gd2hpbGUgY2xlYW5pbmcgU2ltdWxhdG9yIGNhY2hlczogJHtlLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtc1RvUmVtb3ZlLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCbG9ja3MgdW50aWwgdGhlIGdpdmVuIGluZGljYXRlciBzdHJpbmcgYXBwZWFycyBpbiBTaW11bGF0b3IgbG9ncy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJvb3RlZEluZGljYXRvciAtIFRoZSBtYWdpYyBzdHJpbmcsIHdoaWNoIGFwcGVhcnMgaW4gbG9ncyBhZnRlciBTaW11bGF0b3IgYm9vdGluZyBpcyBjb21wbGV0ZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TXMgLSBUaGUgbWF4aW11bW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciB0aGUgc3RyaW5nIGluZGljYXRvciBwcmVzZW5jZS5cbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGlvcyBzaW11bGF0b3IgbG9ncyBvdXRwdXQgYSBsaW5lIG1hdGNoaW5nIGBib290ZWRJbmRpY2F0b3JgXG4gICAqIHRpbWVzIG91dCBhZnRlciB0aW1lb3V0TXNcbiAgICovXG4gIGFzeW5jIHRhaWxMb2dzVW50aWwgKGJvb3RlZEluZGljYXRvciwgdGltZW91dE1zKSB7XG4gICAgbGV0IHNpbUxvZyA9IHBhdGgucmVzb2x2ZSh0aGlzLmdldExvZ0RpcigpLCAnc3lzdGVtLmxvZycpO1xuXG4gICAgLy8gd2UgbmVlZCB0byBtYWtlIHN1cmUgbG9nIGZpbGUgZXhpc3RzIGJlZm9yZSB3ZSBjYW4gdGFpbCBpdFxuICAgIGF3YWl0IHJldHJ5SW50ZXJ2YWwoMjAwLCAyMDAsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBleGlzdHMgPSBhd2FpdCBmcy5leGlzdHMoc2ltTG9nKTtcbiAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgU2ltdWxhdG9yIGxvZzogJyR7c2ltTG9nfSdgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGxvZy5pbmZvKGBTaW11bGF0b3IgbG9nIGF0ICcke3NpbUxvZ30nYCk7XG4gICAgbG9nLmluZm8oYFRhaWxpbmcgc2ltdWxhdG9yIGxvZ3MgdW50aWwgd2UgZW5jb3VudGVyIHRoZSBzdHJpbmcgXCIke2Jvb3RlZEluZGljYXRvcn1cImApO1xuICAgIGxvZy5pbmZvKGBXZSB3aWxsIHRpbWUgb3V0IGFmdGVyICR7dGltZW91dE1zfW1zYCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRhaWxVbnRpbChzaW1Mb2csIGJvb3RlZEluZGljYXRvciwgdGltZW91dE1zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy5kZWJ1ZygnU2ltdWxhdG9yIHN0YXJ0dXAgdGltZWQgb3V0LiBDb250aW51aW5nIGFueXdheS4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlIENhbGVuZGFyIGFjY2VzcyBmb3IgdGhlIGdpdmVuIGFwcGxpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYnVuZGxlSUQgLSBCdW5kbGUgSUQgb2YgdGhlIGFwcGxpY2F0aW9uLCBmb3Igd2hpY2ggdGhlIGFjY2VzcyBzaG91bGQgYmUgZ3JhbnRlZC5cbiAgICovXG4gIGFzeW5jIGVuYWJsZUNhbGVuZGFyQWNjZXNzIChidW5kbGVJRCkge1xuICAgIGF3YWl0IHRoaXMuY2FsZW5kYXIuZW5hYmxlQ2FsZW5kYXJBY2Nlc3MoYnVuZGxlSUQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGUgQ2FsZW5kYXIgYWNjZXNzIGZvciB0aGUgZ2l2ZW4gYXBwbGljYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBidW5kbGVJRCAtIEJ1bmRsZSBJRCBvZiB0aGUgYXBwbGljYXRpb24sIGZvciB3aGljaCB0aGUgYWNjZXNzIHNob3VsZCBiZSBkZW5pZWQuXG4gICAqL1xuICBhc3luYyBkaXNhYmxlQ2FsZW5kYXJBY2Nlc3MgKGJ1bmRsZUlEKSB7XG4gICAgYXdhaXQgdGhpcy5jYWxlbmRhci5kaXNhYmxlQ2FsZW5kYXJBY2Nlc3MoYnVuZGxlSUQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIGFwcGxpY2F0aW9uIGhhcyBhY2Nlc3MgdG8gQ2FsZW5kYXIuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdpdmVuIGFwcGxpY2F0aW9uIGhhcyB0aGUgYWNjZXNzLlxuICAgKi9cbiAgYXN5bmMgaGFzQ2FsZW5kYXJBY2Nlc3MgKGJ1bmRsZUlEKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY2FsZW5kYXIuaGFzQ2FsZW5kYXJBY2Nlc3MoYnVuZGxlSUQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIEFwcGxlIHNjcmlwdCwgd2hpY2ggYWN0aXZhdGVzIFNpbXVsYXRvci5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gdGhlIGdlbmVyYXRlZCBBcHBsZSBTY3JpcHQgc25pcHBldC5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlV2luZG93QWN0aXZhdGlvblNjcmlwdCAoKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIHRlbGwgYXBwbGljYXRpb24gXCJTeXN0ZW0gRXZlbnRzXCJcbiAgICAgICAgdGVsbCBwcm9jZXNzIFwiU2ltdWxhdG9yXCJcbiAgICAgICAgICBzZXQgZnJvbnRtb3N0IHRvIGZhbHNlXG4gICAgICAgICAgc2V0IGZyb250bW9zdCB0byB0cnVlXG4gICAgICAgIGVuZCB0ZWxsXG4gICAgICBlbmQgdGVsbFxuICAgIGA7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBnaXZlbiBBcHBsZSBTY3JpcHQgaW5zaWRlIGEgY3JpdGljYWwgc2VjdGlvbiwgc28gb3RoZXJcbiAgICogc2Vzc2lvbnMgY2Fubm90IGluZmx1ZW5jZSB0aGUgVUkgY2xpZW50IGF0IHRoZSBzYW1lIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcHBsZVNjcmlwdCAtIFRoZSB2YWxpZCBBcHBsZSBTY3JpcHQgc25pcHBldCB0byBiZSBleGVjdXRlZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3Rkb3V0IG91dHB1dCBwcm9kdWNlZCBieSB0aGUgc2NyaXB0LlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgb3Nhc2NyaXB0IHRvb2wgcmV0dXJucyBub24temVybyBleGl0IGNvZGUuXG4gICAqL1xuICBhc3luYyBleGVjdXRlVUlDbGllbnRTY3JpcHQgKGFwcGxlU2NyaXB0KSB7XG4gICAgY29uc3Qgd2luZG93QWN0aXZhdGlvblNjcmlwdCA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVXaW5kb3dBY3RpdmF0aW9uU2NyaXB0KCk7XG4gICAgY29uc3QgcmVzdWx0U2NyaXB0ID0gYCR7d2luZG93QWN0aXZhdGlvblNjcmlwdH1cXG4ke2FwcGxlU2NyaXB0fWA7XG4gICAgbG9nLmRlYnVnKGBFeGVjdXRpbmcgVUkgQXBwbGUgU2NyaXB0IG9uIFNpbXVsYXRvciB3aXRoIFVESUQgJHt0aGlzLnVkaWR9OiAke3Jlc3VsdFNjcmlwdH1gKTtcbiAgICByZXR1cm4gYXdhaXQgVUlfQ0xJRU5UX0FDQ0VTU19HVUFSRC5hY3F1aXJlKHRoaXMuc2ltdWxhdG9yQXBwLCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ29zYXNjcmlwdCcsIFsnLWUnLCByZXN1bHRTY3JpcHRdKTtcbiAgICAgICAgcmV0dXJuIHN0ZG91dDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cuZXJyb3JBbmRUaHJvdyhgQ291bGQgbm90IGNvbXBsZXRlIG9wZXJhdGlvbi4gTWFrZSBzdXJlIFNpbXVsYXRvciBVSSBpcyBydW5uaW5nIGFuZCB0aGUgcGFyZW50IEFwcGl1bSBhcHBsaWNhdGlvbiAoZS4gZy4gQXBwaXVtLmFwcCBvciBUZXJtaW5hbC5hcHApIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBgaXMgcHJlc2VudCBpbiBTeXN0ZW0gUHJlZmVyZW5jZXMgPiBTZWN1cml0eSAmIFByaXZhY3kgPiBQcml2YWN5ID4gQWNjZXNzaWJpbGl0eSBsaXN0LiBJZiB0aGUgb3BlcmF0aW9uIGlzIHN0aWxsIHVuc3VjY2Vzc2Z1bCB0aGVuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBgaXQgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIFNpbXVsYXRvci4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgVG91Y2ggSUQgRW5yb2xsbWVudCBmZWF0dXJlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIFRvdWNoIElEIEVucm9sbG1lbnQgbWVudSBpdGVtIGlzIGNoZWNrZWQgaW4gU2ltdWxhdG9yIG1lbnVcbiAgICovXG4gIGFzeW5jIGlzQmlvbWV0cmljRW5yb2xsZWQgKCkge1xuICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHRoaXMuZXhlY3V0ZVVJQ2xpZW50U2NyaXB0KGBcbiAgICAgIHRlbGwgYXBwbGljYXRpb24gXCJTeXN0ZW0gRXZlbnRzXCJcbiAgICAgICAgdGVsbCBwcm9jZXNzIFwiU2ltdWxhdG9yXCJcbiAgICAgICAgICBzZXQgZHN0TWVudUl0ZW0gdG8gbWVudSBpdGVtIFwiVG9nZ2xlIEVucm9sbGVkIFN0YXRlXCIgb2YgbWVudSAxIG9mIG1lbnUgaXRlbSBcIlRvdWNoIElEXCIgb2YgbWVudSAxIG9mIG1lbnUgYmFyIGl0ZW0gXCJIYXJkd2FyZVwiIG9mIG1lbnUgYmFyIDFcbiAgICAgICAgICBzZXQgaXNDaGVja2VkIHRvICh2YWx1ZSBvZiBhdHRyaWJ1dGUgXCJBWE1lbnVJdGVtTWFya0NoYXJcIiBvZiBkc3RNZW51SXRlbSkgaXMgXCLinJNcIlxuICAgICAgICBlbmQgdGVsbFxuICAgICAgZW5kIHRlbGxcbiAgICBgKTtcbiAgICBsb2cuZGVidWcoYFRvdWNoIElEIGVucm9sbGVkIHN0YXRlOiAke291dHB1dH1gKTtcbiAgICByZXR1cm4gXy5pc1N0cmluZyhvdXRwdXQpICYmIG91dHB1dC50cmltKCkgPT09ICd0cnVlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgc3BlY2lhbCBBcHBsZSBzY3JpcHQsIHdoaWNoIGNoYW5nZXMgVG91Y2ggSUQgZmVhdHVyZSB0ZXN0aW5nIGluIFNpbXVsYXRvciBVSSBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFbmFibGVkIC0gU2V0IGl0IHRvIGZhbHNlIGluIG9yZGVyIHRvIHVuY2hlY2sgJ1RvZ2dsZSBFbnJvbGxlZCBTdGF0ZScgZmxhZ1xuICAgKi9cbiAgYXN5bmMgZW5yb2xsQmlvbWV0cmljIChpc0VuYWJsZWQgPSB0cnVlKSB7XG4gICAgYXdhaXQgdGhpcy5leGVjdXRlVUlDbGllbnRTY3JpcHQoYFxuICAgICAgdGVsbCBhcHBsaWNhdGlvbiBcIlN5c3RlbSBFdmVudHNcIlxuICAgICAgICB0ZWxsIHByb2Nlc3MgXCJTaW11bGF0b3JcIlxuICAgICAgICAgIHNldCBkc3RNZW51SXRlbSB0byBtZW51IGl0ZW0gXCJUb2dnbGUgRW5yb2xsZWQgU3RhdGVcIiBvZiBtZW51IDEgb2YgbWVudSBpdGVtIFwiVG91Y2ggSURcIiBvZiBtZW51IDEgb2YgbWVudSBiYXIgaXRlbSBcIkhhcmR3YXJlXCIgb2YgbWVudSBiYXIgMVxuICAgICAgICAgIHNldCBpc0NoZWNrZWQgdG8gKHZhbHVlIG9mIGF0dHJpYnV0ZSBcIkFYTWVudUl0ZW1NYXJrQ2hhclwiIG9mIGRzdE1lbnVJdGVtKSBpcyBcIuKck1wiXG4gICAgICAgICAgaWYgJHtpc0VuYWJsZWQgPyAnbm90ICcgOiAnJ31pc0NoZWNrZWQgdGhlblxuICAgICAgICAgICAgY2xpY2sgZHN0TWVudUl0ZW1cbiAgICAgICAgICBlbmQgaWZcbiAgICAgICAgZW5kIHRlbGxcbiAgICAgIGVuZCB0ZWxsXG4gICAgYCk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIHNwZWNpYWwgQXBwbGUgc2NyaXB0LCB3aGljaCBjbGlja3MgdGhlIHBhcnRpY3VsYXIgYnV0dG9uIG9uIERhdGFiYXNlIGFsZXJ0LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluY3JlYXNlIC0gQ2xpY2sgdGhlIGJ1dHRvbiB3aXRoICdJbmNyZWFzZScgdGl0bGUgb24gdGhlIGFsZXJ0IGlmIHRoaXNcbiAgICogICBwYXJhbWV0ZXIgaXMgdHJ1ZS4gVGhlICdDYW5jZWwnIGJ1dHRvbiB3aWxsIGJlIGNsaWNrZWQgb3RoZXJ3aXNlLlxuICAgKi9cbiAgYXN5bmMgZGlzbWlzc0RhdGFiYXNlQWxlcnQgKGluY3JlYXNlID0gdHJ1ZSkge1xuICAgIGxldCBidXR0b24gPSBpbmNyZWFzZSA/ICdJbmNyZWFzZScgOiAnQ2FuY2VsJztcbiAgICBsb2cuZGVidWcoYEF0dGVtcHRpbmcgdG8gZGlzbWlzcyBkYXRhYmFzZSBhbGVydCB3aXRoICcke2J1dHRvbn0nIGJ1dHRvbmApO1xuICAgIGF3YWl0IHRoaXMuZXhlY3V0ZVVJQ2xpZW50U2NyaXB0KGBcbiAgICAgIHRlbGwgYXBwbGljYXRpb24gXCJTeXN0ZW0gRXZlbnRzXCJcbiAgICAgICAgdGVsbCBwcm9jZXNzIFwiU2ltdWxhdG9yXCJcbiAgICAgICAgICBjbGljayBidXR0b24gXCIke2J1dHRvbn1cIiBvZiB3aW5kb3cgMVxuICAgICAgICBlbmQgdGVsbFxuICAgICAgZW5kIHRlbGxcbiAgICBgKTtcbiAgfVxuXG4gIC8vcmVnaW9uIEtleWNoYWlucyBJbnRlcmFjdGlvblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBiYWNrdXAgb2Yga2V5Y2hhaW5zIGZvbGRlci5cbiAgICogVGhlIHByZXZpb3VzbHkgY3JlYXRlZCBiYWNrdXAgd2lsbCBiZSBhdXRvbWF0aWNhbGx5XG4gICAqIGRlbGV0ZWQgaWYgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZCB0d2ljZSBpbiBhIHJvdyB3aXRob3V0XG4gICAqIGByZXN0b3JlS2V5Y2hhaW5zYCBiZWluZyBpbnZva2VkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYmFja3VwIG9wZXJhdGlvbiB3YXMgc3VjY2Vzc2Z1bGwuXG4gICAqL1xuICBhc3luYyBiYWNrdXBLZXljaGFpbnMgKCkge1xuICAgIGlmICghYXdhaXQgZnMuZXhpc3RzKHRoaXMua2V5Y2hhaW5QYXRoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGJhY2t1cFBhdGggPSBhd2FpdCB0ZW1wRGlyLnBhdGgoe1xuICAgICAgcHJlZml4OiBga2V5Y2hhaW5zX2JhY2t1cF8ke01hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSl9YCxcbiAgICAgIHN1ZmZpeDogJy56aXAnLFxuICAgIH0pO1xuICAgIGNvbnN0IHppcEFyZ3MgPSBbXG4gICAgICAnLXInLCBiYWNrdXBQYXRoLFxuICAgICAgYCR7dGhpcy5rZXljaGFpblBhdGh9JHtwYXRoLnNlcH1gXG4gICAgXTtcbiAgICBsb2cuZGVidWcoYENyZWF0aW5nIGtleWNoYWlucyBiYWNrdXAgd2l0aCAnemlwICR7emlwQXJncy5qb2luKCcgJyl9JyBjb21tYW5kYCk7XG4gICAgYXdhaXQgZXhlYygnemlwJywgemlwQXJncyk7XG4gICAgaWYgKF8uaXNTdHJpbmcodGhpcy5fa2V5Y2hhaW5zQmFja3VwUGF0aCkgJiYgYXdhaXQgZnMuZXhpc3RzKHRoaXMuX2tleWNoYWluc0JhY2t1cFBhdGgpKSB7XG4gICAgICBhd2FpdCBmcy51bmxpbmsodGhpcy5fa2V5Y2hhaW5zQmFja3VwUGF0aCk7XG4gICAgfVxuICAgIHRoaXMuX2tleWNoYWluc0JhY2t1cFBhdGggPSBiYWNrdXBQYXRoO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3RvcmUgdGhlIHByZXZpc291bHkgY3JlYXRlZCBrZXljaGFpbnMgYmFja3VwLlxuICAgKlxuICAgKiBAcGFyYW0gez9zdHJpbmd8QXJyYXk8c3RyaW5nPn0gZXhjbHVkZVBhdHRlcm5zIC0gVGhlIGxpc3RcbiAgICogb2YgZmlsZSBuYW1lIHBhdHRlcm5zIHRvIGJlIGV4Y2x1ZGVkIGZyb20gcmVzdG9yZS4gVGhlIGZvcm1hdFxuICAgKiBvZiBlYWNoIGl0ZW0gc2hvdWxkIGJlIHRoZSBzYW1lIGFzICcteCcgb3B0aW9uIGZvcm1hdCBmb3JcbiAgICogJ3VuemlwJyB1dGlsaXR5LiBUaGlzIGNhbiBhbHNvIGJlIGEgY29tbWEtc2VwYXJhdGVkIHN0cmluZyxcbiAgICogd2hpY2ggaXMgZ29pbmcgYmUgdHJhbnNmb3JtZWQgaW50byBhIGxpc3QgYXV0b21hdGljYWxseSxcbiAgICogZm9yIGV4YW1wbGU6ICcqLmRiKixibGFibGEuc3FsaXRlJ1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgdGhlIHJlc3RvcmUgb3ByYXRpb24gd2FzIHN1Y2Nlc3NmdWwuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBubyBrZXljaGFpbnMgYmFja3VwIGF2YWlsYWJsZSBmb3IgcmVzdG9yZS5cbiAgICovXG4gIGFzeW5jIHJlc3RvcmVLZXljaGFpbnMgKGV4Y2x1ZGVQYXR0ZXJucyA9IFtdKSB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHRoaXMuX2tleWNoYWluc0JhY2t1cFBhdGgpIHx8ICFhd2FpdCBmcy5leGlzdHModGhpcy5fa2V5Y2hhaW5zQmFja3VwUGF0aCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGtleWNoYWlucyBiYWNrdXAgYXJjaGl2ZSBkb2VzIG5vdCBleGlzdC4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgYEFyZSB5b3Ugc3VyZSBpdCB3YXMgY3JlYXRlZCBiZWZvcmU/YCk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNTdHJpbmcoZXhjbHVkZVBhdHRlcm5zKSkge1xuICAgICAgZXhjbHVkZVBhdHRlcm5zID0gZXhjbHVkZVBhdHRlcm5zLnNwbGl0KCcsJykubWFwKCh4KSA9PiB4LnRyaW0oKSk7XG4gICAgfVxuICAgIGF3YWl0IGZzLnJpbXJhZih0aGlzLmtleWNoYWluUGF0aCk7XG4gICAgYXdhaXQgbWtkaXJwKHRoaXMua2V5Y2hhaW5QYXRoKTtcbiAgICBjb25zdCB1bnppcEFyZ3MgPSBbXG4gICAgICAnLW8nLCB0aGlzLl9rZXljaGFpbnNCYWNrdXBQYXRoLFxuICAgICAgLi4uKF8uZmxhdE1hcChleGNsdWRlUGF0dGVybnMubWFwKCh4KSA9PiBbJy14JywgeF0pKSksXG4gICAgICAnLWQnLCAnLydcbiAgICBdO1xuICAgIGxvZy5kZWJ1ZyhgUmVzdG9yaW5nIGtleWNoYWlucyB3aXRoICd1bnppcCAke3VuemlwQXJncy5qb2luKCcgJyl9JyBjb21tYW5kYCk7XG4gICAgYXdhaXQgZXhlYygndW56aXAnLCB1bnppcEFyZ3MpO1xuICAgIGF3YWl0IGZzLnVubGluayh0aGlzLl9rZXljaGFpbnNCYWNrdXBQYXRoKTtcbiAgICB0aGlzLl9rZXljaGFpbnNCYWNrdXBQYXRoID0gbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvL2VuZHJlZ2lvblxuXG4gIHN0YXRpYyBhc3luYyBfZ2V0RGV2aWNlU3RyaW5nUGxhdGZvcm1WZXJzaW9uIChwbGF0Zm9ybVZlcnNpb24pIHtcbiAgICBsZXQgcmVxVmVyc2lvbiA9IHBsYXRmb3JtVmVyc2lvbjtcbiAgICBpZiAoIXJlcVZlcnNpb24pIHtcbiAgICAgIHJlcVZlcnNpb24gPSBhd2FpdCB4Y29kZS5nZXRNYXhJT1NTREsoKTtcbiAgICAgIGxvZy53YXJuKGBObyBwbGF0Zm9ybSB2ZXJzaW9uIHNldC4gVXNpbmcgbWF4IFNESyB2ZXJzaW9uOiAke3JlcVZlcnNpb259YCk7XG4gICAgICAvLyB0aGlzIHdpbGwgYmUgYSBudW1iZXIsIGFuZCBwb3NzaWJseSBhbiBpbnRlZ2VyIChlLmcuLCBpZiBtYXggaU9TIFNESyBpcyA5KVxuICAgICAgLy8gc28gdHVybiBpdCBpbnRvIGEgc3RyaW5nIGFuZCBhZGQgYSAuMCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmICghXy5pc1N0cmluZyhyZXFWZXJzaW9uKSkge1xuICAgICAgICByZXFWZXJzaW9uID0gKHJlcVZlcnNpb24gJSAxKSA/IFN0cmluZyhyZXFWZXJzaW9uKSA6IGAke3JlcVZlcnNpb259LjBgO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVxVmVyc2lvbjtcbiAgfVxuXG4gIC8vIGNoYW5nZSB0aGUgZm9ybWF0IGluIHN1YmNsYXNzZXMsIGFzIG5lY2Vzc2FyeVxuICBzdGF0aWMgYXN5bmMgX2dldERldmljZVN0cmluZ1ZlcnNpb25TdHJpbmcgKHBsYXRmb3JtVmVyc2lvbikge1xuICAgIGxldCByZXFWZXJzaW9uID0gYXdhaXQgdGhpcy5fZ2V0RGV2aWNlU3RyaW5nUGxhdGZvcm1WZXJzaW9uKHBsYXRmb3JtVmVyc2lvbik7XG5cbiAgICByZXR1cm4gYCgke3JlcVZlcnNpb259IFNpbXVsYXRvcilgO1xuICB9XG5cbiAgLy8gY2hhbmdlIHRoZSBmb3JtYXQgaW4gc3ViY2xhc3NlcywgYXMgbmVjZXNzYXJ5XG4gIHN0YXRpYyBfZ2V0RGV2aWNlU3RyaW5nQ29uZmlnRml4ICgpIHtcbiAgICAvLyBzb21lIGRldmljZXMgbmVlZCB0byBiZSB1cGRhdGVkXG4gICAgcmV0dXJuIHtcbiAgICAgICdpUGFkIFNpbXVsYXRvciAoNy4xIFNpbXVsYXRvciknOiAnaVBhZCAyICg3LjEgU2ltdWxhdG9yKScsXG4gICAgICAnaVBhZCBTaW11bGF0b3IgKDguMCBTaW11bGF0b3IpJzogJ2lQYWQgMiAoOC4wIFNpbXVsYXRvciknLFxuICAgICAgJ2lQYWQgU2ltdWxhdG9yICg4LjEgU2ltdWxhdG9yKSc6ICdpUGFkIDIgKDguMSBTaW11bGF0b3IpJyxcbiAgICAgICdpUGFkIFNpbXVsYXRvciAoOC4yIFNpbXVsYXRvciknOiAnaVBhZCAyICg4LjIgU2ltdWxhdG9yKScsXG4gICAgICAnaVBhZCBTaW11bGF0b3IgKDguMyBTaW11bGF0b3IpJzogJ2lQYWQgMiAoOC4zIFNpbXVsYXRvciknLFxuICAgICAgJ2lQYWQgU2ltdWxhdG9yICg4LjQgU2ltdWxhdG9yKSc6ICdpUGFkIDIgKDguNCBTaW11bGF0b3IpJyxcbiAgICAgICdpUGhvbmUgU2ltdWxhdG9yICg3LjEgU2ltdWxhdG9yKSc6ICdpUGhvbmUgNXMgKDcuMSBTaW11bGF0b3IpJyxcbiAgICAgICdpUGhvbmUgU2ltdWxhdG9yICg4LjQgU2ltdWxhdG9yKSc6ICdpUGhvbmUgNiAoOC40IFNpbXVsYXRvciknLFxuICAgICAgJ2lQaG9uZSBTaW11bGF0b3IgKDguMyBTaW11bGF0b3IpJzogJ2lQaG9uZSA2ICg4LjMgU2ltdWxhdG9yKScsXG4gICAgICAnaVBob25lIFNpbXVsYXRvciAoOC4yIFNpbXVsYXRvciknOiAnaVBob25lIDYgKDguMiBTaW11bGF0b3IpJyxcbiAgICAgICdpUGhvbmUgU2ltdWxhdG9yICg4LjEgU2ltdWxhdG9yKSc6ICdpUGhvbmUgNiAoOC4xIFNpbXVsYXRvciknLFxuICAgICAgJ2lQaG9uZSBTaW11bGF0b3IgKDguMCBTaW11bGF0b3IpJzogJ2lQaG9uZSA2ICg4LjAgU2ltdWxhdG9yKSdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIGEgc2V0IG9mIG9wdGlvbnMgYW5kIGZpbmRzIHRoZSBjb3JyZWN0IGRldmljZSBzdHJpbmcgaW4gb3JkZXIgZm9yIEluc3RydW1lbnRzIHRvXG4gICAqIGlkZW50aWZ5IHRoZSBjb3JyZWN0IHNpbXVsYXRvci5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBUaGUgb3B0aW9ucyBhdmFpbGFibGUgYXJlOlxuICAgKiAgIC0gYGRldmljZU5hbWVgIC0gYSBuYW1lIGZvciB0aGUgZGV2aWNlLiBJZiB0aGUgZ2l2ZW4gZGV2aWNlIG5hbWUgc3RhcnRzIHdpdGggYD1gLCB0aGUgbmFtZSwgbGVzcyB0aGUgZXF1YWxzIHNpZ24sIGlzIHJldHVybmVkLlxuICAgKiAgIC0gYHBsYXRmb3JtVmVyc2lvbmAgLSB0aGUgdmVyc2lvbiBvZiBpT1MgdG8gdXNlLiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBYY29kZSdzIG1heGltdW0gU0RLIHZlcnNpb24uXG4gICAqICAgLSBgZm9yY2VJcGhvbmVgIC0gZm9yY2UgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGRldmljZSBzdHJpbmcgdG8gaVBob25lLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgKiAgIC0gYGZvcmNlSXBhZGAgLSBmb3JjZSB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgZGV2aWNlIHN0cmluZyB0byBpUGFkLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgKiAgIElmIGJvdGggYGZvcmNlSXBob25lYCBhbmQgYGZvcmNlSXBhZGAgYXJlIHRydWUsIHRoZSBkZXZpY2Ugd2lsbCBiZSBmb3JjZWQgdG8gaVBob25lLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBmb3VuZCBkZXZpY2Ugc3RyaW5nLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGdldERldmljZVN0cmluZyAob3B0cykge1xuICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICBkZXZpY2VOYW1lOiBudWxsLFxuICAgICAgcGxhdGZvcm1WZXJzaW9uOiBudWxsLFxuICAgICAgZm9yY2VJcGhvbmU6IGZhbHNlLFxuICAgICAgZm9yY2VJcGFkOiBmYWxzZVxuICAgIH0sIG9wdHMpO1xuICAgIGxldCBsb2dPcHRzID0ge1xuICAgICAgZGV2aWNlTmFtZTogb3B0cy5kZXZpY2VOYW1lLFxuICAgICAgcGxhdGZvcm1WZXJzaW9uOiBvcHRzLnBsYXRmb3JtVmVyc2lvbixcbiAgICAgIGZvcmNlSXBob25lOiBvcHRzLmZvcmNlSXBob25lLFxuICAgICAgZm9yY2VJcGFkOiBvcHRzLmZvcmNlSXBhZFxuICAgIH07XG4gICAgbG9nLmRlYnVnKGBHZXR0aW5nIGRldmljZSBzdHJpbmcgZnJvbSBvcHRpb25zOiAke0pTT04uc3RyaW5naWZ5KGxvZ09wdHMpfWApO1xuXG4gICAgLy8gc2hvcnQgY2lyY3VpdCBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBkZXZpY2UgbmFtZVxuICAgIGlmICgob3B0cy5kZXZpY2VOYW1lIHx8ICcnKVswXSA9PT0gJz0nKSB7XG4gICAgICByZXR1cm4gb3B0cy5kZXZpY2VOYW1lLnN1YnN0cmluZygxKTtcbiAgICB9XG5cbiAgICBsZXQgaXNpUGhvbmUgPSAhIW9wdHMuZm9yY2VJcGhvbmUgfHwgIW9wdHMuZm9yY2VJcGFkO1xuXG4gICAgaWYgKG9wdHMuZGV2aWNlTmFtZSkge1xuICAgICAgbGV0IGRldmljZSA9IG9wdHMuZGV2aWNlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGRldmljZS5pbmRleE9mKCdpcGhvbmUnKSAhPT0gLTEpIHtcbiAgICAgICAgaXNpUGhvbmUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkZXZpY2UuaW5kZXhPZignaXBhZCcpICE9PSAtMSkge1xuICAgICAgICBpc2lQaG9uZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBpb3NEZXZpY2VTdHJpbmcgPSBvcHRzLmRldmljZU5hbWUgfHwgKGlzaVBob25lID8gJ2lQaG9uZSBTaW11bGF0b3InIDogJ2lQYWQgU2ltdWxhdG9yJyk7XG5cbiAgICAvLyBpZiBzb21lb25lIHBhc3NlcyBpbiBqdXN0IFwiaVBob25lXCIsIG1ha2UgdGhhdCBcImlQaG9uZSBTaW11bGF0b3JcIiB0b1xuICAgIC8vIGNvbmZvcm0gdG8gYWxsIHRoZSBsb2dpYyBiZWxvd1xuICAgIGlmICgvXihpUGhvbmV8aVBhZCkkLy50ZXN0KGlvc0RldmljZVN0cmluZykpIHtcbiAgICAgIGlvc0RldmljZVN0cmluZyArPSBcIiBTaW11bGF0b3JcIjtcbiAgICB9XG5cbiAgICAvLyB3ZSBzdXBwb3J0IGRldmljZU5hbWU6IFwiaVBob25lIFNpbXVsYXRvclwiLCBhbmQgYWxzbyB3YW50IHRvIHN1cHBvcnRcbiAgICAvLyBcImlQaG9uZSBYWVogU2ltdWxhdG9yXCIsIGJ1dCB0aGVzZSBzdHJpbmdzIGFyZW4ndCBpbiB0aGUgZGV2aWNlIGxpc3QuXG4gICAgLy8gU28sIGlmIHNvbWVvbmUgc2VudCBpbiBcImlQaG9uZSBYWVogU2ltdWxhdG9yXCIsIHN0cmlwIG9mZiBcIiBTaW11bGF0b3JcIlxuICAgIC8vIGluIG9yZGVyIHRvIGFsbG93IHRoZSBkZWZhdWx0IFwiaVBob25lIFhZWlwiIG1hdGNoXG4gICAgaWYgKC9bXihpUGhvbmV8aVBhZCldIFNpbXVsYXRvci8udGVzdChpb3NEZXZpY2VTdHJpbmcpKSB7XG4gICAgICBpb3NEZXZpY2VTdHJpbmcgPSBpb3NEZXZpY2VTdHJpbmcucmVwbGFjZShcIiBTaW11bGF0b3JcIiwgXCJcIik7XG4gICAgfVxuICAgIGlvc0RldmljZVN0cmluZyArPSBgICR7YXdhaXQgdGhpcy5fZ2V0RGV2aWNlU3RyaW5nVmVyc2lvblN0cmluZyhvcHRzLnBsYXRmb3JtVmVyc2lvbil9YDtcblxuICAgIGxldCBDT05GSUdfRklYID0gdGhpcy5fZ2V0RGV2aWNlU3RyaW5nQ29uZmlnRml4KCk7XG5cbiAgICBsZXQgY29uZmlnRml4ID0gQ09ORklHX0ZJWDtcbiAgICBpZiAoY29uZmlnRml4W2lvc0RldmljZVN0cmluZ10pIHtcbiAgICAgIGlvc0RldmljZVN0cmluZyA9IGNvbmZpZ0ZpeFtpb3NEZXZpY2VTdHJpbmddO1xuICAgICAgbG9nLmRlYnVnKGBGaXhpbmcgZGV2aWNlLiBDaGFuZ2VkIGZyb20gJyR7b3B0cy5kZXZpY2VOYW1lfScgYCtcbiAgICAgICAgICAgICAgICAgICBgdG8gJyR7aW9zRGV2aWNlU3RyaW5nfSdgKTtcbiAgICB9XG5cbiAgICBsb2cuZGVidWcoYEZpbmFsIGRldmljZSBzdHJpbmcgaXMgJyR7aW9zRGV2aWNlU3RyaW5nfSdgKTtcbiAgICByZXR1cm4gaW9zRGV2aWNlU3RyaW5nO1xuICB9XG5cbiAgLypcbiAgICogQHJldHVybiB7P3N0cmluZ30gVGhlIGZ1bGwgcGF0aCB0byB0aGUgc2ltdWxhdG9yJ3MgV2ViSW5zcGVjdG9yIFVuaXggRG9tYWluIFNvY2tldFxuICAgKiAgIG9yIGBudWxsYCBpZiB0aGVyZSBpcyBubyBzb2NrZXQuXG4gICAqL1xuICBhc3luYyBnZXRXZWJJbnNwZWN0b3JTb2NrZXQgKCkge1xuICAgIC8vIHRoZXJlIGlzIG5vIFdlYkluc3BlY3RvciBzb2NrZXQgZm9yIHRoaXMgdmVyc2lvbiBvZiBYY29kZVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZvciAobGV0IFtjbWQsIGZuXSBvZiBfLnRvUGFpcnMoZXh0ZW5zaW9ucykpIHtcbiAgU2ltdWxhdG9yWGNvZGU2LnByb3RvdHlwZVtjbWRdID0gZm47XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNpbXVsYXRvclhjb2RlNjtcbmV4cG9ydCB7IFNpbXVsYXRvclhjb2RlNiwgQk9PVF9DT01QTEVURURfRVZFTlQgfTtcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
