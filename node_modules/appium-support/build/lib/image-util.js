'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _jimp = require('jimp');

var _jimp2 = _interopRequireDefault(_jimp);

var _buffer = require('buffer');

var _pngjs = require('pngjs');

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _util = require('./util');

var MIME_JPEG = _jimp2['default'].MIME_JPEG;
var MIME_PNG = _jimp2['default'].MIME_PNG;
var MIME_BMP = _jimp2['default'].MIME_BMP;

var cv = null;

/**
 * @typedef {Object} Region
 * @property {number} left - The offset from the left side
 * @property {number} top - The offset from the top
 * @property {number} width - The width
 * @property {number} height - The height
 */

/**
 * @typedef {Object} Point
 * @property {number} x - The x coordinate
 * @property {number} y - The y coordinate
 */

/**
* @typedef {Object} Rect
* @property {number} x - The top left coordinate
* @property {number} y - The bottom right coordinate
* @property {number} width - The width
* @property {number} height - The height
*/

var BYTES_IN_PIXEL_BLOCK = 4;
var SCANLINE_FILTER_METHOD = 4;
var DEFAULT_MATCH_THRESHOLD = 0.5;

var AVAILABLE_DETECTORS = ['AKAZE', 'AGAST', 'BRISK', 'FAST', 'GFTT', 'KAZE', 'MSER', 'SIFT', 'ORB'];

var AVAILABLE_MATCHING_FUNCTIONS = ['FlannBased', 'BruteForce', 'BruteForceL1', 'BruteForceHamming', 'BruteForceHammingLut', 'BruteForceSL2'];

/**
 * Utility function to get a Jimp image object from buffer or base64 data. Jimp
 * is a great library however it does IO in the constructor so it's not
 * convenient for our async/await model.
 *
 * @param {Buffer|string} data - binary image buffer or base64-encoded image
 * string
 * @returns {Jimp} - the jimp image object
 */
function getJimpImage(data) {
  return _regeneratorRuntime.async(function getJimpImage$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(new _bluebird2['default'](function (resolve, reject) {
          if (!_lodash2['default'].isString(data) && !_lodash2['default'].isBuffer(data)) {
            return reject(new Error("Must initialize jimp object with string or buffer"));
          }
          // if data is a string, assume it is a base64-encoded image
          if (_lodash2['default'].isString(data)) {
            data = _buffer.Buffer.from(data, 'base64');
          }
          new _jimp2['default'](data, function (err, imgObj) {
            if (err) {
              return reject(err);
            }
            if (!imgObj) {
              return reject(new Error("Could not create jimp image from that data"));
            }
            imgObj._getBuffer = imgObj.getBuffer.bind(imgObj);
            imgObj.getBuffer = _bluebird2['default'].promisify(imgObj._getBuffer, { context: imgObj });
            resolve(imgObj);
          });
        }));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * @throws {Error} If opencv4nodejs module is not installed or cannot be loaded
 */
function initOpenCV() {
  if (!cv) {
    try {
      cv = require('opencv4nodejs');
    } catch (ign) {}
  }
  if (!cv) {
    throw new Error('opencv4nodejs module is required to use OpenCV features. ' + 'Please install it first (npm i -g opencv4nodejs) and restart Appium. ' + 'Read https://github.com/justadudewhohacks/opencv4nodejs#how-to-install for more details on this topic.');
  }
}

/**
 * @typedef {Object} MatchComputationResult
 * @property {cv.DescriptorMatch} desciptor - OpenCV match descriptor
 * @property {Array<cv.KeyPoint>} keyPoints - The array of key points
 */

/**
 * Calculates an OpenCV match descriptor of an image, which can be used
 * for brute-force matching.
 * Read https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_feature2d/py_matcher/py_matcher.html
 * for more details.
 *
 * @param {cv.Mat} img Image data
 * @param {cv.FeatureDetector} detector OpenCV feature detector instance
 *
 * @returns {MatchComputationResult}
 */
function detectAndCompute(img, detector) {
  var keyPoints, descriptor;
  return _regeneratorRuntime.async(function detectAndCompute$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(detector.detectAsync(img));

      case 2:
        keyPoints = context$1$0.sent;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(detector.computeAsync(img, keyPoints));

      case 5:
        descriptor = context$1$0.sent;
        return context$1$0.abrupt('return', {
          keyPoints: keyPoints,
          descriptor: descriptor
        });

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Calculated the bounding rect coordinates for the array of matching points
 *
 * @param {Array<Point>} matchedPoints Array of matching points
 * @returns {Rect} The matching bounding rect or a zero rect if no match
 * can be found.
 */
function calculateMatchedRect(matchedPoints) {
  if (matchedPoints.length < 2) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }

  var pointsSortedByDistance = matchedPoints.map(function (point) {
    return [Math.sqrt(point.x * point.x + point.y * point.y), point];
  }).sort(function (pair1, pair2) {
    return pair1[0] >= pair2[0];
  }).map(function (pair) {
    return pair[1];
  });
  var firstPoint = _lodash2['default'].head(pointsSortedByDistance);
  var lastPoint = _lodash2['default'].last(pointsSortedByDistance);
  var topLeftPoint = {
    x: firstPoint.x <= lastPoint.x ? firstPoint.x : lastPoint.x,
    y: firstPoint.y <= lastPoint.y ? firstPoint.y : lastPoint.y
  };
  var bottomRightPoint = {
    x: firstPoint.x >= lastPoint.x ? firstPoint.x : lastPoint.x,
    y: firstPoint.y >= lastPoint.y ? firstPoint.y : lastPoint.y
  };
  return {
    x: topLeftPoint.x,
    y: topLeftPoint.y,
    width: bottomRightPoint.x - topLeftPoint.x,
    height: bottomRightPoint.y - topLeftPoint.y
  };
}

/**
 * Draws a rectanngle on the given image matrix
 *
 * @param {cv.Mat} mat The source image
 * @param {Rect} region The region to highlight
 *
 * @returns {cv.Mat} The same image with the rectange on it
 */
function highlightRegion(mat, region) {
  if (region.width <= 0 || region.height <= 0) {
    return;
  }

  // highlight in red
  var color = new cv.Vec(0, 0, 255);
  var thickness = 2;
  mat.drawRectangle(new cv.Rect(region.x, region.y, region.width, region.height), color, thickness, cv.LINE_8);
  return mat;
}

/**
 * @typedef {Object} MatchingOptions
 * @property {?string} detectorName ['ORB'] One of possible OpenCV feature detector names
 * from `AVAILABLE_DETECTORS` array.
 * Some of these methods (FAST, AGAST, GFTT, FAST, SIFT and MSER) are not available
 * in the default OpenCV installation and have to be enabled manually before
 * library compilation.
 * @property {?string} matchFunc ['BruteForce'] The name of the matching function.
 * Should be one of `AVAILABLE_MATCHING_FUNCTIONS` array.
 * @property {?number|Function} goodMatchesFactor The maximum count of "good" matches
 * (e. g. with minimal distances) or a function, which accepts 3 arguments: the current distance,
 * minimal distance, maximum distance and returns true or false to include or exclude the match.
 * @property {?boolean} visualize [false] Whether to return the resulting visalization
 * as an image (useful for debugging purposes)
 */

/**
 * @typedef {Object} MatchingResult
 * @property {number} count The count of matched edges on both images.
 * The more matching edges there are no both images the more similar they are.
 * @property {number} totalCount The total count of matched edges on both images.
 * It is equal to `count` if `goodMatchesFactor` does not limit the matches,
 * otherwise it contains the total count of matches before `goodMatchesFactor` is
 * applied.
 * @property {?Buffer} visualization The visualization of the matching result
 * represented as PNG image buffer. This visualization looks like
 * https://user-images.githubusercontent.com/31125521/29702731-c79e3142-8972-11e7-947e-db109d415469.jpg
 * @property {Array<Point>} points1 The array of matching points on the first image
 * @property {Rect} rect1 The bounding rect for the `matchedPoints1` set or a zero rect
 * if not enough matching points are found
 * @property {Array<Point>} points2 The array of matching points on the second image
 * @property {Rect} rect2 The bounding rect for the `matchedPoints2` set or a zero rect
 * if not enough matching points are found
 */

/**
 * Calculates the count of common edges between two images.
 * The images might be rotated or resized relatively to each other.
 *
 * @param {Buffer} img1Data The data of the first image packed into a NodeJS buffer
 * @param {Buffer} img2Data The data of the second image packed into a NodeJS buffer
 * @param {?MatchingOptions} options [{}] Set of matching options
 *
 * @returns {MatchingResult} Maching result
 * @throws {Error} If `detectorName` value is unknown.
 */
function getImagesMatches(img1Data, img2Data) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var _options$detectorName, detectorName, _options$visualize, visualize, goodMatchesFactor, _options$matchFunc, matchFunc, detector, _ref, _ref2, img1, img2, _ref3, _ref32, result1, result2, matches, totalCount, points1, rect1, points2, rect2, result, visualization;

  return _regeneratorRuntime.async(function getImagesMatches$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        initOpenCV();

        _options$detectorName = options.detectorName;
        detectorName = _options$detectorName === undefined ? 'ORB' : _options$detectorName;
        _options$visualize = options.visualize;
        visualize = _options$visualize === undefined ? false : _options$visualize;
        goodMatchesFactor = options.goodMatchesFactor;
        _options$matchFunc = options.matchFunc;
        matchFunc = _options$matchFunc === undefined ? 'BruteForce' : _options$matchFunc;

        if (_lodash2['default'].includes(AVAILABLE_DETECTORS, detectorName)) {
          context$1$0.next = 10;
          break;
        }

        throw new Error('\'' + detectorName + '\' detector is unknown. ' + ('Only ' + JSON.stringify(AVAILABLE_DETECTORS) + ' detectors are supported.'));

      case 10:
        if (_lodash2['default'].includes(AVAILABLE_MATCHING_FUNCTIONS, matchFunc)) {
          context$1$0.next = 12;
          break;
        }

        throw new Error('\'' + matchFunc + '\' matching function is unknown. ' + ('Only ' + JSON.stringify(AVAILABLE_MATCHING_FUNCTIONS) + ' matching functions are supported.'));

      case 12:
        detector = new cv[detectorName + 'Detector']();
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(_bluebird2['default'].all([cv.imdecodeAsync(img1Data), cv.imdecodeAsync(img2Data)]));

      case 15:
        _ref = context$1$0.sent;
        _ref2 = _slicedToArray(_ref, 2);
        img1 = _ref2[0];
        img2 = _ref2[1];
        context$1$0.next = 21;
        return _regeneratorRuntime.awrap(_bluebird2['default'].all([detectAndCompute(img1, detector), detectAndCompute(img2, detector)]));

      case 21:
        _ref3 = context$1$0.sent;
        _ref32 = _slicedToArray(_ref3, 2);
        result1 = _ref32[0];
        result2 = _ref32[1];
        matches = [];
        context$1$0.prev = 26;
        context$1$0.next = 29;
        return _regeneratorRuntime.awrap(cv['match' + matchFunc + 'Async'](result1.descriptor, result2.descriptor));

      case 29:
        matches = context$1$0.sent;
        context$1$0.next = 35;
        break;

      case 32:
        context$1$0.prev = 32;
        context$1$0.t0 = context$1$0['catch'](26);
        throw new Error('Cannot find any matches between the given images. Try another detection algorithm. ' + (' Original error: ' + context$1$0.t0));

      case 35:
        totalCount = matches.length;

        if ((0, _util.hasValue)(goodMatchesFactor)) {
          if (_lodash2['default'].isFunction(goodMatchesFactor)) {
            (function () {
              var distances = matches.map(function (match) {
                return match.distance;
              });
              var minDistance = _lodash2['default'].min(distances);
              var maxDistance = _lodash2['default'].max(distances);
              matches = matches.filter(function (match) {
                return goodMatchesFactor(match.distance, minDistance, maxDistance);
              });
            })();
          } else {
            if (matches.length > goodMatchesFactor) {
              matches = matches.sort(function (match1, match2) {
                return match1.distance - match2.distance;
              }).slice(0, goodMatchesFactor);
            }
          }
        }

        points1 = matches.map(function (match) {
          return result1.keyPoints[match.queryIdx].point;
        });
        rect1 = calculateMatchedRect(points1);
        points2 = matches.map(function (match) {
          return result2.keyPoints[match.trainIdx].point;
        });
        rect2 = calculateMatchedRect(points2);
        result = {
          points1: points1,
          rect1: rect1,
          points2: points2,
          rect2: rect2,
          totalCount: totalCount,
          count: matches.length
        };

        if (!visualize) {
          context$1$0.next = 49;
          break;
        }

        visualization = cv.drawMatches(img1, img2, result1.keyPoints, result2.keyPoints, matches);

        highlightRegion(visualization, rect1);
        highlightRegion(visualization, {
          x: img1.cols + rect2.x,
          y: rect2.y,
          width: rect2.width,
          height: rect2.height
        });
        context$1$0.next = 48;
        return _regeneratorRuntime.awrap(cv.imencodeAsync('.png', visualization));

      case 48:
        result.visualization = context$1$0.sent;

      case 49:
        return context$1$0.abrupt('return', result);

      case 50:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[26, 32]]);
}

/**
 * @typedef {Object} SimilarityOptions
 * @property {?boolean} visualize [false] Whether to return the resulting visalization
 * as an image (useful for debugging purposes)
 */

/**
 * @typedef {Object} SimilarityResult
 * @property {number} score The similarity score as a float number in range [0.0, 1.0].
 * 1.0 is the highest score (means both images are totally equal).
 * @property {?Buffer} visualization The visualization of the matching result
 * represented as PNG image buffer. This image includes both input pictures where
 * difference regions are highlighted with rectangles.
 */

/**
 * Calculates the similarity score between two images.
 * It is expected, that both images have the same resolution.
 *
 * @param {Buffer} img1Data The data of the first image packed into a NodeJS buffer
 * @param {Buffer} img2Data The data of the second image packed into a NodeJS buffer
 * @param {?SimilarityOptions} options [{}] Set of similarity calculation options
 *
 * @returns {SimilarityResult} The calculation result
 * @throws {Error} If the given images have different resolution.
 */
function getImagesSimilarity(img1Data, img2Data) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var _options$visualize2, visualize, _ref4, _ref42, template, reference, _ref5, _ref52, matched, minMax, result, resultMat, mask, contours, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, contour, boundingRect;

  return _regeneratorRuntime.async(function getImagesSimilarity$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        initOpenCV();

        _options$visualize2 = options.visualize;
        visualize = _options$visualize2 === undefined ? false : _options$visualize2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(_bluebird2['default'].all([cv.imdecodeAsync(img1Data), cv.imdecodeAsync(img2Data)]));

      case 5:
        _ref4 = context$1$0.sent;
        _ref42 = _slicedToArray(_ref4, 2);
        template = _ref42[0];
        reference = _ref42[1];

        if (!(template.rows !== reference.rows || template.cols !== reference.cols)) {
          context$1$0.next = 11;
          break;
        }

        throw new Error('Both images are expected to have the same size in order to ' + 'calculate the similarity score.');

      case 11:
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(_bluebird2['default'].all([template.convertToAsync(cv.CV_8UC3), reference.convertToAsync(cv.CV_8UC3)]));

      case 13:
        _ref5 = context$1$0.sent;
        _ref52 = _slicedToArray(_ref5, 2);
        template = _ref52[0];
        reference = _ref52[1];
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(reference.matchTemplateAsync(template, cv.TM_CCOEFF_NORMED));

      case 19:
        matched = context$1$0.sent;
        context$1$0.next = 22;
        return _regeneratorRuntime.awrap(matched.minMaxLocAsync());

      case 22:
        minMax = context$1$0.sent;
        result = {
          score: minMax.maxVal
        };

        if (!visualize) {
          context$1$0.next = 66;
          break;
        }

        resultMat = new cv.Mat(template.rows, template.cols * 2, cv.CV_8UC3);
        context$1$0.next = 28;
        return _regeneratorRuntime.awrap(_bluebird2['default'].all([reference.copyToAsync(resultMat.getRegion(new cv.Rect(0, 0, reference.cols, reference.rows))), template.copyToAsync(resultMat.getRegion(new cv.Rect(reference.cols, 0, template.cols, template.rows)))]));

      case 28:
        mask = reference.absdiff(template);
        context$1$0.next = 31;
        return _regeneratorRuntime.awrap(mask.cvtColorAsync(cv.COLOR_BGR2GRAY));

      case 31:
        mask = context$1$0.sent;
        contours = [];
        context$1$0.prev = 33;
        context$1$0.next = 36;
        return _regeneratorRuntime.awrap(mask.thresholdAsync(128, 255, cv.THRESH_BINARY | cv.THRESH_OTSU));

      case 36:
        mask = context$1$0.sent;
        context$1$0.next = 39;
        return _regeneratorRuntime.awrap(mask.findContoursAsync(cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE));

      case 39:
        contours = context$1$0.sent;
        context$1$0.next = 44;
        break;

      case 42:
        context$1$0.prev = 42;
        context$1$0.t0 = context$1$0['catch'](33);

      case 44:
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 47;

        // No contours can be found, which means, most likely, that images are equal

        for (_iterator = _getIterator(contours); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          contour = _step.value;
          boundingRect = contour.boundingRect();

          highlightRegion(resultMat, boundingRect);
          highlightRegion(resultMat, {
            x: reference.cols + boundingRect.x,
            y: boundingRect.y,
            width: boundingRect.width,
            height: boundingRect.height
          });
        }
        context$1$0.next = 55;
        break;

      case 51:
        context$1$0.prev = 51;
        context$1$0.t1 = context$1$0['catch'](47);
        _didIteratorError = true;
        _iteratorError = context$1$0.t1;

      case 55:
        context$1$0.prev = 55;
        context$1$0.prev = 56;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 58:
        context$1$0.prev = 58;

        if (!_didIteratorError) {
          context$1$0.next = 61;
          break;
        }

        throw _iteratorError;

      case 61:
        return context$1$0.finish(58);

      case 62:
        return context$1$0.finish(55);

      case 63:
        context$1$0.next = 65;
        return _regeneratorRuntime.awrap(cv.imencodeAsync('.png', resultMat));

      case 65:
        result.visualization = context$1$0.sent;

      case 66:
        return context$1$0.abrupt('return', result);

      case 67:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[33, 42], [47, 51, 55, 63], [56,, 58, 62]]);
}

/**
 * @typedef {Object} OccurrenceOptions
 * @property {?boolean} visualize [false] Whether to return the resulting visalization
 * as an image (useful for debugging purposes)
 * @property {?float} threshold [0.5] At what normalized threshold to reject
 * a match
 */

/**
 * @typedef {Object} OccurrenceResult
 * @property {Rect} rect The region of the partial image occurence
 * on the full image
 * @property {?Buffer} visualization The visualization of the matching result
 * represented as PNG image buffer. On this image the matching
 * region is highlighted with a rectangle.
 */

/**
 * Calculates the occurence position of a partial image in the full
 * image.
 *
 * @param {Buffer} fullImgData The data of the full image packed into a NodeJS buffer
 * @param {Buffer} partialImgData The data of the partial image packed into a NodeJS buffer
 * @param {?OccurrenceOptions} options [{}] Set of occurrence calculation options
 *
 * @returns {OccurrenceResult}
 * @throws {Error} If no occurences of the partial image can be found in the full image
 */
function getImageOccurrence(fullImgData, partialImgData) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var _options$visualize3, visualize, _options$threshold, threshold, _ref6, _ref62, fullImg, partialImg, result, matched, minMax;

  return _regeneratorRuntime.async(function getImageOccurrence$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        initOpenCV();

        _options$visualize3 = options.visualize;
        visualize = _options$visualize3 === undefined ? false : _options$visualize3;
        _options$threshold = options.threshold;
        threshold = _options$threshold === undefined ? DEFAULT_MATCH_THRESHOLD : _options$threshold;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(_bluebird2['default'].all([cv.imdecodeAsync(fullImgData), cv.imdecodeAsync(partialImgData)]));

      case 7:
        _ref6 = context$1$0.sent;
        _ref62 = _slicedToArray(_ref6, 2);
        fullImg = _ref62[0];
        partialImg = _ref62[1];
        result = {};
        context$1$0.prev = 12;
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(fullImg.matchTemplateAsync(partialImg, cv.TM_CCOEFF_NORMED));

      case 15:
        matched = context$1$0.sent;
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap(matched.minMaxLocAsync());

      case 18:
        minMax = context$1$0.sent;

        if (!(minMax.maxVal < threshold)) {
          context$1$0.next = 21;
          break;
        }

        throw new Error('Cannot find any occurrences of the partial image in the full ' + ('image above the threshold of ' + threshold + '. Highest match value ') + ('found was ' + minMax.maxVal));

      case 21:
        result.rect = {
          x: minMax.maxLoc.x,
          y: minMax.maxLoc.y,
          width: partialImg.cols,
          height: partialImg.rows
        };
        context$1$0.next = 27;
        break;

      case 24:
        context$1$0.prev = 24;
        context$1$0.t0 = context$1$0['catch'](12);
        throw new Error('Cannot find any occurences of the partial image in the full image. ' + ('Original error: ' + context$1$0.t0));

      case 27:
        if (!visualize) {
          context$1$0.next = 32;
          break;
        }

        highlightRegion(fullImg, result.rect);
        context$1$0.next = 31;
        return _regeneratorRuntime.awrap(cv.imencodeAsync('.png', fullImg));

      case 31:
        result.visualization = context$1$0.sent;

      case 32:
        return context$1$0.abrupt('return', result);

      case 33:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[12, 24]]);
}

/**
 * Crop the image by given rectangle (use base64 string as input and output)
 *
 * @param {string} base64Image The string with base64 encoded image
 * @param {Region} rect The selected region of image
 * @return {string} base64 encoded string of cropped image
 */
function cropBase64Image(base64Image, rect) {
  var image;
  return _regeneratorRuntime.async(function cropBase64Image$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(base64ToImage(base64Image));

      case 2:
        image = context$1$0.sent;

        cropImage(image, rect);
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(imageToBase64(image));

      case 6:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Create a pngjs image from given base64 image
 *
 * @param {string} base64Image The string with base64 encoded image
 * @return {PNG} The image object
 */
function base64ToImage(base64Image) {
  var imageBuffer;
  return _regeneratorRuntime.async(function base64ToImage$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        imageBuffer = _buffer.Buffer.from(base64Image, 'base64');
        return context$1$0.abrupt('return', new _bluebird2['default'](function (resolve, reject) {
          var image = new _pngjs.PNG({ filterType: SCANLINE_FILTER_METHOD });
          image.parse(imageBuffer, function (err, image) {
            // eslint-disable-line promise/prefer-await-to-callbacks
            if (err) {
              return reject(err);
            }
            resolve(image);
          });
        }));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Create a base64 string for given image object
 *
 * @param {PNG} image The image object
 * @return {string} The string with base64 encoded image
 */
function imageToBase64(image) {
  return _regeneratorRuntime.async(function imageToBase64$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        return context$1$0.abrupt('return', new _bluebird2['default'](function (resolve, reject) {
          var chunks = [];
          image.pack().on('data', function (chunk) {
            return chunks.push(chunk);
          }).on('end', function () {
            resolve(_buffer.Buffer.concat(chunks).toString('base64'));
          }).on('error', function (err) {
            // eslint-disable-line promise/prefer-await-to-callbacks
            reject(err);
          });
        }));

      case 1:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Crop the image by given rectangle
 *
 * @param {PNG} image The image to mutate by cropping
 * @param {Region} rect The selected region of image
 */
function cropImage(image, rect) {
  var imageRect = { width: image.width, height: image.height };
  var interRect = getRectIntersection(rect, imageRect);
  if (interRect.width < rect.width || interRect.height < rect.height) {
    throw new Error('Cannot crop ' + JSON.stringify(rect) + ' from ' + JSON.stringify(imageRect) + ' because the intersection between them was not the size of the rect');
  }

  var firstVerticalPixel = interRect.top;
  var lastVerticalPixel = interRect.top + interRect.height;

  var firstHorizontalPixel = interRect.left;
  var lastHorizontalPixel = interRect.left + interRect.width;

  var croppedArray = [];
  for (var y = firstVerticalPixel; y < lastVerticalPixel; y++) {
    for (var x = firstHorizontalPixel; x < lastHorizontalPixel; x++) {
      var firstByteIdxInPixelBlock = imageRect.width * y + x << 2;
      for (var byteIdx = 0; byteIdx < BYTES_IN_PIXEL_BLOCK; byteIdx++) {
        croppedArray.push(image.data[firstByteIdxInPixelBlock + byteIdx]);
      }
    }
  }

  image.data = _buffer.Buffer.from(croppedArray);
  image.width = interRect.width;
  image.height = interRect.height;
  return image;
}

function getRectIntersection(rect, imageSize) {
  var left = rect.left >= imageSize.width ? imageSize.width : rect.left;
  var top = rect.top >= imageSize.height ? imageSize.height : rect.top;
  var width = imageSize.width >= left + rect.width ? rect.width : imageSize.width - left;
  var height = imageSize.height >= top + rect.height ? rect.height : imageSize.height - top;
  return { left: left, top: top, width: width, height: height };
}

exports.cropBase64Image = cropBase64Image;
exports.base64ToImage = base64ToImage;
exports.imageToBase64 = imageToBase64;
exports.cropImage = cropImage;
exports.getImagesMatches = getImagesMatches;
exports.getImagesSimilarity = getImagesSimilarity;
exports.getImageOccurrence = getImageOccurrence;
exports.getJimpImage = getJimpImage;
exports.MIME_JPEG = MIME_JPEG;
exports.MIME_PNG = MIME_PNG;
exports.MIME_BMP = MIME_BMP;
//# sourceMappingURL=data:application/json;charset=utf8;base64,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b250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgSmltcCBmcm9tICdqaW1wJztcbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcic7XG5pbXBvcnQgeyBQTkcgfSBmcm9tICdwbmdqcyc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBoYXNWYWx1ZSB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IHsgTUlNRV9KUEVHLCBNSU1FX1BORywgTUlNRV9CTVAgfSA9IEppbXA7XG5sZXQgY3YgPSBudWxsO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlZ2lvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnQgLSBUaGUgb2Zmc2V0IGZyb20gdGhlIGxlZnQgc2lkZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcCAtIFRoZSBvZmZzZXQgZnJvbSB0aGUgdG9wXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQb2ludFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggLSBUaGUgeCBjb29yZGluYXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0geSAtIFRoZSB5IGNvb3JkaW5hdGVcbiAqL1xuXG4gLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZWN0XG4gKiBAcHJvcGVydHkge251bWJlcn0geCAtIFRoZSB0b3AgbGVmdCBjb29yZGluYXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0geSAtIFRoZSBib3R0b20gcmlnaHQgY29vcmRpbmF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodFxuICovXG5cbmNvbnN0IEJZVEVTX0lOX1BJWEVMX0JMT0NLID0gNDtcbmNvbnN0IFNDQU5MSU5FX0ZJTFRFUl9NRVRIT0QgPSA0O1xuY29uc3QgREVGQVVMVF9NQVRDSF9USFJFU0hPTEQgPSAwLjU7XG5cbmNvbnN0IEFWQUlMQUJMRV9ERVRFQ1RPUlMgPSBbXG4gICdBS0FaRScsXG4gICdBR0FTVCcsXG4gICdCUklTSycsXG4gICdGQVNUJyxcbiAgJ0dGVFQnLFxuICAnS0FaRScsXG4gICdNU0VSJyxcbiAgJ1NJRlQnLFxuICAnT1JCJyxcbl07XG5cbmNvbnN0IEFWQUlMQUJMRV9NQVRDSElOR19GVU5DVElPTlMgPSBbXG4gICdGbGFubkJhc2VkJyxcbiAgJ0JydXRlRm9yY2UnLFxuICAnQnJ1dGVGb3JjZUwxJyxcbiAgJ0JydXRlRm9yY2VIYW1taW5nJyxcbiAgJ0JydXRlRm9yY2VIYW1taW5nTHV0JyxcbiAgJ0JydXRlRm9yY2VTTDInLFxuXTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGdldCBhIEppbXAgaW1hZ2Ugb2JqZWN0IGZyb20gYnVmZmVyIG9yIGJhc2U2NCBkYXRhLiBKaW1wXG4gKiBpcyBhIGdyZWF0IGxpYnJhcnkgaG93ZXZlciBpdCBkb2VzIElPIGluIHRoZSBjb25zdHJ1Y3RvciBzbyBpdCdzIG5vdFxuICogY29udmVuaWVudCBmb3Igb3VyIGFzeW5jL2F3YWl0IG1vZGVsLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gZGF0YSAtIGJpbmFyeSBpbWFnZSBidWZmZXIgb3IgYmFzZTY0LWVuY29kZWQgaW1hZ2VcbiAqIHN0cmluZ1xuICogQHJldHVybnMge0ppbXB9IC0gdGhlIGppbXAgaW1hZ2Ugb2JqZWN0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEppbXBJbWFnZSAoZGF0YSkge1xuICByZXR1cm4gYXdhaXQgbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmICghXy5pc1N0cmluZyhkYXRhKSAmJiAhXy5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJNdXN0IGluaXRpYWxpemUgamltcCBvYmplY3Qgd2l0aCBzdHJpbmcgb3IgYnVmZmVyXCIpKTtcbiAgICB9XG4gICAgLy8gaWYgZGF0YSBpcyBhIHN0cmluZywgYXNzdW1lIGl0IGlzIGEgYmFzZTY0LWVuY29kZWQgaW1hZ2VcbiAgICBpZiAoXy5pc1N0cmluZyhkYXRhKSkge1xuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsICdiYXNlNjQnKTtcbiAgICB9XG4gICAgbmV3IEppbXAoZGF0YSwgKGVyciwgaW1nT2JqKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIGlmICghaW1nT2JqKSB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKFwiQ291bGQgbm90IGNyZWF0ZSBqaW1wIGltYWdlIGZyb20gdGhhdCBkYXRhXCIpKTtcbiAgICAgIH1cbiAgICAgIGltZ09iai5fZ2V0QnVmZmVyID0gaW1nT2JqLmdldEJ1ZmZlci5iaW5kKGltZ09iaik7XG4gICAgICBpbWdPYmouZ2V0QnVmZmVyID0gQi5wcm9taXNpZnkoaW1nT2JqLl9nZXRCdWZmZXIsIHtjb250ZXh0OiBpbWdPYmp9KTtcbiAgICAgIHJlc29sdmUoaW1nT2JqKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQHRocm93cyB7RXJyb3J9IElmIG9wZW5jdjRub2RlanMgbW9kdWxlIGlzIG5vdCBpbnN0YWxsZWQgb3IgY2Fubm90IGJlIGxvYWRlZFxuICovXG5mdW5jdGlvbiBpbml0T3BlbkNWICgpIHtcbiAgaWYgKCFjdikge1xuICAgIHRyeSB7XG4gICAgICBjdiA9IHJlcXVpcmUoJ29wZW5jdjRub2RlanMnKTtcbiAgICB9IGNhdGNoIChpZ24pIHt9XG4gIH1cbiAgaWYgKCFjdikge1xuICAgIHRocm93IG5ldyBFcnJvcignb3BlbmN2NG5vZGVqcyBtb2R1bGUgaXMgcmVxdWlyZWQgdG8gdXNlIE9wZW5DViBmZWF0dXJlcy4gJyArXG4gICAgICAgICAgICAgICAgICAgICdQbGVhc2UgaW5zdGFsbCBpdCBmaXJzdCAobnBtIGkgLWcgb3BlbmN2NG5vZGVqcykgYW5kIHJlc3RhcnQgQXBwaXVtLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1JlYWQgaHR0cHM6Ly9naXRodWIuY29tL2p1c3RhZHVkZXdob2hhY2tzL29wZW5jdjRub2RlanMjaG93LXRvLWluc3RhbGwgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGlzIHRvcGljLicpO1xuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWF0Y2hDb21wdXRhdGlvblJlc3VsdFxuICogQHByb3BlcnR5IHtjdi5EZXNjcmlwdG9yTWF0Y2h9IGRlc2NpcHRvciAtIE9wZW5DViBtYXRjaCBkZXNjcmlwdG9yXG4gKiBAcHJvcGVydHkge0FycmF5PGN2LktleVBvaW50Pn0ga2V5UG9pbnRzIC0gVGhlIGFycmF5IG9mIGtleSBwb2ludHNcbiAqL1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgYW4gT3BlbkNWIG1hdGNoIGRlc2NyaXB0b3Igb2YgYW4gaW1hZ2UsIHdoaWNoIGNhbiBiZSB1c2VkXG4gKiBmb3IgYnJ1dGUtZm9yY2UgbWF0Y2hpbmcuXG4gKiBSZWFkIGh0dHBzOi8vZG9jcy5vcGVuY3Yub3JnLzMuMC1iZXRhL2RvYy9weV90dXRvcmlhbHMvcHlfZmVhdHVyZTJkL3B5X21hdGNoZXIvcHlfbWF0Y2hlci5odG1sXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBwYXJhbSB7Y3YuTWF0fSBpbWcgSW1hZ2UgZGF0YVxuICogQHBhcmFtIHtjdi5GZWF0dXJlRGV0ZWN0b3J9IGRldGVjdG9yIE9wZW5DViBmZWF0dXJlIGRldGVjdG9yIGluc3RhbmNlXG4gKlxuICogQHJldHVybnMge01hdGNoQ29tcHV0YXRpb25SZXN1bHR9XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRldGVjdEFuZENvbXB1dGUgKGltZywgZGV0ZWN0b3IpIHtcbiAgY29uc3Qga2V5UG9pbnRzID0gYXdhaXQgZGV0ZWN0b3IuZGV0ZWN0QXN5bmMoaW1nKTtcbiAgY29uc3QgZGVzY3JpcHRvciA9IGF3YWl0IGRldGVjdG9yLmNvbXB1dGVBc3luYyhpbWcsIGtleVBvaW50cyk7XG4gIHJldHVybiB7XG4gICAga2V5UG9pbnRzLFxuICAgIGRlc2NyaXB0b3JcbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVkIHRoZSBib3VuZGluZyByZWN0IGNvb3JkaW5hdGVzIGZvciB0aGUgYXJyYXkgb2YgbWF0Y2hpbmcgcG9pbnRzXG4gKlxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IG1hdGNoZWRQb2ludHMgQXJyYXkgb2YgbWF0Y2hpbmcgcG9pbnRzXG4gKiBAcmV0dXJucyB7UmVjdH0gVGhlIG1hdGNoaW5nIGJvdW5kaW5nIHJlY3Qgb3IgYSB6ZXJvIHJlY3QgaWYgbm8gbWF0Y2hcbiAqIGNhbiBiZSBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlTWF0Y2hlZFJlY3QgKG1hdGNoZWRQb2ludHMpIHtcbiAgaWYgKG1hdGNoZWRQb2ludHMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHBvaW50c1NvcnRlZEJ5RGlzdGFuY2UgPSBtYXRjaGVkUG9pbnRzXG4gICAgLm1hcChwb2ludCA9PiBbTWF0aC5zcXJ0KHBvaW50LnggKiBwb2ludC54ICsgcG9pbnQueSAqIHBvaW50LnkpLCBwb2ludF0pXG4gICAgLnNvcnQoKHBhaXIxLCBwYWlyMikgPT4gcGFpcjFbMF0gPj0gcGFpcjJbMF0pXG4gICAgLm1hcChwYWlyID0+IHBhaXJbMV0pO1xuICBjb25zdCBmaXJzdFBvaW50ID0gXy5oZWFkKHBvaW50c1NvcnRlZEJ5RGlzdGFuY2UpO1xuICBjb25zdCBsYXN0UG9pbnQgPSBfLmxhc3QocG9pbnRzU29ydGVkQnlEaXN0YW5jZSk7XG4gIGNvbnN0IHRvcExlZnRQb2ludCA9IHtcbiAgICB4OiBmaXJzdFBvaW50LnggPD0gbGFzdFBvaW50LnggPyBmaXJzdFBvaW50LnggOiBsYXN0UG9pbnQueCxcbiAgICB5OiBmaXJzdFBvaW50LnkgPD0gbGFzdFBvaW50LnkgPyBmaXJzdFBvaW50LnkgOiBsYXN0UG9pbnQueSxcbiAgfTtcbiAgY29uc3QgYm90dG9tUmlnaHRQb2ludCA9IHtcbiAgICB4OiBmaXJzdFBvaW50LnggPj0gbGFzdFBvaW50LnggPyBmaXJzdFBvaW50LnggOiBsYXN0UG9pbnQueCxcbiAgICB5OiBmaXJzdFBvaW50LnkgPj0gbGFzdFBvaW50LnkgPyBmaXJzdFBvaW50LnkgOiBsYXN0UG9pbnQueSxcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB4OiB0b3BMZWZ0UG9pbnQueCxcbiAgICB5OiB0b3BMZWZ0UG9pbnQueSxcbiAgICB3aWR0aDogYm90dG9tUmlnaHRQb2ludC54IC0gdG9wTGVmdFBvaW50LngsXG4gICAgaGVpZ2h0OiBib3R0b21SaWdodFBvaW50LnkgLSB0b3BMZWZ0UG9pbnQueVxuICB9O1xufVxuXG4vKipcbiAqIERyYXdzIGEgcmVjdGFubmdsZSBvbiB0aGUgZ2l2ZW4gaW1hZ2UgbWF0cml4XG4gKlxuICogQHBhcmFtIHtjdi5NYXR9IG1hdCBUaGUgc291cmNlIGltYWdlXG4gKiBAcGFyYW0ge1JlY3R9IHJlZ2lvbiBUaGUgcmVnaW9uIHRvIGhpZ2hsaWdodFxuICpcbiAqIEByZXR1cm5zIHtjdi5NYXR9IFRoZSBzYW1lIGltYWdlIHdpdGggdGhlIHJlY3RhbmdlIG9uIGl0XG4gKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFJlZ2lvbiAobWF0LCByZWdpb24pIHtcbiAgaWYgKHJlZ2lvbi53aWR0aCA8PSAwIHx8IHJlZ2lvbi5oZWlnaHQgPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGhpZ2hsaWdodCBpbiByZWRcbiAgY29uc3QgY29sb3IgPSBuZXcgY3YuVmVjKDAsIDAsIDI1NSk7XG4gIGNvbnN0IHRoaWNrbmVzcyA9IDI7XG4gIG1hdC5kcmF3UmVjdGFuZ2xlKG5ldyBjdi5SZWN0KHJlZ2lvbi54LCByZWdpb24ueSwgcmVnaW9uLndpZHRoLCByZWdpb24uaGVpZ2h0KSwgY29sb3IsIHRoaWNrbmVzcywgY3YuTElORV84KTtcbiAgcmV0dXJuIG1hdDtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNYXRjaGluZ09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gZGV0ZWN0b3JOYW1lIFsnT1JCJ10gT25lIG9mIHBvc3NpYmxlIE9wZW5DViBmZWF0dXJlIGRldGVjdG9yIG5hbWVzXG4gKiBmcm9tIGBBVkFJTEFCTEVfREVURUNUT1JTYCBhcnJheS5cbiAqIFNvbWUgb2YgdGhlc2UgbWV0aG9kcyAoRkFTVCwgQUdBU1QsIEdGVFQsIEZBU1QsIFNJRlQgYW5kIE1TRVIpIGFyZSBub3QgYXZhaWxhYmxlXG4gKiBpbiB0aGUgZGVmYXVsdCBPcGVuQ1YgaW5zdGFsbGF0aW9uIGFuZCBoYXZlIHRvIGJlIGVuYWJsZWQgbWFudWFsbHkgYmVmb3JlXG4gKiBsaWJyYXJ5IGNvbXBpbGF0aW9uLlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBtYXRjaEZ1bmMgWydCcnV0ZUZvcmNlJ10gVGhlIG5hbWUgb2YgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uLlxuICogU2hvdWxkIGJlIG9uZSBvZiBgQVZBSUxBQkxFX01BVENISU5HX0ZVTkNUSU9OU2AgYXJyYXkuXG4gKiBAcHJvcGVydHkgez9udW1iZXJ8RnVuY3Rpb259IGdvb2RNYXRjaGVzRmFjdG9yIFRoZSBtYXhpbXVtIGNvdW50IG9mIFwiZ29vZFwiIG1hdGNoZXNcbiAqIChlLiBnLiB3aXRoIG1pbmltYWwgZGlzdGFuY2VzKSBvciBhIGZ1bmN0aW9uLCB3aGljaCBhY2NlcHRzIDMgYXJndW1lbnRzOiB0aGUgY3VycmVudCBkaXN0YW5jZSxcbiAqIG1pbmltYWwgZGlzdGFuY2UsIG1heGltdW0gZGlzdGFuY2UgYW5kIHJldHVybnMgdHJ1ZSBvciBmYWxzZSB0byBpbmNsdWRlIG9yIGV4Y2x1ZGUgdGhlIG1hdGNoLlxuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gdmlzdWFsaXplIFtmYWxzZV0gV2hldGhlciB0byByZXR1cm4gdGhlIHJlc3VsdGluZyB2aXNhbGl6YXRpb25cbiAqIGFzIGFuIGltYWdlICh1c2VmdWwgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcylcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1hdGNoaW5nUmVzdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gY291bnQgVGhlIGNvdW50IG9mIG1hdGNoZWQgZWRnZXMgb24gYm90aCBpbWFnZXMuXG4gKiBUaGUgbW9yZSBtYXRjaGluZyBlZGdlcyB0aGVyZSBhcmUgbm8gYm90aCBpbWFnZXMgdGhlIG1vcmUgc2ltaWxhciB0aGV5IGFyZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b3RhbENvdW50IFRoZSB0b3RhbCBjb3VudCBvZiBtYXRjaGVkIGVkZ2VzIG9uIGJvdGggaW1hZ2VzLlxuICogSXQgaXMgZXF1YWwgdG8gYGNvdW50YCBpZiBgZ29vZE1hdGNoZXNGYWN0b3JgIGRvZXMgbm90IGxpbWl0IHRoZSBtYXRjaGVzLFxuICogb3RoZXJ3aXNlIGl0IGNvbnRhaW5zIHRoZSB0b3RhbCBjb3VudCBvZiBtYXRjaGVzIGJlZm9yZSBgZ29vZE1hdGNoZXNGYWN0b3JgIGlzXG4gKiBhcHBsaWVkLlxuICogQHByb3BlcnR5IHs/QnVmZmVyfSB2aXN1YWxpemF0aW9uIFRoZSB2aXN1YWxpemF0aW9uIG9mIHRoZSBtYXRjaGluZyByZXN1bHRcbiAqIHJlcHJlc2VudGVkIGFzIFBORyBpbWFnZSBidWZmZXIuIFRoaXMgdmlzdWFsaXphdGlvbiBsb29rcyBsaWtlXG4gKiBodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8zMTEyNTUyMS8yOTcwMjczMS1jNzllMzE0Mi04OTcyLTExZTctOTQ3ZS1kYjEwOWQ0MTU0NjkuanBnXG4gKiBAcHJvcGVydHkge0FycmF5PFBvaW50Pn0gcG9pbnRzMSBUaGUgYXJyYXkgb2YgbWF0Y2hpbmcgcG9pbnRzIG9uIHRoZSBmaXJzdCBpbWFnZVxuICogQHByb3BlcnR5IHtSZWN0fSByZWN0MSBUaGUgYm91bmRpbmcgcmVjdCBmb3IgdGhlIGBtYXRjaGVkUG9pbnRzMWAgc2V0IG9yIGEgemVybyByZWN0XG4gKiBpZiBub3QgZW5vdWdoIG1hdGNoaW5nIHBvaW50cyBhcmUgZm91bmRcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8UG9pbnQ+fSBwb2ludHMyIFRoZSBhcnJheSBvZiBtYXRjaGluZyBwb2ludHMgb24gdGhlIHNlY29uZCBpbWFnZVxuICogQHByb3BlcnR5IHtSZWN0fSByZWN0MiBUaGUgYm91bmRpbmcgcmVjdCBmb3IgdGhlIGBtYXRjaGVkUG9pbnRzMmAgc2V0IG9yIGEgemVybyByZWN0XG4gKiBpZiBub3QgZW5vdWdoIG1hdGNoaW5nIHBvaW50cyBhcmUgZm91bmRcbiAqL1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGNvdW50IG9mIGNvbW1vbiBlZGdlcyBiZXR3ZWVuIHR3byBpbWFnZXMuXG4gKiBUaGUgaW1hZ2VzIG1pZ2h0IGJlIHJvdGF0ZWQgb3IgcmVzaXplZCByZWxhdGl2ZWx5IHRvIGVhY2ggb3RoZXIuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGltZzFEYXRhIFRoZSBkYXRhIG9mIHRoZSBmaXJzdCBpbWFnZSBwYWNrZWQgaW50byBhIE5vZGVKUyBidWZmZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBpbWcyRGF0YSBUaGUgZGF0YSBvZiB0aGUgc2Vjb25kIGltYWdlIHBhY2tlZCBpbnRvIGEgTm9kZUpTIGJ1ZmZlclxuICogQHBhcmFtIHs/TWF0Y2hpbmdPcHRpb25zfSBvcHRpb25zIFt7fV0gU2V0IG9mIG1hdGNoaW5nIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7TWF0Y2hpbmdSZXN1bHR9IE1hY2hpbmcgcmVzdWx0XG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYGRldGVjdG9yTmFtZWAgdmFsdWUgaXMgdW5rbm93bi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0SW1hZ2VzTWF0Y2hlcyAoaW1nMURhdGEsIGltZzJEYXRhLCBvcHRpb25zID0ge30pIHtcbiAgaW5pdE9wZW5DVigpO1xuXG4gIGNvbnN0IHtkZXRlY3Rvck5hbWUgPSAnT1JCJywgdmlzdWFsaXplID0gZmFsc2UsXG4gICAgICAgICBnb29kTWF0Y2hlc0ZhY3RvciwgbWF0Y2hGdW5jID0gJ0JydXRlRm9yY2UnfSA9IG9wdGlvbnM7XG4gIGlmICghXy5pbmNsdWRlcyhBVkFJTEFCTEVfREVURUNUT1JTLCBkZXRlY3Rvck5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHtkZXRlY3Rvck5hbWV9JyBkZXRlY3RvciBpcyB1bmtub3duLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYE9ubHkgJHtKU09OLnN0cmluZ2lmeShBVkFJTEFCTEVfREVURUNUT1JTKX0gZGV0ZWN0b3JzIGFyZSBzdXBwb3J0ZWQuYCk7XG4gIH1cbiAgaWYgKCFfLmluY2x1ZGVzKEFWQUlMQUJMRV9NQVRDSElOR19GVU5DVElPTlMsIG1hdGNoRnVuYykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCcke21hdGNoRnVuY30nIG1hdGNoaW5nIGZ1bmN0aW9uIGlzIHVua25vd24uIGAgK1xuICAgICAgICAgICAgICAgICAgICBgT25seSAke0pTT04uc3RyaW5naWZ5KEFWQUlMQUJMRV9NQVRDSElOR19GVU5DVElPTlMpfSBtYXRjaGluZyBmdW5jdGlvbnMgYXJlIHN1cHBvcnRlZC5gKTtcbiAgfVxuXG4gIGNvbnN0IGRldGVjdG9yID0gbmV3IGN2W2Ake2RldGVjdG9yTmFtZX1EZXRlY3RvcmBdKCk7XG4gIGNvbnN0IFtpbWcxLCBpbWcyXSA9IGF3YWl0IEIuYWxsKFtcbiAgICBjdi5pbWRlY29kZUFzeW5jKGltZzFEYXRhKSxcbiAgICBjdi5pbWRlY29kZUFzeW5jKGltZzJEYXRhKVxuICBdKTtcbiAgY29uc3QgW3Jlc3VsdDEsIHJlc3VsdDJdID0gYXdhaXQgQi5hbGwoW1xuICAgIGRldGVjdEFuZENvbXB1dGUoaW1nMSwgZGV0ZWN0b3IpLFxuICAgIGRldGVjdEFuZENvbXB1dGUoaW1nMiwgZGV0ZWN0b3IpXG4gIF0pO1xuICBsZXQgbWF0Y2hlcyA9IFtdO1xuICB0cnkge1xuICAgIG1hdGNoZXMgPSBhd2FpdCBjdltgbWF0Y2gke21hdGNoRnVuY31Bc3luY2BdKHJlc3VsdDEuZGVzY3JpcHRvciwgcmVzdWx0Mi5kZXNjcmlwdG9yKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgYW55IG1hdGNoZXMgYmV0d2VlbiB0aGUgZ2l2ZW4gaW1hZ2VzLiBUcnkgYW5vdGhlciBkZXRlY3Rpb24gYWxnb3JpdGhtLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYCBPcmlnaW5hbCBlcnJvcjogJHtlfWApO1xuICB9XG4gIGNvbnN0IHRvdGFsQ291bnQgPSBtYXRjaGVzLmxlbmd0aDtcbiAgaWYgKGhhc1ZhbHVlKGdvb2RNYXRjaGVzRmFjdG9yKSkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oZ29vZE1hdGNoZXNGYWN0b3IpKSB7XG4gICAgICBjb25zdCBkaXN0YW5jZXMgPSBtYXRjaGVzLm1hcChtYXRjaCA9PiBtYXRjaC5kaXN0YW5jZSk7XG4gICAgICBjb25zdCBtaW5EaXN0YW5jZSA9IF8ubWluKGRpc3RhbmNlcyk7XG4gICAgICBjb25zdCBtYXhEaXN0YW5jZSA9IF8ubWF4KGRpc3RhbmNlcyk7XG4gICAgICBtYXRjaGVzID0gbWF0Y2hlc1xuICAgICAgICAuZmlsdGVyKG1hdGNoID0+IGdvb2RNYXRjaGVzRmFjdG9yKG1hdGNoLmRpc3RhbmNlLCBtaW5EaXN0YW5jZSwgbWF4RGlzdGFuY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gZ29vZE1hdGNoZXNGYWN0b3IpIHtcbiAgICAgICAgbWF0Y2hlcyA9IG1hdGNoZXNcbiAgICAgICAgICAuc29ydCgobWF0Y2gxLCBtYXRjaDIpID0+IG1hdGNoMS5kaXN0YW5jZSAtIG1hdGNoMi5kaXN0YW5jZSlcbiAgICAgICAgICAuc2xpY2UoMCwgZ29vZE1hdGNoZXNGYWN0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHBvaW50czEgPSBtYXRjaGVzLm1hcChtYXRjaCA9PiByZXN1bHQxLmtleVBvaW50c1ttYXRjaC5xdWVyeUlkeF0ucG9pbnQpO1xuICBjb25zdCByZWN0MSA9IGNhbGN1bGF0ZU1hdGNoZWRSZWN0KHBvaW50czEpO1xuICBjb25zdCBwb2ludHMyID0gbWF0Y2hlcy5tYXAobWF0Y2ggPT4gcmVzdWx0Mi5rZXlQb2ludHNbbWF0Y2gudHJhaW5JZHhdLnBvaW50KTtcbiAgY29uc3QgcmVjdDIgPSBjYWxjdWxhdGVNYXRjaGVkUmVjdChwb2ludHMyKTtcblxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgcG9pbnRzMSxcbiAgICByZWN0MSxcbiAgICBwb2ludHMyLFxuICAgIHJlY3QyLFxuICAgIHRvdGFsQ291bnQsXG4gICAgY291bnQ6IG1hdGNoZXMubGVuZ3RoLFxuICB9O1xuICBpZiAodmlzdWFsaXplKSB7XG4gICAgY29uc3QgdmlzdWFsaXphdGlvbiA9IGN2LmRyYXdNYXRjaGVzKGltZzEsIGltZzIsIHJlc3VsdDEua2V5UG9pbnRzLCByZXN1bHQyLmtleVBvaW50cywgbWF0Y2hlcyk7XG4gICAgaGlnaGxpZ2h0UmVnaW9uKHZpc3VhbGl6YXRpb24sIHJlY3QxKTtcbiAgICBoaWdobGlnaHRSZWdpb24odmlzdWFsaXphdGlvbiwge1xuICAgICAgeDogaW1nMS5jb2xzICsgcmVjdDIueCxcbiAgICAgIHk6IHJlY3QyLnksXG4gICAgICB3aWR0aDogcmVjdDIud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlY3QyLmhlaWdodFxuICAgIH0pO1xuICAgIHJlc3VsdC52aXN1YWxpemF0aW9uID0gYXdhaXQgY3YuaW1lbmNvZGVBc3luYygnLnBuZycsIHZpc3VhbGl6YXRpb24pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2ltaWxhcml0eU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IHZpc3VhbGl6ZSBbZmFsc2VdIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSByZXN1bHRpbmcgdmlzYWxpemF0aW9uXG4gKiBhcyBhbiBpbWFnZSAodXNlZnVsIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTaW1pbGFyaXR5UmVzdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gc2NvcmUgVGhlIHNpbWlsYXJpdHkgc2NvcmUgYXMgYSBmbG9hdCBudW1iZXIgaW4gcmFuZ2UgWzAuMCwgMS4wXS5cbiAqIDEuMCBpcyB0aGUgaGlnaGVzdCBzY29yZSAobWVhbnMgYm90aCBpbWFnZXMgYXJlIHRvdGFsbHkgZXF1YWwpLlxuICogQHByb3BlcnR5IHs/QnVmZmVyfSB2aXN1YWxpemF0aW9uIFRoZSB2aXN1YWxpemF0aW9uIG9mIHRoZSBtYXRjaGluZyByZXN1bHRcbiAqIHJlcHJlc2VudGVkIGFzIFBORyBpbWFnZSBidWZmZXIuIFRoaXMgaW1hZ2UgaW5jbHVkZXMgYm90aCBpbnB1dCBwaWN0dXJlcyB3aGVyZVxuICogZGlmZmVyZW5jZSByZWdpb25zIGFyZSBoaWdobGlnaHRlZCB3aXRoIHJlY3RhbmdsZXMuXG4gKi9cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzaW1pbGFyaXR5IHNjb3JlIGJldHdlZW4gdHdvIGltYWdlcy5cbiAqIEl0IGlzIGV4cGVjdGVkLCB0aGF0IGJvdGggaW1hZ2VzIGhhdmUgdGhlIHNhbWUgcmVzb2x1dGlvbi5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaW1nMURhdGEgVGhlIGRhdGEgb2YgdGhlIGZpcnN0IGltYWdlIHBhY2tlZCBpbnRvIGEgTm9kZUpTIGJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ9IGltZzJEYXRhIFRoZSBkYXRhIG9mIHRoZSBzZWNvbmQgaW1hZ2UgcGFja2VkIGludG8gYSBOb2RlSlMgYnVmZmVyXG4gKiBAcGFyYW0gez9TaW1pbGFyaXR5T3B0aW9uc30gb3B0aW9ucyBbe31dIFNldCBvZiBzaW1pbGFyaXR5IGNhbGN1bGF0aW9uIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7U2ltaWxhcml0eVJlc3VsdH0gVGhlIGNhbGN1bGF0aW9uIHJlc3VsdFxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBnaXZlbiBpbWFnZXMgaGF2ZSBkaWZmZXJlbnQgcmVzb2x1dGlvbi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0SW1hZ2VzU2ltaWxhcml0eSAoaW1nMURhdGEsIGltZzJEYXRhLCBvcHRpb25zID0ge30pIHtcbiAgaW5pdE9wZW5DVigpO1xuXG4gIGNvbnN0IHt2aXN1YWxpemUgPSBmYWxzZX0gPSBvcHRpb25zO1xuICBsZXQgW3RlbXBsYXRlLCByZWZlcmVuY2VdID0gYXdhaXQgQi5hbGwoW1xuICAgIGN2LmltZGVjb2RlQXN5bmMoaW1nMURhdGEpLFxuICAgIGN2LmltZGVjb2RlQXN5bmMoaW1nMkRhdGEpXG4gIF0pO1xuICBpZiAodGVtcGxhdGUucm93cyAhPT0gcmVmZXJlbmNlLnJvd3MgfHwgdGVtcGxhdGUuY29scyAhPT0gcmVmZXJlbmNlLmNvbHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggaW1hZ2VzIGFyZSBleHBlY3RlZCB0byBoYXZlIHRoZSBzYW1lIHNpemUgaW4gb3JkZXIgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICdjYWxjdWxhdGUgdGhlIHNpbWlsYXJpdHkgc2NvcmUuJyk7XG4gIH1cbiAgW3RlbXBsYXRlLCByZWZlcmVuY2VdID0gYXdhaXQgQi5hbGwoW1xuICAgIHRlbXBsYXRlLmNvbnZlcnRUb0FzeW5jKGN2LkNWXzhVQzMpLFxuICAgIHJlZmVyZW5jZS5jb252ZXJ0VG9Bc3luYyhjdi5DVl84VUMzKVxuICBdKTtcblxuICBjb25zdCBtYXRjaGVkID0gYXdhaXQgcmVmZXJlbmNlLm1hdGNoVGVtcGxhdGVBc3luYyh0ZW1wbGF0ZSwgY3YuVE1fQ0NPRUZGX05PUk1FRCk7XG4gIGNvbnN0IG1pbk1heCA9IGF3YWl0IG1hdGNoZWQubWluTWF4TG9jQXN5bmMoKTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHNjb3JlOiBtaW5NYXgubWF4VmFsXG4gIH07XG4gIGlmICh2aXN1YWxpemUpIHtcbiAgICBjb25zdCByZXN1bHRNYXQgPSBuZXcgY3YuTWF0KHRlbXBsYXRlLnJvd3MsIHRlbXBsYXRlLmNvbHMgKiAyLCBjdi5DVl84VUMzKTtcbiAgICBhd2FpdCBCLmFsbChbXG4gICAgICByZWZlcmVuY2UuY29weVRvQXN5bmMoXG4gICAgICAgIHJlc3VsdE1hdC5nZXRSZWdpb24obmV3IGN2LlJlY3QoMCwgMCwgcmVmZXJlbmNlLmNvbHMsIHJlZmVyZW5jZS5yb3dzKSkpLFxuICAgICAgdGVtcGxhdGUuY29weVRvQXN5bmMoXG4gICAgICAgIHJlc3VsdE1hdC5nZXRSZWdpb24obmV3IGN2LlJlY3QocmVmZXJlbmNlLmNvbHMsIDAsIHRlbXBsYXRlLmNvbHMsIHRlbXBsYXRlLnJvd3MpKSlcbiAgICBdKTtcbiAgICBsZXQgbWFzayA9IHJlZmVyZW5jZS5hYnNkaWZmKHRlbXBsYXRlKTtcbiAgICBtYXNrID0gYXdhaXQgbWFzay5jdnRDb2xvckFzeW5jKGN2LkNPTE9SX0JHUjJHUkFZKTtcbiAgICBsZXQgY29udG91cnMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgbWFzayA9IGF3YWl0IG1hc2sudGhyZXNob2xkQXN5bmMoMTI4LCAyNTUsIGN2LlRIUkVTSF9CSU5BUlkgfCBjdi5USFJFU0hfT1RTVSk7XG4gICAgICBjb250b3VycyA9IGF3YWl0IG1hc2suZmluZENvbnRvdXJzQXN5bmMoY3YuUkVUUl9FWFRFUk5BTCwgY3YuQ0hBSU5fQVBQUk9YX1NJTVBMRSk7XG4gICAgfSBjYXRjaCAoaWduKSB7XG4gICAgICAvLyBObyBjb250b3VycyBjYW4gYmUgZm91bmQsIHdoaWNoIG1lYW5zLCBtb3N0IGxpa2VseSwgdGhhdCBpbWFnZXMgYXJlIGVxdWFsXG4gICAgfVxuICAgIGZvciAoY29uc3QgY29udG91ciBvZiBjb250b3Vycykge1xuICAgICAgY29uc3QgYm91bmRpbmdSZWN0ID0gY29udG91ci5ib3VuZGluZ1JlY3QoKTtcbiAgICAgIGhpZ2hsaWdodFJlZ2lvbihyZXN1bHRNYXQsIGJvdW5kaW5nUmVjdCk7XG4gICAgICBoaWdobGlnaHRSZWdpb24ocmVzdWx0TWF0LCB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS5jb2xzICsgYm91bmRpbmdSZWN0LngsXG4gICAgICAgIHk6IGJvdW5kaW5nUmVjdC55LFxuICAgICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXN1bHQudmlzdWFsaXphdGlvbiA9IGF3YWl0IGN2LmltZW5jb2RlQXN5bmMoJy5wbmcnLCByZXN1bHRNYXQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT2NjdXJyZW5jZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IHZpc3VhbGl6ZSBbZmFsc2VdIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSByZXN1bHRpbmcgdmlzYWxpemF0aW9uXG4gKiBhcyBhbiBpbWFnZSAodXNlZnVsIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpXG4gKiBAcHJvcGVydHkgez9mbG9hdH0gdGhyZXNob2xkIFswLjVdIEF0IHdoYXQgbm9ybWFsaXplZCB0aHJlc2hvbGQgdG8gcmVqZWN0XG4gKiBhIG1hdGNoXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPY2N1cnJlbmNlUmVzdWx0XG4gKiBAcHJvcGVydHkge1JlY3R9IHJlY3QgVGhlIHJlZ2lvbiBvZiB0aGUgcGFydGlhbCBpbWFnZSBvY2N1cmVuY2VcbiAqIG9uIHRoZSBmdWxsIGltYWdlXG4gKiBAcHJvcGVydHkgez9CdWZmZXJ9IHZpc3VhbGl6YXRpb24gVGhlIHZpc3VhbGl6YXRpb24gb2YgdGhlIG1hdGNoaW5nIHJlc3VsdFxuICogcmVwcmVzZW50ZWQgYXMgUE5HIGltYWdlIGJ1ZmZlci4gT24gdGhpcyBpbWFnZSB0aGUgbWF0Y2hpbmdcbiAqIHJlZ2lvbiBpcyBoaWdobGlnaHRlZCB3aXRoIGEgcmVjdGFuZ2xlLlxuICovXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgb2NjdXJlbmNlIHBvc2l0aW9uIG9mIGEgcGFydGlhbCBpbWFnZSBpbiB0aGUgZnVsbFxuICogaW1hZ2UuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGZ1bGxJbWdEYXRhIFRoZSBkYXRhIG9mIHRoZSBmdWxsIGltYWdlIHBhY2tlZCBpbnRvIGEgTm9kZUpTIGJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ9IHBhcnRpYWxJbWdEYXRhIFRoZSBkYXRhIG9mIHRoZSBwYXJ0aWFsIGltYWdlIHBhY2tlZCBpbnRvIGEgTm9kZUpTIGJ1ZmZlclxuICogQHBhcmFtIHs/T2NjdXJyZW5jZU9wdGlvbnN9IG9wdGlvbnMgW3t9XSBTZXQgb2Ygb2NjdXJyZW5jZSBjYWxjdWxhdGlvbiBvcHRpb25zXG4gKlxuICogQHJldHVybnMge09jY3VycmVuY2VSZXN1bHR9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgbm8gb2NjdXJlbmNlcyBvZiB0aGUgcGFydGlhbCBpbWFnZSBjYW4gYmUgZm91bmQgaW4gdGhlIGZ1bGwgaW1hZ2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0SW1hZ2VPY2N1cnJlbmNlIChmdWxsSW1nRGF0YSwgcGFydGlhbEltZ0RhdGEsIG9wdGlvbnMgPSB7fSkge1xuICBpbml0T3BlbkNWKCk7XG5cbiAgY29uc3Qge3Zpc3VhbGl6ZSA9IGZhbHNlLCB0aHJlc2hvbGQgPSBERUZBVUxUX01BVENIX1RIUkVTSE9MRH0gPSBvcHRpb25zO1xuICBjb25zdCBbZnVsbEltZywgcGFydGlhbEltZ10gPSBhd2FpdCBCLmFsbChbXG4gICAgY3YuaW1kZWNvZGVBc3luYyhmdWxsSW1nRGF0YSksXG4gICAgY3YuaW1kZWNvZGVBc3luYyhwYXJ0aWFsSW1nRGF0YSlcbiAgXSk7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICB0cnkge1xuICAgIGNvbnN0IG1hdGNoZWQgPSBhd2FpdCBmdWxsSW1nLm1hdGNoVGVtcGxhdGVBc3luYyhwYXJ0aWFsSW1nLCBjdi5UTV9DQ09FRkZfTk9STUVEKTtcbiAgICBjb25zdCBtaW5NYXggPSBhd2FpdCBtYXRjaGVkLm1pbk1heExvY0FzeW5jKCk7XG4gICAgaWYgKG1pbk1heC5tYXhWYWwgPCB0aHJlc2hvbGQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgYW55IG9jY3VycmVuY2VzIG9mIHRoZSBwYXJ0aWFsIGltYWdlIGluIHRoZSBmdWxsIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBpbWFnZSBhYm92ZSB0aGUgdGhyZXNob2xkIG9mICR7dGhyZXNob2xkfS4gSGlnaGVzdCBtYXRjaCB2YWx1ZSBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgZm91bmQgd2FzICR7bWluTWF4Lm1heFZhbH1gKTtcbiAgICB9XG4gICAgcmVzdWx0LnJlY3QgPSB7XG4gICAgICB4OiBtaW5NYXgubWF4TG9jLngsXG4gICAgICB5OiBtaW5NYXgubWF4TG9jLnksXG4gICAgICB3aWR0aDogcGFydGlhbEltZy5jb2xzLFxuICAgICAgaGVpZ2h0OiBwYXJ0aWFsSW1nLnJvd3NcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBhbnkgb2NjdXJlbmNlcyBvZiB0aGUgcGFydGlhbCBpbWFnZSBpbiB0aGUgZnVsbCBpbWFnZS4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlfWApO1xuICB9XG4gIGlmICh2aXN1YWxpemUpIHtcbiAgICBoaWdobGlnaHRSZWdpb24oZnVsbEltZywgcmVzdWx0LnJlY3QpO1xuICAgIHJlc3VsdC52aXN1YWxpemF0aW9uID0gYXdhaXQgY3YuaW1lbmNvZGVBc3luYygnLnBuZycsIGZ1bGxJbWcpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JvcCB0aGUgaW1hZ2UgYnkgZ2l2ZW4gcmVjdGFuZ2xlICh1c2UgYmFzZTY0IHN0cmluZyBhcyBpbnB1dCBhbmQgb3V0cHV0KVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRJbWFnZSBUaGUgc3RyaW5nIHdpdGggYmFzZTY0IGVuY29kZWQgaW1hZ2VcbiAqIEBwYXJhbSB7UmVnaW9ufSByZWN0IFRoZSBzZWxlY3RlZCByZWdpb24gb2YgaW1hZ2VcbiAqIEByZXR1cm4ge3N0cmluZ30gYmFzZTY0IGVuY29kZWQgc3RyaW5nIG9mIGNyb3BwZWQgaW1hZ2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JvcEJhc2U2NEltYWdlIChiYXNlNjRJbWFnZSwgcmVjdCkge1xuICBjb25zdCBpbWFnZSA9IGF3YWl0IGJhc2U2NFRvSW1hZ2UoYmFzZTY0SW1hZ2UpO1xuICBjcm9wSW1hZ2UoaW1hZ2UsIHJlY3QpO1xuICByZXR1cm4gYXdhaXQgaW1hZ2VUb0Jhc2U2NChpbWFnZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcG5nanMgaW1hZ2UgZnJvbSBnaXZlbiBiYXNlNjQgaW1hZ2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0SW1hZ2UgVGhlIHN0cmluZyB3aXRoIGJhc2U2NCBlbmNvZGVkIGltYWdlXG4gKiBAcmV0dXJuIHtQTkd9IFRoZSBpbWFnZSBvYmplY3RcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYmFzZTY0VG9JbWFnZSAoYmFzZTY0SW1hZ2UpIHtcbiAgY29uc3QgaW1hZ2VCdWZmZXIgPSBCdWZmZXIuZnJvbShiYXNlNjRJbWFnZSwgJ2Jhc2U2NCcpO1xuICByZXR1cm4gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGltYWdlID0gbmV3IFBORyh7ZmlsdGVyVHlwZTogU0NBTkxJTkVfRklMVEVSX01FVEhPRH0pO1xuICAgIGltYWdlLnBhcnNlKGltYWdlQnVmZmVyLCAoZXJyLCBpbWFnZSkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByb21pc2UvcHJlZmVyLWF3YWl0LXRvLWNhbGxiYWNrc1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKGltYWdlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYmFzZTY0IHN0cmluZyBmb3IgZ2l2ZW4gaW1hZ2Ugb2JqZWN0XG4gKlxuICogQHBhcmFtIHtQTkd9IGltYWdlIFRoZSBpbWFnZSBvYmplY3RcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZyB3aXRoIGJhc2U2NCBlbmNvZGVkIGltYWdlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGltYWdlVG9CYXNlNjQgKGltYWdlKSB7XG4gIHJldHVybiBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgaW1hZ2UucGFjaygpXG4gICAgLm9uKCdkYXRhJywgKGNodW5rKSA9PiBjaHVua3MucHVzaChjaHVuaykpLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICByZXNvbHZlKEJ1ZmZlci5jb25jYXQoY2h1bmtzKS50b1N0cmluZygnYmFzZTY0JykpO1xuICAgIH0pXG4gICAgLm9uKCdlcnJvcicsIChlcnIpID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by1jYWxsYmFja3NcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcm9wIHRoZSBpbWFnZSBieSBnaXZlbiByZWN0YW5nbGVcbiAqXG4gKiBAcGFyYW0ge1BOR30gaW1hZ2UgVGhlIGltYWdlIHRvIG11dGF0ZSBieSBjcm9wcGluZ1xuICogQHBhcmFtIHtSZWdpb259IHJlY3QgVGhlIHNlbGVjdGVkIHJlZ2lvbiBvZiBpbWFnZVxuICovXG5mdW5jdGlvbiBjcm9wSW1hZ2UgKGltYWdlLCByZWN0KSB7XG4gIGNvbnN0IGltYWdlUmVjdCA9IHt3aWR0aDogaW1hZ2Uud2lkdGgsIGhlaWdodDogaW1hZ2UuaGVpZ2h0fTtcbiAgY29uc3QgaW50ZXJSZWN0ID0gZ2V0UmVjdEludGVyc2VjdGlvbihyZWN0LCBpbWFnZVJlY3QpO1xuICBpZiAoaW50ZXJSZWN0LndpZHRoIDwgcmVjdC53aWR0aCB8fCBpbnRlclJlY3QuaGVpZ2h0IDwgcmVjdC5oZWlnaHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjcm9wICR7SlNPTi5zdHJpbmdpZnkocmVjdCl9IGZyb20gJHtKU09OLnN0cmluZ2lmeShpbWFnZVJlY3QpfSBiZWNhdXNlIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGVtIHdhcyBub3QgdGhlIHNpemUgb2YgdGhlIHJlY3RgKTtcbiAgfVxuXG4gIGNvbnN0IGZpcnN0VmVydGljYWxQaXhlbCA9IGludGVyUmVjdC50b3A7XG4gIGNvbnN0IGxhc3RWZXJ0aWNhbFBpeGVsID0gaW50ZXJSZWN0LnRvcCArIGludGVyUmVjdC5oZWlnaHQ7XG5cbiAgY29uc3QgZmlyc3RIb3Jpem9udGFsUGl4ZWwgPSBpbnRlclJlY3QubGVmdDtcbiAgY29uc3QgbGFzdEhvcml6b250YWxQaXhlbCA9IGludGVyUmVjdC5sZWZ0ICsgaW50ZXJSZWN0LndpZHRoO1xuXG4gIGNvbnN0IGNyb3BwZWRBcnJheSA9IFtdO1xuICBmb3IgKGxldCB5ID0gZmlyc3RWZXJ0aWNhbFBpeGVsOyB5IDwgbGFzdFZlcnRpY2FsUGl4ZWw7IHkrKykge1xuICAgIGZvciAobGV0IHggPSBmaXJzdEhvcml6b250YWxQaXhlbDsgeCA8IGxhc3RIb3Jpem9udGFsUGl4ZWw7IHgrKykge1xuICAgICAgY29uc3QgZmlyc3RCeXRlSWR4SW5QaXhlbEJsb2NrID0gKGltYWdlUmVjdC53aWR0aCAqIHkgKyB4KSA8PCAyO1xuICAgICAgZm9yIChsZXQgYnl0ZUlkeCA9IDA7IGJ5dGVJZHggPCBCWVRFU19JTl9QSVhFTF9CTE9DSzsgYnl0ZUlkeCsrKSB7XG4gICAgICAgIGNyb3BwZWRBcnJheS5wdXNoKGltYWdlLmRhdGFbZmlyc3RCeXRlSWR4SW5QaXhlbEJsb2NrICsgYnl0ZUlkeF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGltYWdlLmRhdGEgPSBCdWZmZXIuZnJvbShjcm9wcGVkQXJyYXkpO1xuICBpbWFnZS53aWR0aCA9IGludGVyUmVjdC53aWR0aDtcbiAgaW1hZ2UuaGVpZ2h0ID0gaW50ZXJSZWN0LmhlaWdodDtcbiAgcmV0dXJuIGltYWdlO1xufVxuXG5mdW5jdGlvbiBnZXRSZWN0SW50ZXJzZWN0aW9uIChyZWN0LCBpbWFnZVNpemUpIHtcbiAgY29uc3QgbGVmdCA9IHJlY3QubGVmdCA+PSBpbWFnZVNpemUud2lkdGggPyBpbWFnZVNpemUud2lkdGggOiByZWN0LmxlZnQ7XG4gIGNvbnN0IHRvcCA9IHJlY3QudG9wID49IGltYWdlU2l6ZS5oZWlnaHQgPyBpbWFnZVNpemUuaGVpZ2h0IDogcmVjdC50b3A7XG4gIGNvbnN0IHdpZHRoID0gaW1hZ2VTaXplLndpZHRoID49IChsZWZ0ICsgcmVjdC53aWR0aCkgPyByZWN0LndpZHRoIDogKGltYWdlU2l6ZS53aWR0aCAtIGxlZnQpO1xuICBjb25zdCBoZWlnaHQgPSBpbWFnZVNpemUuaGVpZ2h0ID49ICh0b3AgKyByZWN0LmhlaWdodCkgPyByZWN0LmhlaWdodCA6IChpbWFnZVNpemUuaGVpZ2h0IC0gdG9wKTtcbiAgcmV0dXJuIHtsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHR9O1xufVxuXG5leHBvcnQgeyBjcm9wQmFzZTY0SW1hZ2UsIGJhc2U2NFRvSW1hZ2UsIGltYWdlVG9CYXNlNjQsIGNyb3BJbWFnZSxcbiAgICAgICAgIGdldEltYWdlc01hdGNoZXMsIGdldEltYWdlc1NpbWlsYXJpdHksIGdldEltYWdlT2NjdXJyZW5jZSxcbiAgICAgICAgIGdldEppbXBJbWFnZSwgTUlNRV9KUEVHLCBNSU1FX1BORywgTUlNRV9CTVAgfTtcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
