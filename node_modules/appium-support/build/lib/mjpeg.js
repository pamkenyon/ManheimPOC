'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _request = require('request');

var _request2 = _interopRequireDefault(_request);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _imageUtil = require('./image-util');

var _mjpegConsumer = require('mjpeg-consumer');

var _mjpegConsumer2 = _interopRequireDefault(_mjpegConsumer);

var _mjpegServer = require('mjpeg-server');

var _mjpegServer2 = _interopRequireDefault(_mjpegServer);

var _stream = require('stream');

var TEST_IMG_JPG = '/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAeAAD/4QOBaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzE0MCA3OS4xNjA0NTEsIDIwMTcvMDUvMDYtMDE6MDg6MjEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6NGY5ODc1OTctZGE2My00Y2M0LTkzNDMtNGYyNjgzMGUwNjk3IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjlDMzI3QkY0N0Q3NTExRThCMTlDOTVDMDc2RDE5MDY5IiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjlDMzI3QkYzN0Q3NTExRThCMTlDOTVDMDc2RDE5MDY5IiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE4IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NGY5ODc1OTctZGE2My00Y2M0LTkzNDMtNGYyNjgzMGUwNjk3IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjRmOTg3NTk3LWRhNjMtNGNjNC05MzQzLTRmMjY4MzBlMDY5NyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEABALCwsMCxAMDBAXDw0PFxsUEBAUGx8XFxcXFx8eFxoaGhoXHh4jJSclIx4vLzMzLy9AQEBAQEBAQEBAQEBAQEABEQ8PERMRFRISFRQRFBEUGhQWFhQaJhoaHBoaJjAjHh4eHiMwKy4nJycuKzU1MDA1NUBAP0BAQEBAQEBAQEBAQP/AABEIACAAIAMBIgACEQEDEQH/xABgAAEAAwEAAAAAAAAAAAAAAAAABAUHCAEBAAAAAAAAAAAAAAAAAAAAABAAAQMCAgsAAAAAAAAAAAAAAAECBBEDEgYhMRODo7PTVAUWNhEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8Az8AAdAAAAAAI8+fE8dEuTZtzZR7VMb6OdTE5GJoYirrUp/e8qd9wb3TGe/lJ2551sx8D/9k=';

// amount of time to wait for the first image in the stream
var MJPEG_SERVER_TIMEOUT_MS = 10000;

/** Class which stores the last bit of data streamed into it */

var MJpegStream = (function (_Writable) {
  _inherits(MJpegStream, _Writable);

  /**
   * Create an MJpegStream
   * @param {string} mJpegUrl - URL of MJPEG-over-HTTP stream
   * @param {function} [errorHandler=noop] - additional function that will be
   * called in the case of any errors.
   * @param {object} [options={}] - Options to pass to the Writable constructor
   */

  function MJpegStream(mJpegUrl) {
    var errorHandler = arguments.length <= 1 || arguments[1] === undefined ? _lodash2['default'].noop : arguments[1];
    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, MJpegStream);

    _get(Object.getPrototypeOf(MJpegStream.prototype), 'constructor', this).call(this, options);
    this.errorHandler = errorHandler;
    this.url = mJpegUrl;
    this.clear();
  }

  /**
   * Start an mjpeg server for the purpose of testing, which just sends the same
   * image over and over. Caller is responsible for closing the server.
   * @param {int} port - port the server should listen on
   * @param {int} [intMs] - how often the server should push an image
   * @param {int} [times] - how many times the server should push an image before
   * it closes the connection
   * @returns {http.Server}
   */

  /**
   * Get the base64-encoded version of the JPEG
   * @returns {string}
   */

  _createClass(MJpegStream, [{
    key: 'lastChunkPNG',

    /**
     * Get the PNG version of the JPEG buffer
     * @returns {Buffer} PNG image data
     */
    value: function lastChunkPNG() {
      var jpg;
      return _regeneratorRuntime.async(function lastChunkPNG$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (_lodash2['default'].isBuffer(this.lastChunk)) {
              context$2$0.next = 2;
              break;
            }

            return context$2$0.abrupt('return', null);

          case 2:
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap((0, _imageUtil.getJimpImage)(this.lastChunk));

          case 4:
            jpg = context$2$0.sent;
            context$2$0.next = 7;
            return _regeneratorRuntime.awrap(jpg.getBuffer(_imageUtil.MIME_PNG));

          case 7:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 8:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Get the base64-encoded version of the PNG
     * @returns {string}
     */
  }, {
    key: 'lastChunkPNGBase64',
    value: function lastChunkPNGBase64() {
      var png;
      return _regeneratorRuntime.async(function lastChunkPNGBase64$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.lastChunkPNG());

          case 2:
            png = context$2$0.sent;

            if (png) {
              context$2$0.next = 5;
              break;
            }

            return context$2$0.abrupt('return', null);

          case 5:
            return context$2$0.abrupt('return', png.toString('base64'));

          case 6:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Reset internal state
     */
  }, {
    key: 'clear',
    value: function clear() {
      this.registerStartSuccess = null;
      this.registerStartFailure = null;
      this.request = null;
      this.consumer = null;
      this.lastChunk = null;
      this.updateCount = 0;
    }

    /**
     * Start reading the MJpeg stream and storing the last image
     */
  }, {
    key: 'start',
    value: function start() {
      var serverTimeout = arguments.length <= 0 || arguments[0] === undefined ? MJPEG_SERVER_TIMEOUT_MS : arguments[0];
      var startPromise, onErr;
      return _regeneratorRuntime.async(function start$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            // ensure we're not started already
            this.stop();

            this.consumer = new _mjpegConsumer2['default']();

            // use the deferred pattern so we can wait for the start of the stream
            // based on what comes in from an external pipe
            startPromise = new _bluebird2['default'](function (res, rej) {
              _this.registerStartSuccess = res;
              _this.registerStartFailure = rej;
            })
            // start a timeout so that if the server does not return data, we don't
            // block forever.
            .timeout(serverTimeout, 'Waited ' + serverTimeout + 'ms but the MJPEG server never sent any images');

            onErr = function onErr(err) {
              _logger2['default'].error('Error getting MJpeg screenshot chunk: ' + err);
              _this.errorHandler(err);
              if (_this.registerStartFailure) {
                _this.registerStartFailure(err);
              }
            };

            this.request = (0, _request2['default'])(this.url);

            this.request.on('error', onErr) // ensure we do something with errors
            .pipe(this.consumer) // allow chunking and transforming of jpeg data
            .pipe(this); // send the actual jpegs to ourself

            context$2$0.next = 8;
            return _regeneratorRuntime.awrap(startPromise);

          case 8:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Stop reading the MJpeg stream. Ensure we disconnect all the pipes and stop
     * the HTTP request itself. Then reset the state.
     */
  }, {
    key: 'stop',
    value: function stop() {
      if (!this.consumer) {
        return;
      }

      this.consumer.unpipe();
      this.request.end();
      this.clear();
    }

    /**
     * Override the Writable write() method in order to save the last image and
     * log the number of images we have received
     * @override
     * @param {Buffer} data - binary data streamed from the MJpeg consumer
     */
  }, {
    key: 'write',
    value: function write(data) {
      this.lastChunk = data;
      this.updateCount++;

      if (this.registerStartSuccess) {
        this.registerStartSuccess();
        this.registerStartSuccess = null;
      }
    }
  }, {
    key: 'lastChunkBase64',
    get: function get() {
      return _lodash2['default'].isBuffer(this.lastChunk) ? this.lastChunk.toString('base64') : null;
    }
  }]);

  return MJpegStream;
})(_stream.Writable);

function initMJpegServer(port) {
  var intMs = arguments.length <= 1 || arguments[1] === undefined ? 300 : arguments[1];
  var times = arguments.length <= 2 || arguments[2] === undefined ? 20 : arguments[2];

  var server = _http2['default'].createServer(function callee$1$0(req, res) {
    var mJpegReqHandler, jpg, i;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          mJpegReqHandler = _mjpegServer2['default'].createReqHandler(req, res);
          jpg = Buffer.from(TEST_IMG_JPG, 'base64');
          i = 0;

        case 3:
          if (!(i < times)) {
            context$2$0.next = 10;
            break;
          }

          context$2$0.next = 6;
          return _regeneratorRuntime.awrap(_bluebird2['default'].delay(intMs));

        case 6:
          mJpegReqHandler._write(jpg, null, _lodash2['default'].noop);

        case 7:
          i++;
          context$2$0.next = 3;
          break;

        case 10:
          mJpegReqHandler.close();

        case 11:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  }).listen(port);

  return server;
}

exports.MJpegStream = MJpegStream;
exports.initMJpegServer = initMJpegServer;
exports.TEST_IMG_JPG = TEST_IMG_JPG;

// just send the same jpeg over and over
//# sourceMappingURL=data:application/json;charset=utf8;base64,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LENBQUE7Ozs7OzsyQ0FDakIsc0JBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQzs7O0FBQ3BCLHlCQUFlLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsb0JBQUUsSUFBSSxDQUFDLENBQUM7OztBQUZqQixXQUFDLEVBQUU7Ozs7O0FBSTlCLHlCQUFlLENBQUMsS0FBSyxFQUFFLENBQUM7Ozs7Ozs7R0FDekIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFFaEIsU0FBTyxNQUFNLENBQUM7Q0FDZjs7UUFFUSxXQUFXLEdBQVgsV0FBVztRQUFFLGVBQWUsR0FBZixlQUFlO1FBQUUsWUFBWSxHQUFaLFlBQVkiLCJmaWxlIjoibGliL21qcGVnLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCByZXF1ZXN0IGZyb20gJ3JlcXVlc3QnO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgaHR0cCBmcm9tICdodHRwJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IGdldEppbXBJbWFnZSwgTUlNRV9QTkcgfSBmcm9tICcuL2ltYWdlLXV0aWwnO1xuaW1wb3J0IE1KcGVnQ29uc3VtZXIgZnJvbSAnbWpwZWctY29uc3VtZXInO1xuaW1wb3J0IG1KcGVnU2VydmVyIGZyb20gJ21qcGVnLXNlcnZlcic7XG5pbXBvcnQgeyBXcml0YWJsZSB9IGZyb20gJ3N0cmVhbSc7XG5cbmNvbnN0IFRFU1RfSU1HX0pQRyA9ICcvOWovNFFBWVJYaHBaZ0FBU1VrcUFBZ0FBQUFBQUFBQUFBQUFBUC9zQUJGRWRXTnJlUUFCQUFRQUFBQWVBQUQvNFFPQmFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0x3QThQM2h3WVdOclpYUWdZbVZuYVc0OUl1Kzd2eUlnYVdROUlsYzFUVEJOY0VObGFHbEllbkpsVTNwT1ZHTjZhMk01WkNJL1BpQThlRHA0YlhCdFpYUmhJSGh0Ykc1ek9uZzlJbUZrYjJKbE9tNXpPbTFsZEdFdklpQjRPbmh0Y0hSclBTSkJaRzlpWlNCWVRWQWdRMjl5WlNBMUxqWXRZekUwTUNBM09TNHhOakEwTlRFc0lESXdNVGN2TURVdk1EWXRNREU2TURnNk1qRWdJQ0FnSUNBZ0lDSStJRHh5WkdZNlVrUkdJSGh0Ykc1ek9uSmtaajBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TVRrNU9TOHdNaTh5TWkxeVpHWXRjM2x1ZEdGNExXNXpJeUkrSUR4eVpHWTZSR1Z6WTNKcGNIUnBiMjRnY21SbU9tRmliM1YwUFNJaUlIaHRiRzV6T25odGNFMU5QU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2YlcwdklpQjRiV3h1Y3pwemRGSmxaajBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDNOVWVYQmxMMUpsYzI5MWNtTmxVbVZtSXlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0YlhCTlRUcFBjbWxuYVc1aGJFUnZZM1Z0Wlc1MFNVUTlJbmh0Y0M1a2FXUTZOR1k1T0RjMU9UY3RaR0UyTXkwMFkyTTBMVGt6TkRNdE5HWXlOamd6TUdVd05qazNJaUI0YlhCTlRUcEViMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPamxETXpJM1FrWTBOMFEzTlRFeFJUaENNVGxET1RWRE1EYzJSREU1TURZNUlpQjRiWEJOVFRwSmJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qbERNekkzUWtZek4wUTNOVEV4UlRoQ01UbERPVFZETURjMlJERTVNRFk1SWlCNGJYQTZRM0psWVhSdmNsUnZiMnc5SWtGa2IySmxJRkJvYjNSdmMyaHZjQ0JEUXlBeU1ERTRJQ2hOWVdOcGJuUnZjMmdwSWo0Z1BIaHRjRTFOT2tSbGNtbDJaV1JHY205dElITjBVbVZtT21sdWMzUmhibU5sU1VROUluaHRjQzVwYVdRNk5HWTVPRGMxT1RjdFpHRTJNeTAwWTJNMExUa3pORE10TkdZeU5qZ3pNR1V3TmprM0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qUm1PVGczTlRrM0xXUmhOak10TkdOak5DMDVNelF6TFRSbU1qWTRNekJsTURZNU55SXZQaUE4TDNKa1pqcEVaWE5qY21sd2RHbHZiajRnUEM5eVpHWTZVa1JHUGlBOEwzZzZlRzF3YldWMFlUNGdQRDk0Y0dGamEyVjBJR1Z1WkQwaWNpSS9Qdi91QUE1QlpHOWlaUUJrd0FBQUFBSC8yd0NFQUJBTEN3c01DeEFNREJBWER3MFBGeHNVRUJBVUd4OFhGeGNYRng4ZUZ4b2FHaG9YSGg0akpTY2xJeDR2THpNekx5OUFRRUJBUUVCQVFFQkFRRUJBUUVBQkVROFBFUk1SRlJJU0ZSUVJGQkVVR2hRV0ZoUWFKaG9hSEJvYUpqQWpIaDRlSGlNd0t5NG5KeWN1S3pVMU1EQTFOVUJBUDBCQVFFQkFRRUJBUUVCQVFQL0FBQkVJQUNBQUlBTUJJZ0FDRVFFREVRSC94QUJnQUFFQUF3RUFBQUFBQUFBQUFBQUFBQUFBQkFVSENBRUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBUU1DQWdzQUFBQUFBQUFBQUFBQUFBRUNCQkVERWdZaE1ST0RvN1BUVkFVV05oRUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFQL2FBQXdEQVFBQ0VRTVJBRDhBejhBQWRBQUFBQUFJOCtmRThkRXVUWnR6WlI3Vk1iNk9kVEU1R0pvWWlyclVwL2U4cWQ5d2IzVEdlL2xKMjU1MXN4OEQvOWs9JztcblxuLy8gYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBmb3IgdGhlIGZpcnN0IGltYWdlIGluIHRoZSBzdHJlYW1cbmNvbnN0IE1KUEVHX1NFUlZFUl9USU1FT1VUX01TID0gMTAwMDA7XG5cbi8qKiBDbGFzcyB3aGljaCBzdG9yZXMgdGhlIGxhc3QgYml0IG9mIGRhdGEgc3RyZWFtZWQgaW50byBpdCAqL1xuY2xhc3MgTUpwZWdTdHJlYW0gZXh0ZW5kcyBXcml0YWJsZSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBNSnBlZ1N0cmVhbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbUpwZWdVcmwgLSBVUkwgb2YgTUpQRUctb3Zlci1IVFRQIHN0cmVhbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZXJyb3JIYW5kbGVyPW5vb3BdIC0gYWRkaXRpb25hbCBmdW5jdGlvbiB0aGF0IHdpbGwgYmVcbiAgICogY2FsbGVkIGluIHRoZSBjYXNlIG9mIGFueSBlcnJvcnMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gLSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIFdyaXRhYmxlIGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobUpwZWdVcmwsIGVycm9ySGFuZGxlciA9IF8ubm9vcCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XG4gICAgdGhpcy51cmwgPSBtSnBlZ1VybDtcbiAgICB0aGlzLmNsZWFyKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBiYXNlNjQtZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSBKUEVHXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbGFzdENodW5rQmFzZTY0ICgpIHtcbiAgICByZXR1cm4gXy5pc0J1ZmZlcih0aGlzLmxhc3RDaHVuaykgP1xuICAgICAgdGhpcy5sYXN0Q2h1bmsudG9TdHJpbmcoJ2Jhc2U2NCcpIDpcbiAgICAgIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBQTkcgdmVyc2lvbiBvZiB0aGUgSlBFRyBidWZmZXJcbiAgICogQHJldHVybnMge0J1ZmZlcn0gUE5HIGltYWdlIGRhdGFcbiAgICovXG4gIGFzeW5jIGxhc3RDaHVua1BORyAoKSB7XG4gICAgaWYgKCFfLmlzQnVmZmVyKHRoaXMubGFzdENodW5rKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QganBnID0gYXdhaXQgZ2V0SmltcEltYWdlKHRoaXMubGFzdENodW5rKTtcbiAgICByZXR1cm4gYXdhaXQganBnLmdldEJ1ZmZlcihNSU1FX1BORyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBiYXNlNjQtZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSBQTkdcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGFzeW5jIGxhc3RDaHVua1BOR0Jhc2U2NCAoKSB7XG4gICAgY29uc3QgcG5nID0gYXdhaXQgdGhpcy5sYXN0Q2h1bmtQTkcoKTtcblxuICAgIGlmICghcG5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcG5nLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBpbnRlcm5hbCBzdGF0ZVxuICAgKi9cbiAgY2xlYXIgKCkge1xuICAgIHRoaXMucmVnaXN0ZXJTdGFydFN1Y2Nlc3MgPSBudWxsO1xuICAgIHRoaXMucmVnaXN0ZXJTdGFydEZhaWx1cmUgPSBudWxsO1xuICAgIHRoaXMucmVxdWVzdCA9IG51bGw7XG4gICAgdGhpcy5jb25zdW1lciA9IG51bGw7XG4gICAgdGhpcy5sYXN0Q2h1bmsgPSBudWxsO1xuICAgIHRoaXMudXBkYXRlQ291bnQgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHJlYWRpbmcgdGhlIE1KcGVnIHN0cmVhbSBhbmQgc3RvcmluZyB0aGUgbGFzdCBpbWFnZVxuICAgKi9cbiAgYXN5bmMgc3RhcnQgKHNlcnZlclRpbWVvdXQgPSBNSlBFR19TRVJWRVJfVElNRU9VVF9NUykge1xuICAgIC8vIGVuc3VyZSB3ZSdyZSBub3Qgc3RhcnRlZCBhbHJlYWR5XG4gICAgdGhpcy5zdG9wKCk7XG5cbiAgICB0aGlzLmNvbnN1bWVyID0gbmV3IE1KcGVnQ29uc3VtZXIoKTtcblxuICAgIC8vIHVzZSB0aGUgZGVmZXJyZWQgcGF0dGVybiBzbyB3ZSBjYW4gd2FpdCBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBzdHJlYW1cbiAgICAvLyBiYXNlZCBvbiB3aGF0IGNvbWVzIGluIGZyb20gYW4gZXh0ZXJuYWwgcGlwZVxuICAgIGNvbnN0IHN0YXJ0UHJvbWlzZSA9IG5ldyBCKChyZXMsIHJlaikgPT4ge1xuICAgICAgdGhpcy5yZWdpc3RlclN0YXJ0U3VjY2VzcyA9IHJlcztcbiAgICAgIHRoaXMucmVnaXN0ZXJTdGFydEZhaWx1cmUgPSByZWo7XG4gICAgfSlcbiAgICAvLyBzdGFydCBhIHRpbWVvdXQgc28gdGhhdCBpZiB0aGUgc2VydmVyIGRvZXMgbm90IHJldHVybiBkYXRhLCB3ZSBkb24ndFxuICAgIC8vIGJsb2NrIGZvcmV2ZXIuXG4gICAgICAudGltZW91dChzZXJ2ZXJUaW1lb3V0LFxuICAgICAgICBgV2FpdGVkICR7c2VydmVyVGltZW91dH1tcyBidXQgdGhlIE1KUEVHIHNlcnZlciBuZXZlciBzZW50IGFueSBpbWFnZXNgKTtcblxuICAgIGNvbnN0IG9uRXJyID0gKGVycikgPT4ge1xuICAgICAgbG9nLmVycm9yKGBFcnJvciBnZXR0aW5nIE1KcGVnIHNjcmVlbnNob3QgY2h1bms6ICR7ZXJyfWApO1xuICAgICAgdGhpcy5lcnJvckhhbmRsZXIoZXJyKTtcbiAgICAgIGlmICh0aGlzLnJlZ2lzdGVyU3RhcnRGYWlsdXJlKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJTdGFydEZhaWx1cmUoZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdCh0aGlzLnVybCk7XG5cbiAgICB0aGlzLnJlcXVlc3RcbiAgICAgIC5vbignZXJyb3InLCBvbkVycikgICAvLyBlbnN1cmUgd2UgZG8gc29tZXRoaW5nIHdpdGggZXJyb3JzXG4gICAgICAucGlwZSh0aGlzLmNvbnN1bWVyKSAgLy8gYWxsb3cgY2h1bmtpbmcgYW5kIHRyYW5zZm9ybWluZyBvZiBqcGVnIGRhdGFcbiAgICAgIC5waXBlKHRoaXMpOyAgICAgICAgICAvLyBzZW5kIHRoZSBhY3R1YWwganBlZ3MgdG8gb3Vyc2VsZlxuXG4gICAgYXdhaXQgc3RhcnRQcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgcmVhZGluZyB0aGUgTUpwZWcgc3RyZWFtLiBFbnN1cmUgd2UgZGlzY29ubmVjdCBhbGwgdGhlIHBpcGVzIGFuZCBzdG9wXG4gICAqIHRoZSBIVFRQIHJlcXVlc3QgaXRzZWxmLiBUaGVuIHJlc2V0IHRoZSBzdGF0ZS5cbiAgICovXG4gIHN0b3AgKCkge1xuICAgIGlmICghdGhpcy5jb25zdW1lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY29uc3VtZXIudW5waXBlKCk7XG4gICAgdGhpcy5yZXF1ZXN0LmVuZCgpO1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgV3JpdGFibGUgd3JpdGUoKSBtZXRob2QgaW4gb3JkZXIgdG8gc2F2ZSB0aGUgbGFzdCBpbWFnZSBhbmRcbiAgICogbG9nIHRoZSBudW1iZXIgb2YgaW1hZ2VzIHdlIGhhdmUgcmVjZWl2ZWRcbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIC0gYmluYXJ5IGRhdGEgc3RyZWFtZWQgZnJvbSB0aGUgTUpwZWcgY29uc3VtZXJcbiAgICovXG4gIHdyaXRlIChkYXRhKSB7XG4gICAgdGhpcy5sYXN0Q2h1bmsgPSBkYXRhO1xuICAgIHRoaXMudXBkYXRlQ291bnQrKztcblxuICAgIGlmICh0aGlzLnJlZ2lzdGVyU3RhcnRTdWNjZXNzKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyU3RhcnRTdWNjZXNzKCk7XG4gICAgICB0aGlzLnJlZ2lzdGVyU3RhcnRTdWNjZXNzID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTdGFydCBhbiBtanBlZyBzZXJ2ZXIgZm9yIHRoZSBwdXJwb3NlIG9mIHRlc3RpbmcsIHdoaWNoIGp1c3Qgc2VuZHMgdGhlIHNhbWVcbiAqIGltYWdlIG92ZXIgYW5kIG92ZXIuIENhbGxlciBpcyByZXNwb25zaWJsZSBmb3IgY2xvc2luZyB0aGUgc2VydmVyLlxuICogQHBhcmFtIHtpbnR9IHBvcnQgLSBwb3J0IHRoZSBzZXJ2ZXIgc2hvdWxkIGxpc3RlbiBvblxuICogQHBhcmFtIHtpbnR9IFtpbnRNc10gLSBob3cgb2Z0ZW4gdGhlIHNlcnZlciBzaG91bGQgcHVzaCBhbiBpbWFnZVxuICogQHBhcmFtIHtpbnR9IFt0aW1lc10gLSBob3cgbWFueSB0aW1lcyB0aGUgc2VydmVyIHNob3VsZCBwdXNoIGFuIGltYWdlIGJlZm9yZVxuICogaXQgY2xvc2VzIHRoZSBjb25uZWN0aW9uXG4gKiBAcmV0dXJucyB7aHR0cC5TZXJ2ZXJ9XG4gKi9cbmZ1bmN0aW9uIGluaXRNSnBlZ1NlcnZlciAocG9ydCwgaW50TXMgPSAzMDAsIHRpbWVzID0gMjApIHtcbiAgY29uc3Qgc2VydmVyID0gaHR0cC5jcmVhdGVTZXJ2ZXIoYXN5bmMgZnVuY3Rpb24gKHJlcSwgcmVzKSB7XG4gICAgY29uc3QgbUpwZWdSZXFIYW5kbGVyID0gbUpwZWdTZXJ2ZXIuY3JlYXRlUmVxSGFuZGxlcihyZXEsIHJlcyk7XG4gICAgY29uc3QganBnID0gQnVmZmVyLmZyb20oVEVTVF9JTUdfSlBHLCAnYmFzZTY0Jyk7XG5cbiAgICAvLyBqdXN0IHNlbmQgdGhlIHNhbWUganBlZyBvdmVyIGFuZCBvdmVyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lczsgaSsrKSB7XG4gICAgICBhd2FpdCBCLmRlbGF5KGludE1zKTtcbiAgICAgIG1KcGVnUmVxSGFuZGxlci5fd3JpdGUoanBnLCBudWxsLCBfLm5vb3ApO1xuICAgIH1cbiAgICBtSnBlZ1JlcUhhbmRsZXIuY2xvc2UoKTtcbiAgfSkubGlzdGVuKHBvcnQpO1xuXG4gIHJldHVybiBzZXJ2ZXI7XG59XG5cbmV4cG9ydCB7IE1KcGVnU3RyZWFtLCBpbml0TUpwZWdTZXJ2ZXIsIFRFU1RfSU1HX0pQRyB9O1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLiJ9
