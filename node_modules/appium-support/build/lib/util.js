'use strict';

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.hasContent = hasContent;

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _os = require('os');

var _os2 = _interopRequireDefault(_os);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function hasContent(val) {
  return _lodash2['default'].isString(val) && val !== "";
}

// return true if the the value is not undefined, null, or NaN.
function hasValue(val) {
  var hasVal = false;
  // avoid incorrectly evaluating `0` as false
  if (_lodash2['default'].isNumber(val)) {
    hasVal = !_lodash2['default'].isNaN(val);
  } else {
    hasVal = !_lodash2['default'].isUndefined(val) && !_lodash2['default'].isNull(val);
  }

  return hasVal;
}

// escape spaces in string, for commandline calls
function escapeSpace(str) {
  return str.split(/ /).join('\\ ');
}

function escapeSpecialChars(str, quoteEscape) {
  if (typeof str !== "string") {
    return str;
  }
  if (typeof quoteEscape === "undefined") {
    quoteEscape = false;
  }
  str = str.replace(/[\\]/g, '\\\\').replace(/[\/]/g, '\\/').replace(/[\b]/g, '\\b').replace(/[\f]/g, '\\f').replace(/[\n]/g, '\\n').replace(/[\r]/g, '\\r').replace(/[\t]/g, '\\t').replace(/[\"]/g, '\\"').replace(/\\'/g, "\\'");
  if (quoteEscape) {
    var re = new RegExp(quoteEscape, "g");
    str = str.replace(re, '\\' + quoteEscape);
  }
  return str;
}

function localIp() {
  var ip = _lodash2['default'].chain(_os2['default'].networkInterfaces()).values().flatten().filter(function (val) {
    return val.family === 'IPv4' && val.internal === false;
  }).map('address').first().value();
  return ip;
}

/*
 * Creates a promise that is cancellable, and will timeout
 * after `ms` delay
 */
function cancellableDelay(ms) {
  var timer = undefined;
  var resolve = undefined;
  var reject = undefined;

  var delay = new _bluebird2['default'].Promise(function (_resolve, _reject) {
    resolve = _resolve;
    reject = _reject;
    timer = setTimeout(function () {
      resolve();
    }, ms);
  });

  // override Bluebird's `cancel`, which does not work when using `await` on
  // a promise, since `resolve`/`reject` are never called
  delay.cancel = function () {
    clearTimeout(timer);
    reject(new _bluebird2['default'].CancellationError());
  };
  return delay;
}

function multiResolve(roots) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return roots.map(function (root) {
    return _path2['default'].resolve.apply(_path2['default'], [root].concat(args));
  });
}

/*
 * Parses an object if possible. Otherwise returns the object without parsing.
 */
function safeJsonParse(obj) {
  try {
    obj = JSON.parse(obj);
  } catch (ign) {
    // ignore: this is not json parsable
  }
  return obj;
}

/*
 * Removes the wrapper from element, if it exists.
 *   { ELEMENT: 4 } becomes 4
 */
function unwrapElement(el) {
  if (typeof el === 'object' && el.ELEMENT) {
    return el.ELEMENT;
  }
  return el;
}

/*
 * Returns object consisting of all properties in the original element
 * which were truthy given the predicate.
 * If the predicate is
 *   * missing - it will remove all properties whose values are `undefined`
 *   * a scalar - it will test all properties' values against that value
 *   * a function - it will pass each value and the original object into the function
 */
function filterObject(obj, predicate) {
  var newObj = _lodash2['default'].clone(obj);
  if (_lodash2['default'].isUndefined(predicate)) {
    // remove any element from the object whose value is undefined
    predicate = function (v) {
      return !_lodash2['default'].isUndefined(v);
    };
  } else if (!_lodash2['default'].isFunction(predicate)) {
    (function () {
      // make predicate into a function
      var valuePredicate = predicate;
      predicate = function (v) {
        return v === valuePredicate;
      };
    })();
  }
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _getIterator(_Object$keys(obj)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      if (!predicate(obj[key], obj)) {
        delete newObj[key];
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return newObj;
}

/**
 * Converts number of bytes to a readable size string.
 *
 * @param {number|string} bytes - The actual number of bytes.
 * @returns {string} The actual string representation, for example
 *                   '1.00 KB' for '1024 B'
 * @throws {Error} If bytes count cannot be converted to an integer or
 *                 if it is less than zero.
 */
function toReadableSizeString(bytes) {
  var intBytes = parseInt(bytes, 10);
  if (isNaN(intBytes) || intBytes < 0) {
    throw new Error('Cannot convert \'' + bytes + '\' to a readable size format');
  }
  if (intBytes >= 1024 * 1024 * 1024) {
    return parseFloat(intBytes / (1024 * 1024 * 1024.0)).toFixed(2) + ' GB';
  } else if (intBytes >= 1024 * 1024) {
    return parseFloat(intBytes / (1024 * 1024.0)).toFixed(2) + ' MB';
  } else if (intBytes >= 1024) {
    return parseFloat(intBytes / 1024.0).toFixed(2) + ' KB';
  }
  return intBytes + ' B';
}

exports.hasValue = hasValue;
exports.escapeSpace = escapeSpace;
exports.escapeSpecialChars = escapeSpecialChars;
exports.localIp = localIp;
exports.cancellableDelay = cancellableDelay;
exports.multiResolve = multiResolve;
exports.safeJsonParse = safeJsonParse;
exports.unwrapElement = unwrapElement;
exports.filterObject = filterObject;
exports.toReadableSizeString = toReadableSizeString;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi91dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7d0JBQWMsVUFBVTs7OztzQkFDVixRQUFROzs7O2tCQUNQLElBQUk7Ozs7b0JBQ0YsTUFBTTs7OztBQUVoQixTQUFTLFVBQVUsQ0FBRSxHQUFHLEVBQUU7QUFDL0IsU0FBTyxvQkFBRSxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxLQUFLLEVBQUUsQ0FBQztDQUN0Qzs7O0FBR0QsU0FBUyxRQUFRLENBQUUsR0FBRyxFQUFFO0FBQ3RCLE1BQUksTUFBTSxHQUFHLEtBQUssQ0FBQzs7QUFFbkIsTUFBSSxvQkFBRSxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDbkIsVUFBTSxHQUFHLENBQUMsb0JBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0dBQ3hCLE1BQU07QUFDTCxVQUFNLEdBQUcsQ0FBQyxvQkFBRSxXQUFXLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxvQkFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7R0FDaEQ7O0FBRUQsU0FBTyxNQUFNLENBQUM7Q0FDZjs7O0FBR0QsU0FBUyxXQUFXLENBQUUsR0FBRyxFQUFFO0FBQ3pCLFNBQU8sR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7Q0FDbkM7O0FBRUQsU0FBUyxrQkFBa0IsQ0FBRSxHQUFHLEVBQUUsV0FBVyxFQUFFO0FBQzdDLE1BQUksT0FBTyxHQUFHLEtBQUssUUFBUSxFQUFFO0FBQzNCLFdBQU8sR0FBRyxDQUFDO0dBQ1o7QUFDRCxNQUFJLE9BQU8sV0FBVyxLQUFLLFdBQVcsRUFBRTtBQUN0QyxlQUFXLEdBQUcsS0FBSyxDQUFDO0dBQ3JCO0FBQ0QsS0FBRyxHQUFHLEdBQUcsQ0FDRixPQUFPLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUN4QixPQUFPLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUN2QixPQUFPLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUN2QixPQUFPLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUN2QixPQUFPLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUN2QixPQUFPLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUN2QixPQUFPLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUN2QixPQUFPLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUN2QixPQUFPLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQzlCLE1BQUksV0FBVyxFQUFFO0FBQ2YsUUFBSSxFQUFFLEdBQUcsSUFBSSxNQUFNLENBQUMsV0FBVyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3RDLE9BQUcsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUUsU0FBTyxXQUFXLENBQUcsQ0FBQztHQUMzQztBQUNELFNBQU8sR0FBRyxDQUFDO0NBQ1o7O0FBRUQsU0FBUyxPQUFPLEdBQUk7QUFDbEIsTUFBSSxFQUFFLEdBQUcsb0JBQUUsS0FBSyxDQUFDLGdCQUFHLGlCQUFpQixFQUFFLENBQUMsQ0FDckMsTUFBTSxFQUFFLENBQ1IsT0FBTyxFQUFFLENBQ1QsTUFBTSxDQUFDLFVBQVUsR0FBRyxFQUFFO0FBQ3JCLFdBQVEsR0FBRyxDQUFDLE1BQU0sS0FBSyxNQUFNLElBQUksR0FBRyxDQUFDLFFBQVEsS0FBSyxLQUFLLENBQUU7R0FDMUQsQ0FBQyxDQUNELEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FDZCxLQUFLLEVBQUUsQ0FDUCxLQUFLLEVBQUUsQ0FBQztBQUNYLFNBQU8sRUFBRSxDQUFDO0NBQ1g7Ozs7OztBQU1ELFNBQVMsZ0JBQWdCLENBQUUsRUFBRSxFQUFFO0FBQzdCLE1BQUksS0FBSyxZQUFBLENBQUM7QUFDVixNQUFJLE9BQU8sWUFBQSxDQUFDO0FBQ1osTUFBSSxNQUFNLFlBQUEsQ0FBQzs7QUFFWCxNQUFNLEtBQUssR0FBRyxJQUFJLHNCQUFFLE9BQU8sQ0FBQyxVQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUs7QUFDakQsV0FBTyxHQUFHLFFBQVEsQ0FBQztBQUNuQixVQUFNLEdBQUcsT0FBTyxDQUFDO0FBQ2pCLFNBQUssR0FBRyxVQUFVLENBQUMsWUFBWTtBQUM3QixhQUFPLEVBQUUsQ0FBQztLQUNYLEVBQUUsRUFBRSxDQUFDLENBQUM7R0FDUixDQUFDLENBQUM7Ozs7QUFJSCxPQUFLLENBQUMsTUFBTSxHQUFHLFlBQVk7QUFDekIsZ0JBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNwQixVQUFNLENBQUMsSUFBSSxzQkFBRSxpQkFBaUIsRUFBRSxDQUFDLENBQUM7R0FDbkMsQ0FBQztBQUNGLFNBQU8sS0FBSyxDQUFDO0NBQ2Q7O0FBRUQsU0FBUyxZQUFZLENBQUUsS0FBSyxFQUFXO29DQUFOLElBQUk7QUFBSixRQUFJOzs7QUFDbkMsU0FBTyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQUMsSUFBSSxFQUFLO0FBQ3pCLFdBQU8sa0JBQUssT0FBTyxNQUFBLHFCQUFDLElBQUksU0FBSyxJQUFJLEVBQUMsQ0FBQztHQUNwQyxDQUFDLENBQUM7Q0FDSjs7Ozs7QUFLRCxTQUFTLGFBQWEsQ0FBRSxHQUFHLEVBQUU7QUFDM0IsTUFBSTtBQUNGLE9BQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0dBQ3ZCLENBQUMsT0FBTyxHQUFHLEVBQUU7O0dBRWI7QUFDRCxTQUFPLEdBQUcsQ0FBQztDQUNaOzs7Ozs7QUFNRCxTQUFTLGFBQWEsQ0FBRSxFQUFFLEVBQUU7QUFDMUIsTUFBSSxPQUFPLEVBQUUsS0FBSyxRQUFRLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRTtBQUN4QyxXQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUM7R0FDbkI7QUFDRCxTQUFPLEVBQUUsQ0FBQztDQUNYOzs7Ozs7Ozs7O0FBVUQsU0FBUyxZQUFZLENBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRTtBQUNyQyxNQUFJLE1BQU0sR0FBRyxvQkFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDMUIsTUFBSSxvQkFBRSxXQUFXLENBQUMsU0FBUyxDQUFDLEVBQUU7O0FBRTVCLGFBQVMsR0FBRyxVQUFDLENBQUM7YUFBSyxDQUFDLG9CQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUM7S0FBQSxDQUFDO0dBQ3RDLE1BQU0sSUFBSSxDQUFDLG9CQUFFLFVBQVUsQ0FBQyxTQUFTLENBQUMsRUFBRTs7O0FBRW5DLFVBQU0sY0FBYyxHQUFHLFNBQVMsQ0FBQztBQUNqQyxlQUFTLEdBQUcsVUFBQyxDQUFDO2VBQUssQ0FBQyxLQUFLLGNBQWM7T0FBQSxDQUFDOztHQUN6Qzs7Ozs7O0FBQ0Qsc0NBQWtCLGFBQVksR0FBRyxDQUFDLDRHQUFFO1VBQXpCLEdBQUc7O0FBQ1osVUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUU7QUFDN0IsZUFBTyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDcEI7S0FDRjs7Ozs7Ozs7Ozs7Ozs7OztBQUNELFNBQU8sTUFBTSxDQUFDO0NBQ2Y7Ozs7Ozs7Ozs7O0FBV0QsU0FBUyxvQkFBb0IsQ0FBRSxLQUFLLEVBQUU7QUFDcEMsTUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNyQyxNQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxRQUFRLEdBQUcsQ0FBQyxFQUFFO0FBQ25DLFVBQU0sSUFBSSxLQUFLLHVCQUFvQixLQUFLLGtDQUE4QixDQUFDO0dBQ3hFO0FBQ0QsTUFBSSxRQUFRLElBQUksSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEVBQUU7QUFDbEMsV0FBVSxVQUFVLENBQUMsUUFBUSxJQUFJLElBQUksR0FBRyxJQUFJLEdBQUcsTUFBTSxDQUFBLEFBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsU0FBTTtHQUN6RSxNQUFNLElBQUksUUFBUSxJQUFJLElBQUksR0FBRyxJQUFJLEVBQUU7QUFDbEMsV0FBVSxVQUFVLENBQUMsUUFBUSxJQUFJLElBQUksR0FBRyxNQUFNLENBQUEsQUFBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxTQUFNO0dBQ2xFLE1BQU0sSUFBSSxRQUFRLElBQUksSUFBSSxFQUFFO0FBQzNCLFdBQVUsVUFBVSxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFNBQU07R0FDekQ7QUFDRCxTQUFVLFFBQVEsUUFBSztDQUN4Qjs7UUFFUSxRQUFRLEdBQVIsUUFBUTtRQUFFLFdBQVcsR0FBWCxXQUFXO1FBQUUsa0JBQWtCLEdBQWxCLGtCQUFrQjtRQUFFLE9BQU8sR0FBUCxPQUFPO1FBQUUsZ0JBQWdCLEdBQWhCLGdCQUFnQjtRQUNwRSxZQUFZLEdBQVosWUFBWTtRQUFFLGFBQWEsR0FBYixhQUFhO1FBQUUsYUFBYSxHQUFiLGFBQWE7UUFBRSxZQUFZLEdBQVosWUFBWTtRQUN4RCxvQkFBb0IsR0FBcEIsb0JBQW9CIiwiZmlsZSI6ImxpYi91dGlsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBvcyBmcm9tICdvcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NvbnRlbnQgKHZhbCkge1xuICByZXR1cm4gXy5pc1N0cmluZyh2YWwpICYmIHZhbCAhPT0gXCJcIjtcbn1cblxuLy8gcmV0dXJuIHRydWUgaWYgdGhlIHRoZSB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkLCBudWxsLCBvciBOYU4uXG5mdW5jdGlvbiBoYXNWYWx1ZSAodmFsKSB7XG4gIGxldCBoYXNWYWwgPSBmYWxzZTtcbiAgLy8gYXZvaWQgaW5jb3JyZWN0bHkgZXZhbHVhdGluZyBgMGAgYXMgZmFsc2VcbiAgaWYgKF8uaXNOdW1iZXIodmFsKSkge1xuICAgIGhhc1ZhbCA9ICFfLmlzTmFOKHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgaGFzVmFsID0gIV8uaXNVbmRlZmluZWQodmFsKSAmJiAhXy5pc051bGwodmFsKTtcbiAgfVxuXG4gIHJldHVybiBoYXNWYWw7XG59XG5cbi8vIGVzY2FwZSBzcGFjZXMgaW4gc3RyaW5nLCBmb3IgY29tbWFuZGxpbmUgY2FsbHNcbmZ1bmN0aW9uIGVzY2FwZVNwYWNlIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvIC8pLmpvaW4oJ1xcXFwgJyk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVNwZWNpYWxDaGFycyAoc3RyLCBxdW90ZUVzY2FwZSkge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgaWYgKHR5cGVvZiBxdW90ZUVzY2FwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHF1b3RlRXNjYXBlID0gZmFsc2U7XG4gIH1cbiAgc3RyID0gc3RyXG4gICAgICAgIC5yZXBsYWNlKC9bXFxcXF0vZywgJ1xcXFxcXFxcJylcbiAgICAgICAgLnJlcGxhY2UoL1tcXC9dL2csICdcXFxcLycpXG4gICAgICAgIC5yZXBsYWNlKC9bXFxiXS9nLCAnXFxcXGInKVxuICAgICAgICAucmVwbGFjZSgvW1xcZl0vZywgJ1xcXFxmJylcbiAgICAgICAgLnJlcGxhY2UoL1tcXG5dL2csICdcXFxcbicpXG4gICAgICAgIC5yZXBsYWNlKC9bXFxyXS9nLCAnXFxcXHInKVxuICAgICAgICAucmVwbGFjZSgvW1xcdF0vZywgJ1xcXFx0JylcbiAgICAgICAgLnJlcGxhY2UoL1tcXFwiXS9nLCAnXFxcXFwiJylcbiAgICAgICAgLnJlcGxhY2UoL1xcXFwnL2csIFwiXFxcXCdcIik7XG4gIGlmIChxdW90ZUVzY2FwZSkge1xuICAgIGxldCByZSA9IG5ldyBSZWdFeHAocXVvdGVFc2NhcGUsIFwiZ1wiKTtcbiAgICBzdHIgPSBzdHIucmVwbGFjZShyZSwgYFxcXFwke3F1b3RlRXNjYXBlfWApO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIGxvY2FsSXAgKCkge1xuICBsZXQgaXAgPSBfLmNoYWluKG9zLm5ldHdvcmtJbnRlcmZhY2VzKCkpXG4gICAgLnZhbHVlcygpXG4gICAgLmZsYXR0ZW4oKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuICh2YWwuZmFtaWx5ID09PSAnSVB2NCcgJiYgdmFsLmludGVybmFsID09PSBmYWxzZSk7XG4gICAgfSlcbiAgICAubWFwKCdhZGRyZXNzJylcbiAgICAuZmlyc3QoKVxuICAgIC52YWx1ZSgpO1xuICByZXR1cm4gaXA7XG59XG5cbi8qXG4gKiBDcmVhdGVzIGEgcHJvbWlzZSB0aGF0IGlzIGNhbmNlbGxhYmxlLCBhbmQgd2lsbCB0aW1lb3V0XG4gKiBhZnRlciBgbXNgIGRlbGF5XG4gKi9cbmZ1bmN0aW9uIGNhbmNlbGxhYmxlRGVsYXkgKG1zKSB7XG4gIGxldCB0aW1lcjtcbiAgbGV0IHJlc29sdmU7XG4gIGxldCByZWplY3Q7XG5cbiAgY29uc3QgZGVsYXkgPSBuZXcgQi5Qcm9taXNlKChfcmVzb2x2ZSwgX3JlamVjdCkgPT4ge1xuICAgIHJlc29sdmUgPSBfcmVzb2x2ZTtcbiAgICByZWplY3QgPSBfcmVqZWN0O1xuICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSwgbXMpO1xuICB9KTtcblxuICAvLyBvdmVycmlkZSBCbHVlYmlyZCdzIGBjYW5jZWxgLCB3aGljaCBkb2VzIG5vdCB3b3JrIHdoZW4gdXNpbmcgYGF3YWl0YCBvblxuICAvLyBhIHByb21pc2UsIHNpbmNlIGByZXNvbHZlYC9gcmVqZWN0YCBhcmUgbmV2ZXIgY2FsbGVkXG4gIGRlbGF5LmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHJlamVjdChuZXcgQi5DYW5jZWxsYXRpb25FcnJvcigpKTtcbiAgfTtcbiAgcmV0dXJuIGRlbGF5O1xufVxuXG5mdW5jdGlvbiBtdWx0aVJlc29sdmUgKHJvb3RzLCAuLi5hcmdzKSB7XG4gIHJldHVybiByb290cy5tYXAoKHJvb3QpID0+IHtcbiAgICByZXR1cm4gcGF0aC5yZXNvbHZlKHJvb3QsIC4uLmFyZ3MpO1xuICB9KTtcbn1cblxuLypcbiAqIFBhcnNlcyBhbiBvYmplY3QgaWYgcG9zc2libGUuIE90aGVyd2lzZSByZXR1cm5zIHRoZSBvYmplY3Qgd2l0aG91dCBwYXJzaW5nLlxuICovXG5mdW5jdGlvbiBzYWZlSnNvblBhcnNlIChvYmopIHtcbiAgdHJ5IHtcbiAgICBvYmogPSBKU09OLnBhcnNlKG9iaik7XG4gIH0gY2F0Y2ggKGlnbikge1xuICAgIC8vIGlnbm9yZTogdGhpcyBpcyBub3QganNvbiBwYXJzYWJsZVxuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qXG4gKiBSZW1vdmVzIHRoZSB3cmFwcGVyIGZyb20gZWxlbWVudCwgaWYgaXQgZXhpc3RzLlxuICogICB7IEVMRU1FTlQ6IDQgfSBiZWNvbWVzIDRcbiAqL1xuZnVuY3Rpb24gdW53cmFwRWxlbWVudCAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ29iamVjdCcgJiYgZWwuRUxFTUVOVCkge1xuICAgIHJldHVybiBlbC5FTEVNRU5UO1xuICB9XG4gIHJldHVybiBlbDtcbn1cblxuLypcbiAqIFJldHVybnMgb2JqZWN0IGNvbnNpc3Rpbmcgb2YgYWxsIHByb3BlcnRpZXMgaW4gdGhlIG9yaWdpbmFsIGVsZW1lbnRcbiAqIHdoaWNoIHdlcmUgdHJ1dGh5IGdpdmVuIHRoZSBwcmVkaWNhdGUuXG4gKiBJZiB0aGUgcHJlZGljYXRlIGlzXG4gKiAgICogbWlzc2luZyAtIGl0IHdpbGwgcmVtb3ZlIGFsbCBwcm9wZXJ0aWVzIHdob3NlIHZhbHVlcyBhcmUgYHVuZGVmaW5lZGBcbiAqICAgKiBhIHNjYWxhciAtIGl0IHdpbGwgdGVzdCBhbGwgcHJvcGVydGllcycgdmFsdWVzIGFnYWluc3QgdGhhdCB2YWx1ZVxuICogICAqIGEgZnVuY3Rpb24gLSBpdCB3aWxsIHBhc3MgZWFjaCB2YWx1ZSBhbmQgdGhlIG9yaWdpbmFsIG9iamVjdCBpbnRvIHRoZSBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBmaWx0ZXJPYmplY3QgKG9iaiwgcHJlZGljYXRlKSB7XG4gIGxldCBuZXdPYmogPSBfLmNsb25lKG9iaik7XG4gIGlmIChfLmlzVW5kZWZpbmVkKHByZWRpY2F0ZSkpIHtcbiAgICAvLyByZW1vdmUgYW55IGVsZW1lbnQgZnJvbSB0aGUgb2JqZWN0IHdob3NlIHZhbHVlIGlzIHVuZGVmaW5lZFxuICAgIHByZWRpY2F0ZSA9ICh2KSA9PiAhXy5pc1VuZGVmaW5lZCh2KTtcbiAgfSBlbHNlIGlmICghXy5pc0Z1bmN0aW9uKHByZWRpY2F0ZSkpIHtcbiAgICAvLyBtYWtlIHByZWRpY2F0ZSBpbnRvIGEgZnVuY3Rpb25cbiAgICBjb25zdCB2YWx1ZVByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICBwcmVkaWNhdGUgPSAodikgPT4gdiA9PT0gdmFsdWVQcmVkaWNhdGU7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgIGlmICghcHJlZGljYXRlKG9ialtrZXldLCBvYmopKSB7XG4gICAgICBkZWxldGUgbmV3T2JqW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdPYmo7XG59XG5cbi8qKlxuICogQ29udmVydHMgbnVtYmVyIG9mIGJ5dGVzIHRvIGEgcmVhZGFibGUgc2l6ZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBieXRlcyAtIFRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGFjdHVhbCBzdHJpbmcgcmVwcmVzZW50YXRpb24sIGZvciBleGFtcGxlXG4gKiAgICAgICAgICAgICAgICAgICAnMS4wMCBLQicgZm9yICcxMDI0IEInXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYnl0ZXMgY291bnQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyIG9yXG4gKiAgICAgICAgICAgICAgICAgaWYgaXQgaXMgbGVzcyB0aGFuIHplcm8uXG4gKi9cbmZ1bmN0aW9uIHRvUmVhZGFibGVTaXplU3RyaW5nIChieXRlcykge1xuICBjb25zdCBpbnRCeXRlcyA9IHBhcnNlSW50KGJ5dGVzLCAxMCk7XG4gIGlmIChpc05hTihpbnRCeXRlcykgfHwgaW50Qnl0ZXMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29udmVydCAnJHtieXRlc30nIHRvIGEgcmVhZGFibGUgc2l6ZSBmb3JtYXRgKTtcbiAgfVxuICBpZiAoaW50Qnl0ZXMgPj0gMTAyNCAqIDEwMjQgKiAxMDI0KSB7XG4gICAgcmV0dXJuIGAke3BhcnNlRmxvYXQoaW50Qnl0ZXMgLyAoMTAyNCAqIDEwMjQgKiAxMDI0LjApKS50b0ZpeGVkKDIpfSBHQmA7XG4gIH0gZWxzZSBpZiAoaW50Qnl0ZXMgPj0gMTAyNCAqIDEwMjQpIHtcbiAgICByZXR1cm4gYCR7cGFyc2VGbG9hdChpbnRCeXRlcyAvICgxMDI0ICogMTAyNC4wKSkudG9GaXhlZCgyKX0gTUJgO1xuICB9IGVsc2UgaWYgKGludEJ5dGVzID49IDEwMjQpIHtcbiAgICByZXR1cm4gYCR7cGFyc2VGbG9hdChpbnRCeXRlcyAvIDEwMjQuMCkudG9GaXhlZCgyKX0gS0JgO1xuICB9XG4gIHJldHVybiBgJHtpbnRCeXRlc30gQmA7XG59XG5cbmV4cG9ydCB7IGhhc1ZhbHVlLCBlc2NhcGVTcGFjZSwgZXNjYXBlU3BlY2lhbENoYXJzLCBsb2NhbElwLCBjYW5jZWxsYWJsZURlbGF5LFxuICAgICAgICAgbXVsdGlSZXNvbHZlLCBzYWZlSnNvblBhcnNlLCB1bndyYXBFbGVtZW50LCBmaWx0ZXJPYmplY3QsXG4gICAgICAgICB0b1JlYWRhYmxlU2l6ZVN0cmluZyB9O1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLiJ9
